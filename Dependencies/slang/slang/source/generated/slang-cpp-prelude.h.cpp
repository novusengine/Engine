// generated code; do not edit
#include "../source/core/slang-basic.h"
Slang::String get_slang_cpp_prelude()
{
Slang::StringBuilder sb;
sb << 
"#ifndef SLANG_CPP_PRELUDE_H\n"
"#define SLANG_CPP_PRELUDE_H\n"
"\n"
"// Because the signature of isnan, isfinite, and is isinf changed in C++, we use the macro\n"
"// to use the version in the std namespace.\n"
"// https://stackoverflow.com/questions/39130040/cmath-hides-isnan-in-math-h-in-c14-c11\n"
"\n"
"#ifdef SLANG_LLVM\n"
"#ifndef SLANG_LLVM_H\n"
"#define SLANG_LLVM_H\n"
"\n"
"// TODO(JS):\n"
"// Disable exception declspecs, as not supported on LLVM without some extra options.\n"
"// We could enable with `-fms-extensions`\n"
"#define SLANG_DISABLE_EXCEPTIONS 1\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"extern \"C\" void assertFailure(const char* msg);\n"
"#define SLANG_PRELUDE_EXPECT(VALUE, MSG) \\\n"
"    if (VALUE)                           \\\n"
"    {                                    \\\n"
"    }                                    \\\n"
"    else                                 \\\n"
"        assertFailure(\"assertion failed: '\" MSG \"'\")\n"
"#define SLANG_PRELUDE_ASSERT(VALUE) SLANG_PRELUDE_EXPECT(VALUE, #VALUE)\n"
"#else // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#define SLANG_PRELUDE_EXPECT(VALUE, MSG)\n"
"#define SLANG_PRELUDE_ASSERT(x)\n"
"#endif // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#endif\n"
"\n"
"/*\n"
"Taken from stddef.h\n"
"*/\n"
"\n"
"typedef __PTRDIFF_TYPE__ ptrdiff_t;\n"
"typedef __SIZE_TYPE__ size_t;\n"
"typedef __SIZE_TYPE__ rsize_t;\n"
"\n"
"// typedef __WCHAR_TYPE__ wchar_t;\n"
"\n"
"#if defined(__need_NULL)\n"
"#undef NULL\n"
"#ifdef __cplusplus\n"
"#if !defined(__MINGW32__) && !defined(_MSC_VER)\n"
"#define NULL __null\n"
"#else\n"
"#define NULL 0\n"
"#endif\n"
"#else\n"
"#define NULL ((void*)0)\n"
"#endif\n"
"#ifdef __cplusplus\n"
"#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)\n"
"namespace std\n"
"{\n"
"typedef decltype(nullptr) nullptr_t;\n"
"}\n"
"using ::std::nullptr_t;\n"
"#endif\n"
"#endif\n"
"#undef __need_NULL\n"
"#endif /* defined(__need_NULL) */\n"
"\n"
"\n"
"/*\n"
"The following are taken verbatim from stdint.h from Clang in LLVM. Only 8/16/32/64 types are needed.\n"
"*/\n"
"\n"
"// LLVM/Clang types such that we can use LLVM/Clang without headers for C++ output from Slang\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int64_t*/\n"
"typedef __INT64_TYPE__ int64_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT64_TYPE__ uint64_t;\n"
"#define __int_least64_t int64_t\n"
"#define __uint_least64_t uint64_t\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"typedef __int_least64_t int_least64_t;\n"
"typedef __uint_least64_t uint_least64_t;\n"
"typedef __int_least64_t int_fast64_t;\n"
"typedef __uint_least64_t uint_fast64_t;\n"
"#endif /* __int_least64_t */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int32_t*/\n"
"typedef __INT32_TYPE__ int32_t;\n"
"#endif /* __int8_t_defined */\n"
"\n"
"#ifndef __uint32_t_defined /* more glibc compatibility */\n"
"#define __uint32_t_defined\n"
"typedef __UINT32_TYPE__ uint32_t;\n"
"#endif /* __uint32_t_defined */\n"
"\n"
"#define __int_least32_t int32_t\n"
"#define __uint_least32_t uint32_t\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"typedef __int_least32_t int_least32_t;\n"
"typedef __uint_least32_t uint_least32_t;\n"
"typedef __int_least32_t int_fast32_t;\n"
"typedef __uint_least32_t uint_fast32_t;\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int16_t*/\n"
"typedef __INT16_TYPE__ int16_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT16_TYPE__ uint16_t;\n"
"#define __int_least16_t int16_t\n"
"#define __uint_least16_t uint16_t\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"typedef __int_least16_t int_least16_t;\n"
"typedef __uint_least16_t uint_least16_t;\n"
"typedef __int_least16_t int_fast16_t;\n"
"typedef __uint_least16_t uint_fast16_t;\n"
"#endif /* __int_least16_t */\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int8_t*/\n"
"typedef __INT8_TYPE__ int8_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT8_TYPE__ uint8_t;\n"
"#define __int_least8_t int8_t\n"
"#define __uint_least8_t uint8_t\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"typedef __int_least8_t int_least8_t;\n"
"typedef __uint_least8_t uint_least8_t;\n"
"typedef __int_least8_t int_fast8_t;\n"
"typedef __uint_least8_t uint_fast8_t;\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* prevent glibc sys/types.h from defining conflicting types */\n"
"#ifndef __int8_t_defined\n"
"#define __int8_t_defined\n"
"#endif /* __int8_t_defined */\n"
"\n"
"/* C99 7.18.1.4 Integer types capable of holding object pointers.\n"
" */\n"
"#define __stdint_join3(a, b, c) a##b##c\n"
"\n"
"#ifndef _INTPTR_T\n"
"#ifndef __intptr_t_defined\n"
"typedef __INTPTR_TYPE__ intptr_t;\n"
"#define __intptr_t_defined\n"
"#define _INTPTR_T\n"
"#endif\n"
"#endif\n"
"\n"
"#ifndef _UINTPTR_T\n"
"typedef __UINTPTR_TYPE__ uintptr_t;\n"
"#define _UINTPTR_T\n"
"#endif\n"
"\n"
"/* C99 7.18.1.5 Greatest-width integer types.\n"
" */\n"
"typedef __INTMAX_TYPE__ intmax_t;\n"
"typedef __UINTMAX_TYPE__ uintmax_t;\n"
"\n"
"/* C99 7.18.4 Macros for minimum-width integer constants.\n"
" *\n"
" * The standard requires that integer constant macros be defined for all the\n"
" * minimum-width types defined above. As 8-, 16-, 32-, and 64-bit minimum-width\n"
" * types are required, the corresponding integer constant macros are defined\n"
" * here. This implementation also defines minimum-width types for every other\n"
" * integer width that the target implements, so corresponding macros are\n"
" * defined below, too.\n"
" *\n"
" * These macros are defined using the same successive-shrinking approach as\n"
" * the type definitions above. It is likewise important that macros are defined\n"
" * in order of decending width.\n"
" *\n"
" * Note that C++ should not check __STDC_CONSTANT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#define __int_c_join(a, b) a##b\n"
"#define __int_c(v, suffix) __int_c_join(v, suffix)\n"
"#define __uint_c(v, suffix) __int_c_join(v##U, suffix)\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"#ifdef __INT64_C_SUFFIX__\n"
"#define __int64_c_suffix __INT64_C_SUFFIX__\n"
"#else\n"
"#undef __int64_c_suffix\n"
"#endif /* __INT64_C_SUFFIX__ */\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"#ifdef __int64_c_suffix\n"
"#define INT64_C(v) __int_c(v, __int64_c_suffix)\n"
"#define UINT64_C(v) __uint_c(v, __int64_c_suffix)\n"
"#else\n"
"#define INT64_C(v) v\n"
"#define UINT64_C(v) v##U\n"
"#endif /* __int64_c_suffix */\n"
"#endif /* __int_least64_t */\n"
"\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"#ifdef __INT32_C_SUFFIX__\n"
"#define __int32_c_suffix __INT32_C_SUFFIX__\n"
"#else\n"
"#undef __int32_c_suffix\n"
"#endif /* __INT32_C_SUFFIX__ */\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"#ifdef __int32_c_suffix\n"
"#define INT32_C(v) __int_c(v, __int32_c_suffix)\n"
"#define UINT32_C(v) __uint_c(v, __int32_c_suffix)\n"
"#else\n"
"#define INT32_C(v) v\n"
"#define UINT32_C(v) v##U\n"
"#endif /* __int32_c_suffix */\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#ifdef __INT16_C_SUFFIX__\n"
"#define __int16_c_suffix __INT16_C_SUFFIX__\n"
"#else\n"
"#undef __int16_c_suffix\n"
"#endif /* __INT16_C_SUFFIX__ */\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"#ifdef __int16_c_suffix\n"
"#define INT16_C(v) __int_c(v, __int16_c_suffix)\n"
"#define UINT16_C(v) __uint_c(v, __int16_c_suffix)\n"
"#else\n"
"#define INT16_C(v) v\n"
"#define UINT16_C(v) v##U\n"
"#endif /* __int16_c_suffix */\n"
"#endif /* __int_least16_t */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#ifdef __INT8_C_SUFFIX__\n"
"#define __int8_c_suffix __INT8_C_SUFFIX__\n"
"#else\n"
"#undef __int8_c_suffix\n"
"#endif /* __INT8_C_SUFFIX__ */\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"#ifdef __int8_c_suffix\n"
"#define INT8_C(v) __int_c(v, __int8_c_suffix)\n"
"#define UINT8_C(v) __uint_c(v, __int8_c_suffix)\n"
"#else\n"
"#define INT8_C(v) v\n"
"#define UINT8_C(v) v##U\n"
"#endif /* __int8_c_suffix */\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* C99 7.18.2.1 Limits of exact-width integer types.\n"
" * C99 7.18.2.2 Limits of minimum-width integer types.\n"
" * C99 7.18.2.3 Limits of fastest minimum-width integer types.\n"
" *\n"
" * The presence of limit macros are completely optional in C99.  This\n"
" * implementation defines limits for all of the types (exact- and\n"
" * minimum-width) that it defines above, using the limits of the minimum-width\n"
" * type for any types that do not have exact-width representations.\n"
" *\n"
" * As in the type definitions, this section takes an approach of\n"
" * successive-shrinking to determine which limits to use for the standard (8,\n"
" * 16, 32, 64) bit widths when they don't have exact representations. It is\n"
" * therefore important that the definitions be kept in order of decending\n"
" * widths.\n"
" *\n"
" * Note that C++ should not check __STDC_LIMIT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"#define INT64_MAX INT64_C(9223372036854775807)\n"
"#define INT64_MIN (-INT64_C(9223372036854775807) - 1)\n"
"#define UINT64_MAX UINT64_C(18446744073709551615)\n"
"#define __INT_LEAST64_MIN INT64_MIN\n"
"#define __INT_LEAST64_MAX INT64_MAX\n"
"#define __UINT_LEAST64_MAX UINT64_MAX\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST64_MIN\n"
"#define INT_LEAST64_MIN __INT_LEAST64_MIN\n"
"#define INT_LEAST64_MAX __INT_LEAST64_MAX\n"
"#define UINT_LEAST64_MAX __UINT_LEAST64_MAX\n"
"#define INT_FAST64_MIN __INT_LEAST64_MIN\n"
"#define INT_FAST64_MAX __INT_LEAST64_MAX\n"
"#define UINT_FAST64_MAX __UINT_LEAST64_MAX\n"
"#endif /* __INT_LEAST64_MIN */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"#define INT32_MAX INT32_C(2147483647)\n"
"#define INT32_MIN (-INT32_C(2147483647) - 1)\n"
"#define UINT32_MAX UINT32_C(4294967295)\n"
"#define __INT_LEAST32_MIN INT32_MIN\n"
"#define __INT_LEAST32_MAX INT32_MAX\n"
"#define __UINT_LEAST32_MAX UINT32_MAX\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST32_MIN\n"
"#define INT_LEAST32_MIN __INT_LEAST32_MIN\n"
"#define INT_LEAST32_MAX __INT_LEAST32_MAX\n"
"#define UINT_LEAST32_MAX __UINT_LEAST32_MAX\n"
"#define INT_FAST32_MIN __INT_LEAST32_MIN\n"
"#define INT_FAST32_MAX __INT_LEAST32_MAX\n"
"#define UINT_FAST32_MAX __UINT_LEAST32_MAX\n"
"#endif /* __INT_LEAST32_MIN */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#define INT16_MAX INT16_C(32767)\n"
"#define INT16_MIN (-INT16_C(32767) - 1)\n"
"#define UINT16_MAX UINT16_C(65535)\n"
"#define __INT_LEAST16_MIN INT16_MIN\n"
"#define __INT_LEAST16_MAX INT16_MAX\n"
"#define __UINT_LEAST16_MAX UINT16_MAX\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST16_MIN\n"
"#define INT_LEAST16_MIN __INT_LEAST16_MIN\n"
"#define INT_LEAST16_MAX __INT_LEAST16_MAX\n"
"#define UINT_LEAST16_MAX __UINT_LEAST16_MAX\n"
"#define INT_FAST16_MIN __INT_LEAST16_MIN\n"
"#define INT_FAST16_MAX __INT_LEAST16_MAX\n"
"#define UINT_FAST16_MAX __UINT_LEAST16_MAX\n"
"#endif /* __INT_LEAST16_MIN */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#define INT8_MAX INT8_C(127)\n"
"#define INT8_MIN (-INT8_C(127) - 1)\n"
"#define UINT8_MAX UINT8_C(255)\n"
"#define __INT_LEAST8_MIN INT8_MIN\n"
"#define __INT_LEAST8_MAX INT8_MAX\n"
"#define __UINT_LEAST8_MAX UINT8_MAX\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST8_MIN\n"
"#define INT_LEAST8_MIN __INT_LEAST8_MIN\n"
"#define INT_LEAST8_MAX __INT_LEAST8_MAX\n"
"#define UINT_LEAST8_MAX __UINT_LEAST8_MAX\n"
"#define INT_FAST8_MIN __INT_LEAST8_MIN\n"
"#define INT_FAST8_MAX __INT_LEAST8_MAX\n"
"#define UINT_FAST8_MAX __UINT_LEAST8_MAX\n"
"#endif /* __INT_LEAST8_MIN */\n"
"\n"
"/* Some utility macros */\n"
"#define __INTN_MIN(n) __stdint_join3(INT, n, _MIN)\n"
"#define __INTN_MAX(n) __stdint_join3(INT, n, _MAX)\n"
"#define __UINTN_MAX(n) __stdint_join3(UINT, n, _MAX)\n"
"#define __INTN_C(n, v) __stdint_join3(INT, n, _C(v))\n"
"#define __UINTN_C(n, v) __stdint_join3(UINT, n, _C(v))\n"
"\n"
"/* C99 7.18.2.4 Limits of integer types capable of holding object pointers. */\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"\n"
"#define INTPTR_MIN (-__INTPTR_MAX__ - 1)\n"
"#define INTPTR_MAX __INTPTR_MAX__\n"
"#define UINTPTR_MAX __UINTPTR_MAX__\n"
"#define PTRDIFF_MIN (-__PTRDIFF_MAX__ - 1)\n"
"#define PTRDIFF_MAX __PTRDIFF_MAX__\n"
"#define SIZE_MAX __SIZE_MAX__\n"
"\n"
"/* ISO9899:2011 7.20 (C11 Annex K): Define RSIZE_MAX if __STDC_WANT_LIB_EXT1__\n"
" * is enabled. */\n"
"#if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1\n"
"#define RSIZE_MAX (SIZE_MAX >> 1)\n"
"#endif\n"
"\n"
"/* C99 7.18.2.5 Limits of greatest-width integer types. */\n"
"#define INTMAX_MIN (-__INTMAX_MAX__ - 1)\n"
"#define INTMAX_MAX __INTMAX_MAX__\n"
"#define UINTMAX_MAX __UINTMAX_MAX__\n"
"\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"#define SIG_ATOMIC_MIN __INTN_MIN(__SIG_ATOMIC_WIDTH__)\n"
"#define SIG_ATOMIC_MAX __INTN_MAX(__SIG_ATOMIC_WIDTH__)\n"
"#ifdef __WINT_UNSIGNED__\n"
"#define WINT_MIN __UINTN_C(__WINT_WIDTH__, 0)\n"
"#define WINT_MAX __UINTN_MAX(__WINT_WIDTH__)\n"
"#else\n"
"#define WINT_MIN __INTN_MIN(__WINT_WIDTH__)\n"
"#define WINT_MAX __INTN_MAX(__WINT_WIDTH__)\n"
"#endif\n"
"\n"
"#ifndef WCHAR_MAX\n"
"#define WCHAR_MAX __WCHAR_MAX__\n"
"#endif\n"
"#ifndef WCHAR_MIN\n"
"#if __WCHAR_MAX__ == __INTN_MAX(__WCHAR_WIDTH__)\n"
"#define WCHAR_MIN __INTN_MIN(__WCHAR_WIDTH__)\n"
"#else\n"
"#define WCHAR_MIN __UINTN_C(__WCHAR_WIDTH__, 0)\n"
"#endif\n"
"#endif\n"
"\n"
"/* 7.18.4.2 Macros for greatest-width integer constants. */\n"
"#define INTMAX_C(v) __int_c(v, __INTMAX_C_SUFFIX__)\n"
"#define UINTMAX_C(v) __int_c(v, __UINTMAX_C_SUFFIX__)\n"
"\n"
"\n"
"#endif // SLANG_LLVM_H\n"
"\n"
"#else // SLANG_LLVM\n"
"#if SLANG_GCC_FAMILY && __GNUC__ < 6\n"
"#include <cmath>\n"
"#define SLANG_PRELUDE_STD std::\n"
"#else\n"
"#include <math.h>\n"
"#define SLANG_PRELUDE_STD\n"
"#endif\n"
"\n"
"#include <assert.h>\n"
"#include <stdint.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#endif // SLANG_LLVM\n"
"\n"
"// Is intptr_t not equal to equal-width sized integer type?\n"
"#if defined(__APPLE__)\n"
"#define SLANG_INTPTR_TYPE_IS_DISTINCT 1\n"
"#else\n"
"#define SLANG_INTPTR_TYPE_IS_DISTINCT 0\n"
"#endif\n"
"\n"
"#if defined(_MSC_VER)\n"
"#define SLANG_PRELUDE_SHARED_LIB_EXPORT __declspec(dllexport)\n"
"#else\n"
"#define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__((__visibility__(\"default\")))\n"
"// #   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__ ((dllexport))\n"
"// __attribute__((__visibility__(\"default\")))\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"#define SLANG_PRELUDE_EXTERN_C extern \"C\"\n"
"#define SLANG_PRELUDE_EXTERN_C_START \\\n"
"    extern \"C\"                       \\\n"
"    {\n"
"#define SLANG_PRELUDE_EXTERN_C_END }\n"
"#else\n"
"#define SLANG_PRELUDE_EXTERN_C\n"
"#define SLANG_PRELUDE_EXTERN_C_START\n"
"#define SLANG_PRELUDE_EXTERN_C_END\n"
"#endif\n"
"\n"
"#define SLANG_PRELUDE_EXPORT SLANG_PRELUDE_EXTERN_C SLANG_PRELUDE_SHARED_LIB_EXPORT\n"
"#define SLANG_PRELUDE_EXPORT_START SLANG_PRELUDE_EXTERN_C_START SLANG_PRELUDE_SHARED_LIB_EXPORT\n"
"#define SLANG_PRELUDE_EXPORT_END SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#ifndef INFINITY\n"
"// Must overflow for double\n"
"#define INFINITY float(1e+300 * 1e+300)\n"
"#endif\n"
"\n"
"#ifndef SLANG_INFINITY\n"
"#define SLANG_INFINITY INFINITY\n"
"#endif\n"
"\n"
"// Detect the compiler type\n"
"\n"
"#ifndef SLANG_COMPILER\n"
"#define SLANG_COMPILER\n"
"\n"
"/*\n"
"Compiler defines, see http://sourceforge.net/p/predef/wiki/Compilers/\n"
"NOTE that SLANG_VC holds the compiler version - not just 1 or 0\n"
"*/\n"
"#if defined(_MSC_VER)\n"
"#if _MSC_VER >= 1900\n"
"#define SLANG_VC 14\n"
"#elif _MSC_VER >= 1800\n"
"#define SLANG_VC 12\n"
"#elif _MSC_VER >= 1700\n"
"#define SLANG_VC 11\n"
"#elif _MSC_VER >= 1600\n"
"#define SLANG_VC 10\n"
"#elif _MSC_VER >= 1500\n"
"#define SLANG_VC 9\n"
"#else\n"
"#error \"unknown version of Visual C++ compiler\"\n"
"#endif\n"
"#elif defined(__clang__)\n"
"#define SLANG_CLANG 1\n"
"#elif defined(__SNC__)\n"
"#define SLANG_SNC 1\n"
"#elif defined(__ghs__)\n"
"#define SLANG_GHS 1\n"
"#elif defined(__GNUC__) /* note: __clang__, __SNC__, or __ghs__ imply __GNUC__ */\n"
"#define SLANG_GCC 1\n"
"#else\n"
"#error \"unknown compiler\"\n"
"#endif\n"
"/*\n"
"Any compilers not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#ifndef SLANG_VC\n"
"#define SLANG_VC 0\n"
"#endif\n"
"#ifndef SLANG_CLANG\n"
"#define SLANG_CLANG 0\n"
"#endif\n"
"#ifndef SLANG_SNC\n"
"#define SLANG_SNC 0\n"
"#endif\n"
"#ifndef SLANG_GHS\n"
"#define SLANG_GHS 0\n"
"#endif\n"
"#ifndef SLANG_GCC\n"
"#define SLANG_GCC 0\n"
"#endif\n"
"#endif /* SLANG_COMPILER */\n"
"\n"
"/*\n"
"The following section attempts to detect the target platform being compiled for.\n"
"\n"
"If an application defines `SLANG_PLATFORM` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_PLATFORM\n"
"#define SLANG_PLATFORM\n"
"/**\n"
"Operating system defines, see http://sourceforge.net/p/predef/wiki/OperatingSystems/\n"
"*/\n"
"#if defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_PARTITION_APP\n"
"#define SLANG_WINRT 1 /* Windows Runtime, either on Windows RT or Windows 8 */\n"
"#elif defined(XBOXONE)\n"
"#define SLANG_XBOXONE 1\n"
"#elif defined(_WIN64) /* note: XBOXONE implies _WIN64 */\n"
"#define SLANG_WIN64 1\n"
"#elif defined(_M_PPC)\n"
"#define SLANG_X360 1\n"
"#elif defined(_WIN32) /* note: _M_PPC implies _WIN32 */\n"
"#define SLANG_WIN32 1\n"
"#elif defined(__ANDROID__)\n"
"#define SLANG_ANDROID 1\n"
"#elif defined(__linux__) || defined(__CYGWIN__) /* note: __ANDROID__ implies __linux__ */\n"
"#define SLANG_LINUX 1\n"
"#elif defined(__APPLE__) && !defined(SLANG_LLVM)\n"
"#include \"TargetConditionals.h\"\n"
"#if TARGET_OS_MAC\n"
"#define SLANG_OSX 1\n"
"#else\n"
"#define SLANG_IOS 1\n"
"#endif\n"
"#elif defined(__APPLE__)\n"
"// On `slang-llvm` we can't inclue \"TargetConditionals.h\" in general, so for now assume its\n"
"// OSX.\n"
"#define SLANG_OSX 1\n"
"#elif defined(__CELLOS_LV2__)\n"
"#define SLANG_PS3 1\n"
"#elif defined(__ORBIS__)\n"
"#define SLANG_PS4 1\n"
"#elif defined(__SNC__) && defined(__arm__)\n"
"#define SLANG_PSP2 1\n"
"#elif defined(__ghs__)\n"
"#define SLANG_WIIU 1\n"
"#else\n"
"#error \"unknown target platform\"\n"
"#endif\n"
"\n"
"\n"
"/*\n"
"Any platforms not detected by the above logic are now now explicitly zeroed out.\n"
"*/\n"
"#ifndef SLANG_WINRT\n"
"#define SLANG_WINRT 0\n"
"#endif\n"
"#ifndef SLANG_XBOXONE\n"
"#define SLANG_XBOXONE 0\n"
"#endif\n"
"#ifndef SLANG_WIN64\n"
"#define SLANG_WIN64 0\n"
"#endif\n"
"#ifndef SLANG_X360\n"
"#define SLANG_X360 0\n"
"#endif\n"
"#ifndef SLANG_WIN32\n"
"#define SLANG_WIN32 0\n"
"#endif\n"
"#ifndef SLANG_ANDROID\n"
"#define SLANG_ANDROID 0\n"
"#endif\n"
"#ifndef SLANG_LINUX\n"
"#define SLANG_LINUX 0\n"
"#endif\n"
"#ifndef SLANG_IOS\n"
"#define SLANG_IOS 0\n"
"#endif\n"
"#ifndef SLANG_OSX\n"
;
sb << 
"#define SLANG_OSX 0\n"
"#endif\n"
"#ifndef SLANG_PS3\n"
"#define SLANG_PS3 0\n"
"#endif\n"
"#ifndef SLANG_PS4\n"
"#define SLANG_PS4 0\n"
"#endif\n"
"#ifndef SLANG_PSP2\n"
"#define SLANG_PSP2 0\n"
"#endif\n"
"#ifndef SLANG_WIIU\n"
"#define SLANG_WIIU 0\n"
"#endif\n"
"#endif /* SLANG_PLATFORM */\n"
"\n"
"/* Shorthands for \"families\" of compilers/platforms */\n"
"#define SLANG_GCC_FAMILY (SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC)\n"
"#define SLANG_WINDOWS_FAMILY (SLANG_WINRT || SLANG_WIN32 || SLANG_WIN64)\n"
"#define SLANG_MICROSOFT_FAMILY (SLANG_XBOXONE || SLANG_X360 || SLANG_WINDOWS_FAMILY)\n"
"#define SLANG_LINUX_FAMILY (SLANG_LINUX || SLANG_ANDROID)\n"
"#define SLANG_APPLE_FAMILY (SLANG_IOS || SLANG_OSX) /* equivalent to #if __APPLE__ */\n"
"#define SLANG_UNIX_FAMILY \\\n"
"    (SLANG_LINUX_FAMILY || SLANG_APPLE_FAMILY) /* shortcut for unix/posix platforms */\n"
"\n"
"// GCC Specific\n"
"#if SLANG_GCC_FAMILY\n"
"\n"
"#if INTPTR_MAX == INT64_MAX\n"
"#define SLANG_64BIT 1\n"
"#else\n"
"#define SLANG_64BIT 0\n"
"#endif\n"
"\n"
"#define SLANG_BREAKPOINT(id) __builtin_trap()\n"
"\n"
"// Use this macro instead of offsetof, because gcc produces warning if offsetof is used on a\n"
"// non POD type, even though it produces the correct result\n"
"#define SLANG_OFFSET_OF(T, ELEMENT) (size_t(&((T*)1)->ELEMENT) - 1)\n"
"#endif // SLANG_GCC_FAMILY\n"
"\n"
"// Microsoft VC specific\n"
"#if SLANG_VC\n"
"\n"
"#define SLANG_BREAKPOINT(id) __debugbreak();\n"
"\n"
"#endif // SLANG_VC\n"
"\n"
"// Default impls\n"
"\n"
"#ifndef SLANG_OFFSET_OF\n"
"#define SLANG_OFFSET_OF(X, Y) offsetof(X, Y)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BREAKPOINT\n"
"// Make it crash with a write to 0!\n"
"#define SLANG_BREAKPOINT(id) (*((int*)0) = int(id));\n"
"#endif\n"
"\n"
"// If slang.h has been included we don't need any of these definitions\n"
"#ifndef SLANG_H\n"
"\n"
"/* Macro for declaring if a method is no throw. Should be set before the return parameter. */\n"
"#ifndef SLANG_NO_THROW\n"
"#if SLANG_WINDOWS_FAMILY && !defined(SLANG_DISABLE_EXCEPTIONS)\n"
"#define SLANG_NO_THROW __declspec(nothrow)\n"
"#endif\n"
"#endif\n"
"#ifndef SLANG_NO_THROW\n"
"#define SLANG_NO_THROW\n"
"#endif\n"
"\n"
"/* The `SLANG_STDCALL` and `SLANG_MCALL` defines are used to set the calling\n"
"convention for interface methods.\n"
"*/\n"
"#ifndef SLANG_STDCALL\n"
"#if SLANG_MICROSOFT_FAMILY\n"
"#define SLANG_STDCALL __stdcall\n"
"#else\n"
"#define SLANG_STDCALL\n"
"#endif\n"
"#endif\n"
"#ifndef SLANG_MCALL\n"
"#define SLANG_MCALL SLANG_STDCALL\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"// TODO(JS): Should these be in slang-cpp-types.h?\n"
"// They are more likely to clash with slang.h\n"
"\n"
"struct SlangUUID\n"
"{\n"
"    uint32_t data1;\n"
"    uint16_t data2;\n"
"    uint16_t data3;\n"
"    uint8_t data4[8];\n"
"};\n"
"\n"
"typedef int32_t SlangResult;\n"
"\n"
"struct ISlangUnknown\n"
"{\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    queryInterface(SlangUUID const& uuid, void** outObject) = 0;\n"
"    virtual SLANG_NO_THROW uint32_t SLANG_MCALL addRef() = 0;\n"
"    virtual SLANG_NO_THROW uint32_t SLANG_MCALL release() = 0;\n"
"};\n"
"\n"
"#define SLANG_COM_INTERFACE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)             \\\n"
"public:                                                                          \\\n"
"    SLANG_FORCE_INLINE static const SlangUUID& getTypeGuid()                     \\\n"
"    {                                                                            \\\n"
"        static const SlangUUID guid = {a, b, c, d0, d1, d2, d3, d4, d5, d6, d7}; \\\n"
"        return guid;                                                             \\\n"
"    }\n"
"#endif // SLANG_H\n"
"\n"
"// Includes\n"
"\n"
"#ifndef SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"#define SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"\n"
"#if !defined(SLANG_LLVM) && SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"//  If we have visual studio and 64 bit processor, we can assume we have popcnt, and can include\n"
"//  x86 intrinsics\n"
"#include <intrin.h>\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE\n"
"{\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_PI\n"
"#define SLANG_PRELUDE_PI 3.14159265358979323846\n"
"#endif\n"
"\n"
"\n"
"union Union32\n"
"{\n"
"    uint32_t u;\n"
"    int32_t i;\n"
"    float f;\n"
"};\n"
"\n"
"union Union64\n"
"{\n"
"    uint64_t u;\n"
"    int64_t i;\n"
"    double d;\n"
"};\n"
"\n"
"// 32 bit cast conversions\n"
"SLANG_FORCE_INLINE int32_t _bitCastFloatToInt(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.i;\n"
"}\n"
"SLANG_FORCE_INLINE float _bitCastIntToFloat(int32_t i)\n"
"{\n"
"    Union32 u;\n"
"    u.i = i;\n"
"    return u.f;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t _bitCastFloatToUInt(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.u;\n"
"}\n"
"SLANG_FORCE_INLINE float _bitCastUIntToFloat(uint32_t ui)\n"
"{\n"
"    Union32 u;\n"
"    u.u = ui;\n"
"    return u.f;\n"
"}\n"
"\n"
"// ----------------------------- F16 -----------------------------------------\n"
"\n"
"\n"
"// This impl is based on FloatToHalf that is in Slang codebase\n"
"SLANG_FORCE_INLINE uint32_t f32tof16(const float value)\n"
"{\n"
"    const uint32_t inBits = _bitCastFloatToUInt(value);\n"
"\n"
"    // bits initially set to just the sign bit\n"
"    uint32_t bits = (inBits >> 16) & 0x8000;\n"
"    // Mantissa can't be used as is, as it holds last bit, for rounding.\n"
"    uint32_t m = (inBits >> 12) & 0x07ff;\n"
"    uint32_t e = (inBits >> 23) & 0xff;\n"
"\n"
"    if (e < 103)\n"
"    {\n"
"        // It's zero\n"
"        return bits;\n"
"    }\n"
"    if (e == 0xff)\n"
"    {\n"
"        // Could be a NAN or INF. Is INF if *input* mantissa is 0.\n"
"\n"
"        // Remove last bit for rounding to make output mantissa.\n"
"        m >>= 1;\n"
"\n"
"        // We *assume* float16/float32 signaling bit and remaining bits\n"
"        // semantics are the same. (The signalling bit convention is target specific!).\n"
"        // Non signal bit's usage within mantissa for a NAN are also target specific.\n"
"\n"
"        // If the m is 0, it could be because the result is INF, but it could also be because all\n"
"        // the bits that made NAN were dropped as we have less mantissa bits in f16.\n"
"\n"
"        // To fix for this we make non zero if m is 0 and the input mantissa was not.\n"
"        // This will (typically) produce a signalling NAN.\n"
"        m += uint32_t(m == 0 && (inBits & 0x007fffffu));\n"
"\n"
"        // Combine for output\n"
"        return (bits | 0x7c00u | m);\n"
"    }\n"
"    if (e > 142)\n"
"    {\n"
"        // INF.\n"
"        return bits | 0x7c00u;\n"
"    }\n"
"    if (e < 113)\n"
"    {\n"
"        m |= 0x0800u;\n"
"        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n"
"        return bits;\n"
"    }\n"
"    bits |= ((e - 112) << 10) | (m >> 1);\n"
"    bits += m & 1;\n"
"    return bits;\n"
"}\n"
"\n"
"static const float g_f16tof32Magic = _bitCastIntToFloat((127 + (127 - 15)) << 23);\n"
"\n"
"SLANG_FORCE_INLINE float f16tof32(const uint32_t value)\n"
"{\n"
"    const uint32_t sign = (value & 0x8000) << 16;\n"
"    uint32_t exponent = (value & 0x7c00) >> 10;\n"
"    uint32_t mantissa = (value & 0x03ff);\n"
"\n"
"    if (exponent == 0)\n"
"    {\n"
"        // If mantissa is 0 we are done, as output is 0.\n"
"        // If it's not zero we must have a denormal.\n"
"        if (mantissa)\n"
"        {\n"
"            // We have a denormal so use the magic to do exponent adjust\n"
"            return _bitCastIntToFloat(sign | ((value & 0x7fff) << 13)) * g_f16tof32Magic;\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        // If the exponent is NAN or INF exponent is 0x1f on input.\n"
"        // If that's the case, we just need to set the exponent to 0xff on output\n"
"        // and the mantissa can just stay the same. If its 0 it's INF, else it is NAN and we just\n"
"        // copy the bits\n"
"        //\n"
"        // Else we need to correct the exponent in the normalized case.\n"
"        exponent = (exponent == 0x1F) ? 0xff : (exponent + (-15 + 127));\n"
"    }\n"
"\n"
"    return _bitCastUIntToFloat(sign | (exponent << 23) | (mantissa << 13));\n"
"}\n"
"\n"
"// ----------------------------- F32 -----------------------------------------\n"
"\n"
"// Helpers\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary\n"
"float F32_ceil(float f);\n"
"float F32_floor(float f);\n"
"float F32_round(float f);\n"
"float F32_sin(float f);\n"
"float F32_cos(float f);\n"
"float F32_tan(float f);\n"
"float F32_asin(float f);\n"
"float F32_acos(float f);\n"
"float F32_atan(float f);\n"
"float F32_sinh(float f);\n"
"float F32_cosh(float f);\n"
"float F32_tanh(float f);\n"
"float F32_log2(float f);\n"
"float F32_log(float f);\n"
"float F32_log10(float f);\n"
"float F32_exp2(float f);\n"
"float F32_exp(float f);\n"
"float F32_abs(float f);\n"
"float F32_trunc(float f);\n"
"float F32_sqrt(float f);\n"
"\n"
"bool F32_isnan(float f);\n"
"bool F32_isfinite(float f);\n"
"bool F32_isinf(float f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"float F32_pow(float a, float b);\n"
"float F32_fmod(float a, float b);\n"
"float F32_remainder(float a, float b);\n"
"float F32_atan2(float a, float b);\n"
"\n"
"float F32_frexp(float x, int* e);\n"
"\n"
"float F32_modf(float x, float* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c)\n"
"{\n"
"    return a * b + c;\n"
"}\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else\n"
"\n"
"// Unary\n"
"SLANG_FORCE_INLINE float F32_ceil(float f)\n"
"{\n"
"    return ::ceilf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_floor(float f)\n"
"{\n"
"    return ::floorf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_round(float f)\n"
"{\n"
"    return ::roundf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sin(float f)\n"
"{\n"
"    return ::sinf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_cos(float f)\n"
"{\n"
"    return ::cosf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_tan(float f)\n"
"{\n"
"    return ::tanf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_asin(float f)\n"
"{\n"
"    return ::asinf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_acos(float f)\n"
"{\n"
"    return ::acosf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_atan(float f)\n"
"{\n"
"    return ::atanf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sinh(float f)\n"
"{\n"
"    return ::sinhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_cosh(float f)\n"
"{\n"
"    return ::coshf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_tanh(float f)\n"
"{\n"
"    return ::tanhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_asinh(float f)\n"
"{\n"
"    return ::asinhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_acosh(float f)\n"
"{\n"
"    return ::acoshf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_atanh(float f)\n"
"{\n"
"    return ::atanhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_log2(float f)\n"
"{\n"
"    return ::log2f(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_log(float f)\n"
"{\n"
"    return ::logf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_log10(float f)\n"
"{\n"
"    return ::log10f(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_exp2(float f)\n"
"{\n"
"    return ::exp2f(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_exp(float f)\n"
"{\n"
"    return ::expf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_abs(float f)\n"
"{\n"
"    return ::fabsf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_trunc(float f)\n"
"{\n"
"    return ::truncf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sqrt(float f)\n"
"{\n"
"    return ::sqrtf(f);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE bool F32_isnan(float f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isnan(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F32_isfinite(float f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isfinite(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F32_isinf(float f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isinf(f);\n"
"}\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b)\n"
"{\n"
"    return ::fminf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b)\n"
"{\n"
"    return ::fmaxf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_pow(float a, float b)\n"
"{\n"
"    return ::powf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_fmod(float a, float b)\n"
"{\n"
"    return ::fmodf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_remainder(float a, float b)\n"
"{\n"
"    return ::remainderf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_atan2(float a, float b)\n"
"{\n"
"    return float(::atan2(a, b));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_frexp(float x, int* e)\n"
"{\n"
"    return ::frexpf(x, e);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_modf(float x, float* ip)\n"
"{\n"
"    return ::modff(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c)\n"
"{\n"
"    return ::fmaf(a, b, c);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1\n"
"    float a = radians * (1.0f / float(SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F32_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"    return (a * float(SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_rsqrt(float f)\n"
"{\n"
"    return 1.0f / F32_sqrt(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sign(float f)\n"
"{\n"
"    return (f == 0.0f) ? f : ((f < 0.0f) ? -1.0f : 1.0f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_frac(float f)\n"
"{\n"
"    return f - F32_floor(f);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t F32_asuint(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.u;\n"
"}\n"
"SLANG_FORCE_INLINE int32_t F32_asint(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.i;\n"
"}\n"
"\n"
"// ----------------------------- F64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary\n"
"double F64_ceil(double f);\n"
"double F64_floor(double f);\n"
"double F64_round(double f);\n"
"double F64_sin(double f);\n"
"double F64_cos(double f);\n"
"double F64_tan(double f);\n"
"double F64_asin(double f);\n"
"double F64_acos(double f);\n"
"double F64_atan(double f);\n"
"double F64_sinh(double f);\n"
"double F64_cosh(double f);\n"
"double F64_tanh(double f);\n"
"double F64_log2(double f);\n"
"double F64_log(double f);\n"
"double F64_log10(double f);\n"
"double F64_exp2(double f);\n"
"double F64_exp(double f);\n"
"double F64_abs(double f);\n"
"double F64_trunc(double f);\n"
"double F64_sqrt(double f);\n"
"\n"
"bool F64_isnan(double f);\n"
"bool F64_isfinite(double f);\n"
"bool F64_isinf(double f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"double F64_pow(double a, double b);\n"
"double F64_fmod(double a, double b);\n"
"double F64_remainder(double a, double b);\n"
"double F64_atan2(double a, double b);\n"
"\n"
"double F64_frexp(double x, int* e);\n"
"\n"
"double F64_modf(double x, double* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c)\n"
"{\n"
"    return a * b + c;\n"
"}\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"// Unary\n"
"SLANG_FORCE_INLINE double F64_ceil(double f)\n"
"{\n"
"    return ::ceil(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_floor(double f)\n"
"{\n"
"    return ::floor(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_round(double f)\n"
"{\n"
"    return ::round(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sin(double f)\n"
"{\n"
"    return ::sin(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_cos(double f)\n"
"{\n"
"    return ::cos(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_tan(double f)\n"
"{\n"
"    return ::tan(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_asin(double f)\n"
"{\n"
"    return ::asin(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_acos(double f)\n"
"{\n"
"    return ::acos(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_atan(double f)\n"
"{\n"
"    return ::atan(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sinh(double f)\n"
"{\n"
"    return ::sinh(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_cosh(double f)\n"
"{\n"
"    return ::cosh(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_tanh(double f)\n"
"{\n"
"    return ::tanh(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_log2(double f)\n"
"{\n"
"    return ::log2(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_log(double f)\n"
"{\n"
"    return ::log(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_log10(float f)\n"
"{\n"
"    return ::log10(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_exp2(double f)\n"
"{\n"
"    return ::exp2(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_exp(double f)\n"
"{\n"
"    return ::exp(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_abs(double f)\n"
"{\n"
"    return ::fabs(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_trunc(double f)\n"
"{\n"
"    return ::trunc(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sqrt(double f)\n"
"{\n"
"    return ::sqrt(f);\n"
"}\n"
"\n"
"\n"
"SLANG_FORCE_INLINE bool F64_isnan(double f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isnan(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F64_isfinite(double f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isfinite(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F64_isinf(double f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isinf(f);\n"
"}\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b)\n"
"{\n"
"    return ::fmin(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b)\n"
"{\n"
"    return ::fmax(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_pow(double a, double b)\n"
"{\n"
"    return ::pow(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_fmod(double a, double b)\n"
"{\n"
"    return ::fmod(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_remainder(double a, double b)\n"
"{\n"
"    return ::remainder(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_atan2(double a, double b)\n"
"{\n"
"    return ::atan2(a, b);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_frexp(double x, int* e)\n"
"{\n"
"    return ::frexp(x, e);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_modf(double x, double* ip)\n"
"{\n"
"    return ::modf(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c)\n"
"{\n"
"    return ::fma(a, b, c);\n"
"}\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"SLANG_FORCE_INLINE double F64_rsqrt(double f)\n"
"{\n"
"    return 1.0 / F64_sqrt(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sign(double f)\n"
"{\n"
"    return (f == 0.0) ? f : ((f < 0.0) ? -1.0 : 1.0);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_frac(double f)\n"
"{\n"
"    return f - F64_floor(f);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void F64_asuint(double d, uint32_t* low, uint32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = uint32_t(u.u);\n"
"    *hi = uint32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void F64_asint(double d, int32_t* low, int32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = int32_t(u.u);\n"
"    *hi = int32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1\n"
"    double a = radians * (1.0f / (SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F64_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"    return (a * (SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"// ----------------------------- U16 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t U16_countbits(uint16_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
;
sb << 
"    return __builtin_popcount(uint32_t(v));\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return __popcnt16(v);\n"
"#else\n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I16 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t I16_countbits(int16_t v)\n"
"{\n"
"    return U16_countbits(uint16_t(v));\n"
"}\n"
"\n"
"// ----------------------------- U8 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t U8_countbits(uint8_t v)\n"
"{\n"
"    // No native 8bit __popcnt yet, just cast and use 16bit variant\n"
"    return U16_countbits(uint16_t(v));\n"
"}\n"
"\n"
"// ----------------------------- I8 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t I8_countbits(int16_t v)\n"
"{\n"
"    return U8_countbits(uint8_t(v));\n"
"}\n"
"\n"
"// ----------------------------- U32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_abs(uint32_t f)\n"
"{\n"
"    return f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_min(uint32_t a, uint32_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t U32_max(uint32_t a, uint32_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float U32_asfloat(uint32_t x)\n"
"{\n"
"    Union32 u;\n"
"    u.u = x;\n"
"    return u.f;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t U32_asint(int32_t x)\n"
"{\n"
"    return uint32_t(x);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double U32_asdouble(uint32_t low, uint32_t hi)\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | low;\n"
"    return u.d;\n"
"}\n"
"\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_countbits(uint32_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return __builtin_popcount(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return __popcnt(v);\n"
"#else\n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_firstbitlow(uint32_t v)\n"
"{\n"
"    if (v == 0)\n"
"        return ~0u;\n"
"\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    // __builtin_ctz returns number of trailing zeros, which is the 0-based index of first set bit\n"
"    return __builtin_ctz(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    // _BitScanForward returns 1 on success, 0 on failure, and sets index\n"
"    unsigned long index;\n"
"    return _BitScanForward(&index, v) ? index : ~0u;\n"
"#else\n"
"    // Generic implementation - find first set bit\n"
"    uint32_t result = 0;\n"
"    while (result < 32 && !(v & (1u << result)))\n"
"        result++;\n"
"    return result;\n"
"#endif\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_firstbithigh(uint32_t v)\n"
"{\n"
"    if ((int32_t)v < 0)\n"
"        v = ~v;\n"
"    if (v == 0)\n"
"        return ~0u;\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    // __builtin_clz returns number of leading zeros\n"
"    // firstbithigh should return 0-based bit position of MSB\n"
"    return 31 - __builtin_clz(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    // _BitScanReverse returns 1 on success, 0 on failure, and sets index\n"
"    unsigned long index;\n"
"    return _BitScanReverse(&index, v) ? index : ~0u;\n"
"#else\n"
"    // Generic implementation - find highest set bit\n"
"    int result = 31;\n"
"    while (result >= 0 && !(v & (1u << result)))\n"
"        result--;\n"
"    return result;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_abs(int32_t f)\n"
"{\n"
"    return (f < 0) ? -f : f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_min(int32_t a, int32_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE int32_t I32_max(int32_t a, int32_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float I32_asfloat(int32_t x)\n"
"{\n"
"    Union32 u;\n"
"    u.i = x;\n"
"    return u.f;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t I32_asuint(int32_t x)\n"
"{\n"
"    return uint32_t(x);\n"
"}\n"
"SLANG_FORCE_INLINE double I32_asdouble(int32_t low, int32_t hi)\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | uint32_t(low);\n"
"    return u.d;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I32_countbits(int32_t v)\n"
"{\n"
"    return U32_countbits(uint32_t(v));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I32_firstbitlow(int32_t v)\n"
"{\n"
"    return U32_firstbitlow(uint32_t(v));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I32_firstbithigh(int32_t v)\n"
"{\n"
"    return U32_firstbithigh(uint32_t(v));\n"
"}\n"
"\n"
"// ----------------------------- U64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_abs(uint64_t f)\n"
"{\n"
"    return f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_min(uint64_t a, uint64_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE uint64_t U64_max(uint64_t a, uint64_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U64_countbits(uint64_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return uint32_t(__builtin_popcountll(v));\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return uint32_t(__popcnt64(v));\n"
"#else\n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_abs(int64_t f)\n"
"{\n"
"    return (f < 0) ? -f : f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_min(int64_t a, int64_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE int64_t I64_max(int64_t a, int64_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I64_countbits(int64_t v)\n"
"{\n"
"    return U64_countbits(uint64_t(v));\n"
"}\n"
"\n"
"// ----------------------------- UPTR -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uintptr_t UPTR_abs(uintptr_t f)\n"
"{\n"
"    return f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uintptr_t UPTR_min(uintptr_t a, uintptr_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uintptr_t UPTR_max(uintptr_t a, uintptr_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"// ----------------------------- IPTR -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE intptr_t IPTR_abs(intptr_t f)\n"
"{\n"
"    return (f < 0) ? -f : f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE intptr_t IPTR_min(intptr_t a, intptr_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE intptr_t IPTR_max(intptr_t a, intptr_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"// ----------------------------- Interlocked ---------------------------------\n"
"\n"
"#if SLANG_LLVM\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"#ifdef _WIN32\n"
"#include <intrin.h>\n"
"#endif\n"
"\n"
"SLANG_FORCE_INLINE void InterlockedAdd(uint32_t* dest, uint32_t value, uint32_t* oldValue)\n"
"{\n"
"#ifdef _WIN32\n"
"    *oldValue = _InterlockedExchangeAdd((long*)dest, (long)value);\n"
"#else\n"
"    *oldValue = __sync_fetch_and_add(dest, value);\n"
"#endif\n"
"}\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"\n"
"// ----------------------- fmod --------------------------\n"
"SLANG_FORCE_INLINE float _slang_fmod(float x, float y)\n"
"{\n"
"    return F32_fmod(x, y);\n"
"}\n"
"SLANG_FORCE_INLINE double _slang_fmod(double x, double y)\n"
"{\n"
"    return F64_fmod(x, y);\n"
"}\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_CPP_TYPES_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_H\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE\n"
"{\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"#define SLANG_PRELUDE_ASSERT(VALUE) assert(VALUE)\n"
"#else\n"
"#define SLANG_PRELUDE_ASSERT(VALUE)\n"
"#endif\n"
"#endif\n"
"\n"
"// Since we are using unsigned arithmatic care is need in this comparison.\n"
"// It is *assumed* that sizeInBytes >= elemSize. Which means (sizeInBytes >= elemSize) >= 0\n"
"// Which means only a single test is needed\n"
"\n"
"// Asserts for bounds checking.\n"
"// It is assumed index/count are unsigned types.\n"
"#define SLANG_BOUND_ASSERT(index, count) SLANG_PRELUDE_ASSERT(index < count);\n"
"#define SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    SLANG_PRELUDE_ASSERT(index <= (sizeInBytes - elemSize) && (index & 3) == 0);\n"
"\n"
"// Macros to zero index if an access is out of range\n"
"#define SLANG_BOUND_ZERO_INDEX(index, count) index = (index < count) ? index : 0;\n"
"#define SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    index = (index <= (sizeInBytes - elemSize)) ? index : 0;\n"
"\n"
"// The 'FIX' macro define how the index is fixed. The default is to do nothing. If\n"
"// SLANG_ENABLE_BOUND_ZERO_INDEX the fix macro will zero the index, if out of range\n"
"#ifdef SLANG_ENABLE_BOUND_ZERO_INDEX\n"
"#define SLANG_BOUND_FIX(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#define SLANG_BOUND_FIX_FIXED_ARRAY(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#else\n"
"#define SLANG_BOUND_FIX(index, count)\n"
"#define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#define SLANG_BOUND_FIX_FIXED_ARRAY(index, count)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK\n"
"#define SLANG_BOUND_CHECK(index, count) \\\n"
"    SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX(index, count)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_BYTE_ADDRESS\n"
"#define SLANG_BOUND_CHECK_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes)    \\\n"
"    SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_FIXED_ARRAY\n"
"#define SLANG_BOUND_CHECK_FIXED_ARRAY(index, count) \\\n"
"    SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX_FIXED_ARRAY(index, count)\n"
"#endif\n"
"\n"
"struct TypeInfo\n"
"{\n"
"    size_t typeSize;\n"
"};\n"
"\n"
"template<typename T, size_t SIZE>\n"
"struct FixedArray\n"
"{\n"
"    const T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE);\n"
"        return m_data[index];\n"
"    }\n"
"    T& operator[](size_t index)\n"
"    {\n"
"        SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE);\n"
"        return m_data[index];\n"
"    }\n"
"\n"
"    T m_data[SIZE];\n"
"};\n"
"\n"
"// An array that has no specified size, becomes a 'Array'. This stores the size so it can\n"
"// potentially do bounds checking.\n"
"template<typename T>\n"
"struct Array\n"
"{\n"
"    const T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    T& operator[](size_t index)\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"/* Constant buffers become a pointer to the contained type, so ConstantBuffer<T> becomes T* in C++\n"
" * code.\n"
" */\n"
"\n"
"template<typename T, int COUNT>\n"
"struct Vector;\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 1>\n"
"{\n"
"    T x;\n"
"    const T& operator[](size_t /*index*/) const { return x; }\n"
"    T& operator[](size_t /*index*/) { return x; }\n"
"    operator T() const { return x; }\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = scalar; }\n"
"    template<typename U>\n"
"    Vector(Vector<U, 1> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 1;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 2>\n"
"{\n"
"    T x, y;\n"
"    const T& operator[](size_t index) const { return index == 0 ? x : y; }\n"
"    T& operator[](size_t index) { return index == 0 ? x : y; }\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = y = scalar; }\n"
"    Vector(T _x, T _y)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"    }\n"
"    template<typename U>\n"
"    Vector(Vector<U, 2> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 2;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 3>\n"
"{\n"
"    T x, y, z;\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = y = z = scalar; }\n"
"    Vector(T _x, T _y, T _z)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"    }\n"
"    template<typename U>\n"
"    Vector(Vector<U, 3> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"        z = (T)other.z;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 3;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 4>\n"
"{\n"
"    T x, y, z, w;\n"
"\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = y = z = w = scalar; }\n"
"    Vector(T _x, T _y, T _z, T _w)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"        w = _w;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 4;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE Vector<T, N> _slang_select(\n"
"    Vector<bool, N> condition,\n"
"    Vector<T, N> v0,\n"
"    Vector<T, N> v1)\n"
"{\n"
"    Vector<T, N> result;\n"
"    for (int i = 0; i < N; i++)\n"
"    {\n"
"        result[i] = condition[i] ? v0[i] : v1[i];\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE T _slang_select(bool condition, T v0, T v1)\n"
"{\n"
"    return condition ? v0 : v1;\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T _slang_vector_get_element(Vector<T, N> x, int index)\n"
"{\n"
"    return x[index];\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE const T* _slang_vector_get_element_ptr(const Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*const_cast<Vector<T, N>*>(x))[index]);\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T* _slang_vector_get_element_ptr(Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*x)[index]);\n"
"}\n"
"\n"
"template<typename T, int n, typename OtherT, int m>\n"
"SLANG_FORCE_INLINE Vector<T, n> _slang_vector_reshape(const Vector<OtherT, m> other)\n"
"{\n"
"    Vector<T, n> result;\n"
"    for (int i = 0; i < n; i++)\n"
"    {\n"
"        OtherT otherElement = T(0);\n"
"        if (i < m)\n"
"            otherElement = _slang_vector_get_element(other, i);\n"
"        *_slang_vector_get_element_ptr(&result, i) = (T)otherElement;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"typedef uint32_t uint;\n"
"\n"
"#define SLANG_VECTOR_BINARY_OP(T, op)            \\\n"
"    template<int n>                              \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op( \\\n"
"        const Vector<T, n>& thisVal,             \\\n"
"        const Vector<T, n>& other)               \\\n"
"    {                                            \\\n"
"        Vector<T, n> result;                     \\\n"
"        for (int i = 0; i < n; i++)              \\\n"
"            result[i] = thisVal[i] op other[i];  \\\n"
"        return result;                           \\\n"
"    }\n"
"#define SLANG_VECTOR_BINARY_COMPARE_OP(T, op)       \\\n"
"    template<int n>                                 \\\n"
"    SLANG_FORCE_INLINE Vector<bool, n> operator op( \\\n"
"        const Vector<T, n>& thisVal,                \\\n"
"        const Vector<T, n>& other)                  \\\n"
"    {                                               \\\n"
"        Vector<bool, n> result;                     \\\n"
"        for (int i = 0; i < n; i++)                 \\\n"
"            result[i] = thisVal[i] op other[i];     \\\n"
"        return result;                              \\\n"
"    }\n"
"\n"
"#define SLANG_VECTOR_UNARY_OP(T, op)                                         \\\n"
"    template<int n>                                                          \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op(const Vector<T, n>& thisVal) \\\n"
"    {                                                                        \\\n"
"        Vector<T, n> result;                                                 \\\n"
"        for (int i = 0; i < n; i++)                                          \\\n"
"            result[i] = op thisVal[i];                                       \\\n"
"        return result;                                                       \\\n"
"    }\n"
"#define SLANG_INT_VECTOR_OPS(T)           \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, /)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, &)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, |)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, &&)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, ||)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, ^)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, %)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, >>)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, <<)         \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)  \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=) \\\n"
"    SLANG_VECTOR_UNARY_OP(T, !)           \\\n"
"    SLANG_VECTOR_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_VECTOR_OPS(T)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, /)          \\\n"
"    SLANG_VECTOR_UNARY_OP(T, -)           \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)  \\\n"
;
sb << 
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=)\n"
"\n"
"SLANG_INT_VECTOR_OPS(bool)\n"
"SLANG_INT_VECTOR_OPS(int)\n"
"SLANG_INT_VECTOR_OPS(int8_t)\n"
"SLANG_INT_VECTOR_OPS(int16_t)\n"
"SLANG_INT_VECTOR_OPS(int64_t)\n"
"SLANG_INT_VECTOR_OPS(uint)\n"
"SLANG_INT_VECTOR_OPS(uint8_t)\n"
"SLANG_INT_VECTOR_OPS(uint16_t)\n"
"SLANG_INT_VECTOR_OPS(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_INT_VECTOR_OPS(intptr_t)\n"
"SLANG_INT_VECTOR_OPS(uintptr_t)\n"
"#endif\n"
"\n"
"SLANG_FLOAT_VECTOR_OPS(float)\n"
"SLANG_FLOAT_VECTOR_OPS(double)\n"
"\n"
"#define SLANG_VECTOR_INT_NEG_OP(T)                      \\\n"
"    template<int N>                                     \\\n"
"    Vector<T, N> operator-(const Vector<T, N>& thisVal) \\\n"
"    {                                                   \\\n"
"        Vector<T, N> result;                            \\\n"
"        for (int i = 0; i < N; i++)                     \\\n"
"            result[i] = 0 - thisVal[i];                 \\\n"
"        return result;                                  \\\n"
"    }\n"
"SLANG_VECTOR_INT_NEG_OP(int)\n"
"SLANG_VECTOR_INT_NEG_OP(int8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int64_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint)\n"
"SLANG_VECTOR_INT_NEG_OP(uint8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_VECTOR_INT_NEG_OP(intptr_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uintptr_t)\n"
"#endif\n"
"\n"
"#define SLANG_FLOAT_VECTOR_MOD(T)                                               \\\n"
"    template<int N>                                                             \\\n"
"    Vector<T, N> operator%(const Vector<T, N>& left, const Vector<T, N>& right) \\\n"
"    {                                                                           \\\n"
"        Vector<T, N> result;                                                    \\\n"
"        for (int i = 0; i < N; i++)                                             \\\n"
"            result[i] = _slang_fmod(left[i], right[i]);                         \\\n"
"        return result;                                                          \\\n"
"    }\n"
"\n"
"SLANG_FLOAT_VECTOR_MOD(float)\n"
"SLANG_FLOAT_VECTOR_MOD(double)\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"#undef SLANG_VECTOR_BINARY_OP\n"
"#undef SLANG_VECTOR_UNARY_OP\n"
"#undef SLANG_INT_VECTOR_OPS\n"
"#undef SLANG_FLOAT_VECTOR_OPS\n"
"#undef SLANG_VECTOR_INT_NEG_OP\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"\n"
"template<typename T, int ROWS, int COLS>\n"
"struct Matrix\n"
"{\n"
"    Vector<T, COLS> rows[ROWS];\n"
"    const Vector<T, COLS>& operator[](size_t index) const { return rows[index]; }\n"
"    Vector<T, COLS>& operator[](size_t index) { return rows[index]; }\n"
"    Matrix() = default;\n"
"    Matrix(T scalar)\n"
"    {\n"
"        for (int i = 0; i < ROWS; i++)\n"
"            rows[i] = Vector<T, COLS>(scalar);\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0) { rows[0] = row0; }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1, const Vector<T, COLS>& row2)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"    }\n"
"    Matrix(\n"
"        const Vector<T, COLS>& row0,\n"
"        const Vector<T, COLS>& row1,\n"
"        const Vector<T, COLS>& row2,\n"
"        const Vector<T, COLS>& row3)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"        rows[3] = row3;\n"
"    }\n"
"    template<typename U, int otherRow, int otherCol>\n"
"    Matrix(const Matrix<U, otherRow, otherCol>& other)\n"
"    {\n"
"        int minRow = ROWS;\n"
"        int minCol = COLS;\n"
"        if (minRow > otherRow)\n"
"            minRow = otherRow;\n"
"        if (minCol > otherCol)\n"
"            minCol = otherCol;\n"
"        for (int i = 0; i < minRow; i++)\n"
"            for (int j = 0; j < minCol; j++)\n"
"                rows[i][j] = (T)other.rows[i][j];\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3)\n"
"    {\n"
"        rows[0][0] = v0;\n"
"        rows[0][1] = v1;\n"
"        rows[1][0] = v2;\n"
"        rows[1][1] = v3;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5)\n"
"    {\n"
"        if (COLS == 3)\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[1][0] = v3;\n"
"            rows[1][1] = v4;\n"
"            rows[1][2] = v5;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[1][0] = v2;\n"
"            rows[1][1] = v3;\n"
"            rows[2][0] = v4;\n"
"            rows[2][1] = v5;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[0][3] = v3;\n"
"            rows[1][0] = v4;\n"
"            rows[1][1] = v5;\n"
"            rows[1][2] = v6;\n"
"            rows[1][3] = v7;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[1][0] = v2;\n"
"            rows[1][1] = v3;\n"
"            rows[2][0] = v4;\n"
"            rows[2][1] = v5;\n"
"            rows[3][0] = v6;\n"
"            rows[3][1] = v7;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8)\n"
"    {\n"
"        rows[0][0] = v0;\n"
"        rows[0][1] = v1;\n"
"        rows[0][2] = v2;\n"
"        rows[1][0] = v3;\n"
"        rows[1][1] = v4;\n"
"        rows[1][2] = v5;\n"
"        rows[2][0] = v6;\n"
"        rows[2][1] = v7;\n"
"        rows[2][2] = v8;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10, T v11)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[0][3] = v3;\n"
"            rows[1][0] = v4;\n"
"            rows[1][1] = v5;\n"
"            rows[1][2] = v6;\n"
"            rows[1][3] = v7;\n"
"            rows[2][0] = v8;\n"
"            rows[2][1] = v9;\n"
"            rows[2][2] = v10;\n"
"            rows[2][3] = v11;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[1][0] = v3;\n"
"            rows[1][1] = v4;\n"
"            rows[1][2] = v5;\n"
"            rows[2][0] = v6;\n"
"            rows[2][1] = v7;\n"
"            rows[2][2] = v8;\n"
"            rows[3][0] = v9;\n"
"            rows[3][1] = v10;\n"
"            rows[3][2] = v11;\n"
"        }\n"
"    }\n"
"    Matrix(\n"
"        T v0,\n"
"        T v1,\n"
"        T v2,\n"
"        T v3,\n"
"        T v4,\n"
"        T v5,\n"
"        T v6,\n"
"        T v7,\n"
"        T v8,\n"
"        T v9,\n"
"        T v10,\n"
"        T v11,\n"
"        T v12,\n"
"        T v13,\n"
"        T v14,\n"
"        T v15)\n"
"    {\n"
"        rows[0][0] = v0;\n"
"        rows[0][1] = v1;\n"
"        rows[0][2] = v2;\n"
"        rows[0][3] = v3;\n"
"        rows[1][0] = v4;\n"
"        rows[1][1] = v5;\n"
"        rows[1][2] = v6;\n"
"        rows[1][3] = v7;\n"
"        rows[2][0] = v8;\n"
"        rows[2][1] = v9;\n"
"        rows[2][2] = v10;\n"
"        rows[2][3] = v11;\n"
"        rows[3][0] = v12;\n"
"        rows[3][1] = v13;\n"
"        rows[3][2] = v14;\n"
"        rows[3][3] = v15;\n"
"    }\n"
"};\n"
"\n"
"#define SLANG_MATRIX_BINARY_OP(T, op)                                                         \\\n"
"    template<int R, int C>                                                                    \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal, const Matrix<T, R, C>& other) \\\n"
"    {                                                                                         \\\n"
"        Matrix<T, R, C> result;                                                               \\\n"
"        for (int i = 0; i < R; i++)                                                           \\\n"
"            for (int j = 0; j < C; j++)                                                       \\\n"
"                result.rows[i][j] = thisVal.rows[i][j] op other.rows[i][j];                   \\\n"
"        return result;                                                                        \\\n"
"    }\n"
"\n"
"#define SLANG_MATRIX_BINARY_COMPARE_OP(T, op)                                                    \\\n"
"    template<int R, int C>                                                                       \\\n"
"    Matrix<bool, R, C> operator op(const Matrix<T, R, C>& thisVal, const Matrix<T, R, C>& other) \\\n"
"    {                                                                                            \\\n"
"        Matrix<bool, R, C> result;                                                               \\\n"
"        for (int i = 0; i < R; i++)                                                              \\\n"
"            for (int j = 0; j < C; j++)                                                          \\\n"
"                result.rows[i][j] = thisVal.rows[i][j] op other.rows[i][j];                      \\\n"
"        return result;                                                                           \\\n"
"    }\n"
"\n"
"#define SLANG_MATRIX_UNARY_OP(T, op)                            \\\n"
"    template<int R, int C>                                      \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal) \\\n"
"    {                                                           \\\n"
"        Matrix<T, R, C> result;                                 \\\n"
"        for (int i = 0; i < R; i++)                             \\\n"
"            for (int j = 0; j < C; j++)                         \\\n"
"                result[i].rows[i][j] = op thisVal.rows[i][j];   \\\n"
"        return result;                                          \\\n"
"    }\n"
"\n"
"#define SLANG_INT_MATRIX_OPS(T)           \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, /)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, &)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, |)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, &&)         \\\n"
"    SLANG_MATRIX_BINARY_OP(T, ||)         \\\n"
"    SLANG_MATRIX_BINARY_OP(T, ^)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, %)          \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, !=) \\\n"
"    SLANG_MATRIX_UNARY_OP(T, !)           \\\n"
"    SLANG_MATRIX_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_MATRIX_OPS(T)         \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, /)          \\\n"
"    SLANG_MATRIX_UNARY_OP(T, -)           \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, !=)\n"
"SLANG_INT_MATRIX_OPS(int)\n"
"SLANG_INT_MATRIX_OPS(int8_t)\n"
"SLANG_INT_MATRIX_OPS(int16_t)\n"
"SLANG_INT_MATRIX_OPS(int64_t)\n"
"SLANG_INT_MATRIX_OPS(uint)\n"
"SLANG_INT_MATRIX_OPS(uint8_t)\n"
"SLANG_INT_MATRIX_OPS(uint16_t)\n"
"SLANG_INT_MATRIX_OPS(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_INT_MATRIX_OPS(intptr_t)\n"
"SLANG_INT_MATRIX_OPS(uintptr_t)\n"
"#endif\n"
"\n"
"SLANG_FLOAT_MATRIX_OPS(float)\n"
"SLANG_FLOAT_MATRIX_OPS(double)\n"
"\n"
"#define SLANG_MATRIX_INT_NEG_OP(T)                                        \\\n"
"    template<int R, int C>                                                \\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator-(Matrix<T, R, C> thisVal) \\\n"
"    {                                                                     \\\n"
"        Matrix<T, R, C> result;                                           \\\n"
"        for (int i = 0; i < R; i++)                                       \\\n"
"            for (int j = 0; j < C; j++)                                   \\\n"
"                result.rows[i][j] = 0 - thisVal.rows[i][j];               \\\n"
"        return result;                                                    \\\n"
"    }\n"
"SLANG_MATRIX_INT_NEG_OP(int)\n"
"SLANG_MATRIX_INT_NEG_OP(int8_t)\n"
"SLANG_MATRIX_INT_NEG_OP(int16_t)\n"
"SLANG_MATRIX_INT_NEG_OP(int64_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uint)\n"
"SLANG_MATRIX_INT_NEG_OP(uint8_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uint16_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_MATRIX_INT_NEG_OP(intptr_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uintptr_t)\n"
"#endif\n"
"\n"
"#define SLANG_FLOAT_MATRIX_MOD(T)                                                             \\\n"
"    template<int R, int C>                                                                    \\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator%(Matrix<T, R, C> left, Matrix<T, R, C> right) \\\n"
"    {                                                                                         \\\n"
"        Matrix<T, R, C> result;                                                               \\\n"
"        for (int i = 0; i < R; i++)                                                           \\\n"
"            for (int j = 0; j < C; j++)                                                       \\\n"
"                result.rows[i][j] = _slang_fmod(left.rows[i][j], right.rows[i][j]);           \\\n"
"        return result;                                                                        \\\n"
"    }\n"
"\n"
"SLANG_FLOAT_MATRIX_MOD(float)\n"
"SLANG_FLOAT_MATRIX_MOD(double)\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"#undef SLANG_MATRIX_BINARY_OP\n"
"#undef SLANG_MATRIX_UNARY_OP\n"
"#undef SLANG_INT_MATRIX_OPS\n"
"#undef SLANG_FLOAT_MATRIX_OPS\n"
"#undef SLANG_MATRIX_INT_NEG_OP\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"\n"
"template<typename TResult, typename TInput>\n"
"TResult slang_bit_cast(TInput val)\n"
"{\n"
"    return *(TResult*)(&val);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"typedef Vector<float, 2> float2;\n"
"typedef Vector<float, 3> float3;\n"
"typedef Vector<float, 4> float4;\n"
"\n"
"typedef Vector<int32_t, 2> int2;\n"
"typedef Vector<int32_t, 3> int3;\n"
"typedef Vector<int32_t, 4> int4;\n"
"\n"
"typedef Vector<uint32_t, 2> uint2;\n"
"typedef Vector<uint32_t, 3> uint3;\n"
"typedef Vector<uint32_t, 4> uint4;\n"
"\n"
"// We can just map `NonUniformResourceIndex` type directly to the index type on CPU, as CPU does not\n"
"// require any special handling around such accesses.\n"
"typedef size_t NonUniformResourceIndex;\n"
"\n"
"// ----------------------------- ResourceType -----------------------------------------\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-structuredbuffer-getdimensions\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"\n"
"template<typename T>\n"
"struct RWStructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    const T& Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride)\n"
"    {\n"
"        *outNumStructs = uint32_t(count);\n"
"        *outStride = uint32_t(sizeof(T));\n"
"    }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct StructuredBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    T& Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    void GetDimensions(uint32_t* outNumStructs, uint32_t* outStride)\n"
"    {\n"
"        *outNumStructs = uint32_t(count);\n"
"        *outStride = uint32_t(sizeof(T));\n"
"    }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"\n"
"template<typename T>\n"
"struct RWBuffer\n"
"{\n"
"    SLANG_FORCE_INLINE T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    const T& Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Buffer\n"
"{\n"
"    SLANG_FORCE_INLINE const T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    const T& Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    void GetDimensions(uint32_t* outCount) { *outCount = uint32_t(count); }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"// Missing  Load(_In_  int  Location, _Out_ uint Status);\n"
"struct ByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"    uint32_t Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 4, sizeInBytes);\n"
"        return data[index >> 2];\n"
"    }\n"
"    uint2 Load2(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 8, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        return uint2{data[dataIdx], data[dataIdx + 1]};\n"
"    }\n"
"    uint3 Load3(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 12, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]};\n"
"    }\n"
"    uint4 Load4(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 16, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
;
sb << 
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]};\n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, sizeof(T), sizeInBytes);\n"
"        return *(const T*)(((const char*)data) + index);\n"
"    }\n"
"\n"
"    const uint32_t* data;\n"
"    size_t sizeInBytes; //< Must be multiple of 4\n"
"};\n"
"\n"
"// https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-object-rwbyteaddressbuffer\n"
"// Missing support for Atomic operations\n"
"// Missing support for Load with status\n"
"struct RWByteAddressBuffer\n"
"{\n"
"    void GetDimensions(uint32_t* outDim) const { *outDim = uint32_t(sizeInBytes); }\n"
"\n"
"    uint32_t Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 4, sizeInBytes);\n"
"        return data[index >> 2];\n"
"    }\n"
"    uint2 Load2(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 8, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        return uint2{data[dataIdx], data[dataIdx + 1]};\n"
"    }\n"
"    uint3 Load3(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 12, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        return uint3{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2]};\n"
"    }\n"
"    uint4 Load4(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 16, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        return uint4{data[dataIdx], data[dataIdx + 1], data[dataIdx + 2], data[dataIdx + 3]};\n"
"    }\n"
"    template<typename T>\n"
"    T Load(size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, sizeof(T), sizeInBytes);\n"
"        return *(const T*)(((const char*)data) + index);\n"
"    }\n"
"\n"
"    void Store(size_t index, uint32_t v) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 4, sizeInBytes);\n"
"        data[index >> 2] = v;\n"
"    }\n"
"    void Store2(size_t index, uint2 v) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 8, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"    }\n"
"    void Store3(size_t index, uint3 v) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 12, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"    }\n"
"    void Store4(size_t index, uint4 v) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, 16, sizeInBytes);\n"
"        const size_t dataIdx = index >> 2;\n"
"        data[dataIdx + 0] = v.x;\n"
"        data[dataIdx + 1] = v.y;\n"
"        data[dataIdx + 2] = v.z;\n"
"        data[dataIdx + 3] = v.w;\n"
"    }\n"
"    template<typename T>\n"
"    void Store(size_t index, T const& value) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_BYTE_ADDRESS(index, sizeof(T), sizeInBytes);\n"
"        *(T*)(((char*)data) + index) = value;\n"
"    }\n"
"\n"
"    uint32_t* data;\n"
"    size_t sizeInBytes; //< Must be multiple of 4\n"
"};\n"
"\n"
"struct ISamplerState;\n"
"struct ISamplerComparisonState;\n"
"\n"
"struct SamplerState\n"
"{\n"
"    ISamplerState* state;\n"
"};\n"
"\n"
"struct SamplerComparisonState\n"
"{\n"
"    ISamplerComparisonState* state;\n"
"};\n"
"\n"
"#ifndef SLANG_RESOURCE_SHAPE\n"
"#define SLANG_RESOURCE_SHAPE\n"
"typedef unsigned int SlangResourceShape;\n"
"enum\n"
"{\n"
"    SLANG_RESOURCE_BASE_SHAPE_MASK = 0x0F,\n"
"\n"
"    SLANG_RESOURCE_NONE = 0x00,\n"
"\n"
"    SLANG_TEXTURE_1D = 0x01,\n"
"    SLANG_TEXTURE_2D = 0x02,\n"
"    SLANG_TEXTURE_3D = 0x03,\n"
"    SLANG_TEXTURE_CUBE = 0x04,\n"
"    SLANG_TEXTURE_BUFFER = 0x05,\n"
"\n"
"    SLANG_STRUCTURED_BUFFER = 0x06,\n"
"    SLANG_BYTE_ADDRESS_BUFFER = 0x07,\n"
"    SLANG_RESOURCE_UNKNOWN = 0x08,\n"
"    SLANG_ACCELERATION_STRUCTURE = 0x09,\n"
"    SLANG_TEXTURE_SUBPASS = 0x0A,\n"
"\n"
"    SLANG_RESOURCE_EXT_SHAPE_MASK = 0xF0,\n"
"\n"
"    SLANG_TEXTURE_FEEDBACK_FLAG = 0x10,\n"
"    SLANG_TEXTURE_ARRAY_FLAG = 0x40,\n"
"    SLANG_TEXTURE_MULTISAMPLE_FLAG = 0x80,\n"
"\n"
"    SLANG_TEXTURE_1D_ARRAY = SLANG_TEXTURE_1D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_2D_ARRAY = SLANG_TEXTURE_2D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_CUBE_ARRAY = SLANG_TEXTURE_CUBE | SLANG_TEXTURE_ARRAY_FLAG,\n"
"\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"    SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY =\n"
"        SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG | SLANG_TEXTURE_ARRAY_FLAG,\n"
"    SLANG_TEXTURE_SUBPASS_MULTISAMPLE = SLANG_TEXTURE_SUBPASS | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"};\n"
"#endif\n"
"\n"
"//\n"
"struct TextureDimensions\n"
"{\n"
"    void reset()\n"
"    {\n"
"        shape = 0;\n"
"        width = height = depth = 0;\n"
"        numberOfLevels = 0;\n"
"        arrayElementCount = 0;\n"
"    }\n"
"    int getDimSizes(uint32_t outDims[4]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"        case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"        case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"        case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"        case SLANG_TEXTURE_CUBE:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = 6;\n"
"                break;\n"
"            }\n"
"        }\n"
"\n"
"        if (shape & SLANG_TEXTURE_ARRAY_FLAG)\n"
"        {\n"
"            outDims[count++] = arrayElementCount;\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int getMIPDims(int outDims[3]) const\n"
"    {\n"
"        const auto baseShape = (shape & SLANG_RESOURCE_BASE_SHAPE_MASK);\n"
"        int count = 0;\n"
"        switch (baseShape)\n"
"        {\n"
"        case SLANG_TEXTURE_1D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                break;\n"
"            }\n"
"        case SLANG_TEXTURE_CUBE:\n"
"        case SLANG_TEXTURE_2D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                break;\n"
"            }\n"
"        case SLANG_TEXTURE_3D:\n"
"            {\n"
"                outDims[count++] = width;\n"
"                outDims[count++] = height;\n"
"                outDims[count++] = depth;\n"
"                break;\n"
"            }\n"
"        }\n"
"        return count;\n"
"    }\n"
"    int calcMaxMIPLevels() const\n"
"    {\n"
"        int dims[3];\n"
"        const int dimCount = getMIPDims(dims);\n"
"        for (int count = 1; true; count++)\n"
"        {\n"
"            bool allOne = true;\n"
"            for (int i = 0; i < dimCount; ++i)\n"
"            {\n"
"                if (dims[i] > 1)\n"
"                {\n"
"                    allOne = false;\n"
"                    dims[i] >>= 1;\n"
"                }\n"
"            }\n"
"            if (allOne)\n"
"            {\n"
"                return count;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    uint32_t shape;\n"
"    uint32_t width, height, depth;\n"
"    uint32_t numberOfLevels;\n"
"    uint32_t arrayElementCount; ///< For array types, 0 otherwise\n"
"};\n"
"\n"
"\n"
"// Texture\n"
"\n"
"struct ITexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"    virtual void Load(const int32_t* v, void* outData, size_t dataSize) = 0;\n"
"    virtual void Sample(\n"
"        SamplerState samplerState,\n"
"        const float* loc,\n"
"        void* outData,\n"
"        size_t dataSize) = 0;\n"
"    virtual void SampleLevel(\n"
"        SamplerState samplerState,\n"
"        const float* loc,\n"
"        float level,\n"
"        void* outData,\n"
"        size_t dataSize) = 0;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Texture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(const int2& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T Sample(SamplerState samplerState, float loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Sample(samplerState, &loc, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T SampleLevel(SamplerState samplerState, float loc, float level) const\n"
"    {\n"
"        T out;\n"
"        texture->SampleLevel(samplerState, &loc, level, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"\n"
"    ITexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Texture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(const int3& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Sample(samplerState, &loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) const\n"
"    {\n"
"        T out;\n"
"        texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"\n"
"    ITexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Texture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outDepth,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outDepth,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(const int4& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Sample(samplerState, &loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) const\n"
"    {\n"
"        T out;\n"
"        texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"\n"
"    ITexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct TextureCube\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Sample(SamplerState samplerState, const float3& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Sample(samplerState, &loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) const\n"
"    {\n"
"        T out;\n"
"        texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"\n"
"    ITexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Texture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outElements,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outElements,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"\n"
"    T Load(const int3& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T Sample(SamplerState samplerState, const float2& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Sample(samplerState, &loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T SampleLevel(SamplerState samplerState, const float2& loc, float level) const\n"
"    {\n"
"        T out;\n"
"        texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"\n"
"    ITexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Texture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outElements,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outElements,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(const int4& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T Sample(SamplerState samplerState, const float3& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Sample(samplerState, &loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
;
sb << 
"    T SampleLevel(SamplerState samplerState, const float3& loc, float level) const\n"
"    {\n"
"        T out;\n"
"        texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"\n"
"    ITexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct TextureCubeArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outElements,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    void GetDimensions(uint32_t* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outElements,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Sample(SamplerState samplerState, const float4& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Sample(samplerState, &loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T SampleLevel(SamplerState samplerState, const float4& loc, float level) const\n"
"    {\n"
"        T out;\n"
"        texture->SampleLevel(samplerState, &loc.x, level, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"\n"
"    ITexture* texture;\n"
"};\n"
"\n"
"/* !!!!!!!!!!!!!!!!!!!!!!!!!!! RWTexture !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */\n"
"\n"
"struct IRWTexture : ITexture\n"
"{\n"
"    /// Get the reference to the element at loc.\n"
"    virtual void* refAt(const uint32_t* loc) = 0;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct RWTexture1D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, uint32_t* outWidth, uint32_t* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    void GetDimensions(float* outWidth) { *outWidth = texture->GetDimensions().width; }\n"
"    void GetDimensions(uint32_t mipLevel, float* outWidth, float* outNumberOfLevels)\n"
"    {\n"
"        auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(int32_t loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T& operator[](uint32_t loc) { return *(T*)texture->refAt(&loc); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct RWTexture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(const int2& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T& operator[](const uint2& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct RWTexture3D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outDepth,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outDepth)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outDepth,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outDepth = dims.depth;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(const int3& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"\n"
"template<typename T>\n"
"struct RWTexture1DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outElements,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outElements,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(int2 loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T& operator[](uint2 loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct RWTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outElements,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outElements,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    T Load(const int3& loc) const\n"
"    {\n"
"        T out;\n"
"        texture->Load(&loc.x, &out, sizeof(out));\n"
"        return out;\n"
"    }\n"
"    T& operator[](const uint3& loc) { return *(T*)texture->refAt(&loc.x); }\n"
"\n"
"    IRWTexture* texture;\n"
"};\n"
"\n"
"// FeedbackTexture\n"
"\n"
"struct FeedbackType\n"
"{\n"
"};\n"
"struct SAMPLER_FEEDBACK_MIN_MIP : FeedbackType\n"
"{\n"
"};\n"
"struct SAMPLER_FEEDBACK_MIP_REGION_USED : FeedbackType\n"
"{\n"
"};\n"
"\n"
"struct IFeedbackTexture\n"
"{\n"
"    virtual TextureDimensions GetDimensions(int mipLevel = -1) = 0;\n"
"\n"
"    // Note here we pass the optional clamp parameter as a pointer. Passing nullptr means no clamp.\n"
"    // This was preferred over having two function definitions, and having to differentiate their\n"
"    // names\n"
"    virtual void WriteSamplerFeedback(\n"
"        ITexture* tex,\n"
"        SamplerState samp,\n"
"        const float* location,\n"
"        const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackBias(\n"
"        ITexture* tex,\n"
"        SamplerState samp,\n"
"        const float* location,\n"
"        float bias,\n"
"        const float* clamp = nullptr) = 0;\n"
"    virtual void WriteSamplerFeedbackGrad(\n"
"        ITexture* tex,\n"
"        SamplerState samp,\n"
"        const float* location,\n"
"        const float* ddx,\n"
"        const float* ddy,\n"
"        const float* clamp = nullptr) = 0;\n"
"\n"
"    virtual void WriteSamplerFeedbackLevel(\n"
"        ITexture* tex,\n"
"        SamplerState samp,\n"
"        const float* location,\n"
"        float lod) = 0;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct FeedbackTexture2D\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight)\n"
"    {\n"
"        const auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location, float clamp)\n"
"    {\n"
"        texture->WriteSamplerFeedback(tex.texture, samp, &location.x, &clamp);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackBias(\n"
"        Texture2D<S> tex,\n"
"        SamplerState samp,\n"
"        float2 location,\n"
"        float bias,\n"
"        float clamp)\n"
"    {\n"
"        texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias, &clamp);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackGrad(\n"
"        Texture2D<S> tex,\n"
"        SamplerState samp,\n"
"        float2 location,\n"
"        float2 ddx,\n"
"        float2 ddy,\n"
"        float clamp)\n"
"    {\n"
"        texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp);\n"
"    }\n"
"\n"
"    // Level\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackLevel(Texture2D<S> tex, SamplerState samp, float2 location, float lod)\n"
"    {\n"
"        texture->WriteSamplerFeedbackLevel(tex.texture, samp, &location.x, lod);\n"
"    }\n"
"\n"
"    // Without Clamp\n"
"    template<typename S>\n"
"    void WriteSamplerFeedback(Texture2D<S> tex, SamplerState samp, float2 location)\n"
"    {\n"
"        texture->WriteSamplerFeedback(tex.texture, samp, &location.x);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackBias(Texture2D<S> tex, SamplerState samp, float2 location, float bias)\n"
"    {\n"
"        texture->WriteSamplerFeedbackBias(tex.texture, samp, &location.x, bias);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackGrad(\n"
"        Texture2D<S> tex,\n"
"        SamplerState samp,\n"
"        float2 location,\n"
"        float2 ddx,\n"
"        float2 ddy)\n"
"    {\n"
"        texture->WriteSamplerFeedbackGrad(tex.texture, samp, &location.x, &ddx.x, &ddy.x);\n"
"    }\n"
"\n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"template<typename T>\n"
"struct FeedbackTexture2DArray\n"
"{\n"
"    void GetDimensions(uint32_t* outWidth, uint32_t* outHeight, uint32_t* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        uint32_t* outWidth,\n"
"        uint32_t* outHeight,\n"
"        uint32_t* outElements,\n"
"        uint32_t* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"    void GetDimensions(float* outWidth, float* outHeight, float* outElements)\n"
"    {\n"
"        auto dims = texture->GetDimensions();\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"    }\n"
"    void GetDimensions(\n"
"        uint32_t mipLevel,\n"
"        float* outWidth,\n"
"        float* outHeight,\n"
"        float* outElements,\n"
"        float* outNumberOfLevels)\n"
"    {\n"
"        const auto dims = texture->GetDimensions(mipLevel);\n"
"        *outWidth = dims.width;\n"
"        *outHeight = dims.height;\n"
"        *outElements = dims.arrayElementCount;\n"
"        *outNumberOfLevels = dims.numberOfLevels;\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedback(\n"
"        Texture2DArray<S> texArray,\n"
"        SamplerState samp,\n"
"        float3 location,\n"
"        float clamp)\n"
"    {\n"
"        texture->WriteSamplerFeedback(texArray.texture, samp, &location.x, &clamp);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackBias(\n"
"        Texture2DArray<S> texArray,\n"
"        SamplerState samp,\n"
"        float3 location,\n"
"        float bias,\n"
"        float clamp)\n"
"    {\n"
"        texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias, &clamp);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackGrad(\n"
"        Texture2DArray<S> texArray,\n"
"        SamplerState samp,\n"
"        float3 location,\n"
"        float3 ddx,\n"
"        float3 ddy,\n"
"        float clamp)\n"
"    {\n"
"        texture\n"
"            ->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x, &clamp);\n"
"    }\n"
"\n"
"    // Level\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackLevel(\n"
"        Texture2DArray<S> texArray,\n"
"        SamplerState samp,\n"
"        float3 location,\n"
"        float lod)\n"
"    {\n"
"        texture->WriteSamplerFeedbackLevel(texArray.texture, samp, &location.x, lod);\n"
"    }\n"
"\n"
"    // Without Clamp\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedback(Texture2DArray<S> texArray, SamplerState samp, float3 location)\n"
"    {\n"
"        texture->WriteSamplerFeedback(texArray.texture, samp, &location.x);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackBias(\n"
"        Texture2DArray<S> texArray,\n"
"        SamplerState samp,\n"
"        float3 location,\n"
"        float bias)\n"
"    {\n"
"        texture->WriteSamplerFeedbackBias(texArray.texture, samp, &location.x, bias);\n"
"    }\n"
"\n"
"    template<typename S>\n"
"    void WriteSamplerFeedbackGrad(\n"
"        Texture2DArray<S> texArray,\n"
"        SamplerState samp,\n"
"        float3 location,\n"
"        float3 ddx,\n"
"        float3 ddy)\n"
"    {\n"
"        texture->WriteSamplerFeedbackGrad(texArray.texture, samp, &location.x, &ddx.x, &ddy.x);\n"
"    }\n"
"\n"
"    IFeedbackTexture* texture;\n"
"};\n"
"\n"
"/* Varying input for Compute */\n"
"\n"
"/* Used when running a single thread */\n"
"struct ComputeThreadVaryingInput\n"
"{\n"
"    uint3 groupID;\n"
"    uint3 groupThreadID;\n"
"};\n"
"\n"
"struct ComputeVaryingInput\n"
"{\n"
"    uint3 startGroupID; ///< start groupID\n"
"    uint3 endGroupID;   ///< Non inclusive end groupID\n"
"};\n"
"\n"
"// The uniformEntryPointParams and uniformState must be set to structures that match layout that the\n"
"// kernel expects. This can be determined via reflection for example.\n"
"\n"
"typedef void (*ComputeThreadFunc)(\n"
"    ComputeThreadVaryingInput* varyingInput,\n"
"    void* uniformEntryPointParams,\n"
;
sb << 
"    void* uniformState);\n"
"typedef void (*ComputeFunc)(\n"
"    ComputeVaryingInput* varyingInput,\n"
"    void* uniformEntryPointParams,\n"
"    void* uniformState);\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"\n"
"// TODO(JS): Hack! Output C++ code from slang can copy uninitialized variables.\n"
"#if defined(_MSC_VER)\n"
"#pragma warning(disable : 4700)\n"
"#endif\n"
"\n"
"#ifndef SLANG_UNROLL\n"
"#define SLANG_UNROLL\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
;
return sb.produceString();
}
