// generated code; do not edit
#include "../source/core/slang-basic.h"
Slang::String get_slang_torch_prelude()
{
Slang::StringBuilder sb;
sb << 
"// Prelude for PyTorch cpp binding.\n"
"\n"
"// clang-format off\n"
"#include <torch/extension.h>\n"
"// clang-format on\n"
"\n"
"#include <ATen/cuda/CUDAContext.h>\n"
"#include <ATen/cuda/CUDAUtils.h>\n"
"#include <stdexcept>\n"
"#include <string>\n"
"#include <vector>\n"
"\n"
"#ifdef SLANG_LLVM\n"
"#ifndef SLANG_LLVM_H\n"
"#define SLANG_LLVM_H\n"
"\n"
"// TODO(JS):\n"
"// Disable exception declspecs, as not supported on LLVM without some extra options.\n"
"// We could enable with `-fms-extensions`\n"
"#define SLANG_DISABLE_EXCEPTIONS 1\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"extern \"C\" void assertFailure(const char* msg);\n"
"#define SLANG_PRELUDE_EXPECT(VALUE, MSG) \\\n"
"    if (VALUE)                           \\\n"
"    {                                    \\\n"
"    }                                    \\\n"
"    else                                 \\\n"
"        assertFailure(\"assertion failed: '\" MSG \"'\")\n"
"#define SLANG_PRELUDE_ASSERT(VALUE) SLANG_PRELUDE_EXPECT(VALUE, #VALUE)\n"
"#else // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#define SLANG_PRELUDE_EXPECT(VALUE, MSG)\n"
"#define SLANG_PRELUDE_ASSERT(x)\n"
"#endif // SLANG_PRELUDE_ENABLE_ASSERT\n"
"#endif\n"
"\n"
"/*\n"
"Taken from stddef.h\n"
"*/\n"
"\n"
"typedef __PTRDIFF_TYPE__ ptrdiff_t;\n"
"typedef __SIZE_TYPE__ size_t;\n"
"typedef __SIZE_TYPE__ rsize_t;\n"
"\n"
"// typedef __WCHAR_TYPE__ wchar_t;\n"
"\n"
"#if defined(__need_NULL)\n"
"#undef NULL\n"
"#ifdef __cplusplus\n"
"#if !defined(__MINGW32__) && !defined(_MSC_VER)\n"
"#define NULL __null\n"
"#else\n"
"#define NULL 0\n"
"#endif\n"
"#else\n"
"#define NULL ((void*)0)\n"
"#endif\n"
"#ifdef __cplusplus\n"
"#if defined(_MSC_EXTENSIONS) && defined(_NATIVE_NULLPTR_SUPPORTED)\n"
"namespace std\n"
"{\n"
"typedef decltype(nullptr) nullptr_t;\n"
"}\n"
"using ::std::nullptr_t;\n"
"#endif\n"
"#endif\n"
"#undef __need_NULL\n"
"#endif /* defined(__need_NULL) */\n"
"\n"
"\n"
"/*\n"
"The following are taken verbatim from stdint.h from Clang in LLVM. Only 8/16/32/64 types are needed.\n"
"*/\n"
"\n"
"// LLVM/Clang types such that we can use LLVM/Clang without headers for C++ output from Slang\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int64_t*/\n"
"typedef __INT64_TYPE__ int64_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT64_TYPE__ uint64_t;\n"
"#define __int_least64_t int64_t\n"
"#define __uint_least64_t uint64_t\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"typedef __int_least64_t int_least64_t;\n"
"typedef __uint_least64_t uint_least64_t;\n"
"typedef __int_least64_t int_fast64_t;\n"
"typedef __uint_least64_t uint_fast64_t;\n"
"#endif /* __int_least64_t */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int32_t*/\n"
"typedef __INT32_TYPE__ int32_t;\n"
"#endif /* __int8_t_defined */\n"
"\n"
"#ifndef __uint32_t_defined /* more glibc compatibility */\n"
"#define __uint32_t_defined\n"
"typedef __UINT32_TYPE__ uint32_t;\n"
"#endif /* __uint32_t_defined */\n"
"\n"
"#define __int_least32_t int32_t\n"
"#define __uint_least32_t uint32_t\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"typedef __int_least32_t int_least32_t;\n"
"typedef __uint_least32_t uint_least32_t;\n"
"typedef __int_least32_t int_fast32_t;\n"
"typedef __uint_least32_t uint_fast32_t;\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int16_t*/\n"
"typedef __INT16_TYPE__ int16_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT16_TYPE__ uint16_t;\n"
"#define __int_least16_t int16_t\n"
"#define __uint_least16_t uint16_t\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"typedef __int_least16_t int_least16_t;\n"
"typedef __uint_least16_t uint_least16_t;\n"
"typedef __int_least16_t int_fast16_t;\n"
"typedef __uint_least16_t uint_fast16_t;\n"
"#endif /* __int_least16_t */\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#ifndef __int8_t_defined /* glibc sys/types.h also defines int8_t*/\n"
"typedef __INT8_TYPE__ int8_t;\n"
"#endif /* __int8_t_defined */\n"
"typedef __UINT8_TYPE__ uint8_t;\n"
"#define __int_least8_t int8_t\n"
"#define __uint_least8_t uint8_t\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"typedef __int_least8_t int_least8_t;\n"
"typedef __uint_least8_t uint_least8_t;\n"
"typedef __int_least8_t int_fast8_t;\n"
"typedef __uint_least8_t uint_fast8_t;\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* prevent glibc sys/types.h from defining conflicting types */\n"
"#ifndef __int8_t_defined\n"
"#define __int8_t_defined\n"
"#endif /* __int8_t_defined */\n"
"\n"
"/* C99 7.18.1.4 Integer types capable of holding object pointers.\n"
" */\n"
"#define __stdint_join3(a, b, c) a##b##c\n"
"\n"
"#ifndef _INTPTR_T\n"
"#ifndef __intptr_t_defined\n"
"typedef __INTPTR_TYPE__ intptr_t;\n"
"#define __intptr_t_defined\n"
"#define _INTPTR_T\n"
"#endif\n"
"#endif\n"
"\n"
"#ifndef _UINTPTR_T\n"
"typedef __UINTPTR_TYPE__ uintptr_t;\n"
"#define _UINTPTR_T\n"
"#endif\n"
"\n"
"/* C99 7.18.1.5 Greatest-width integer types.\n"
" */\n"
"typedef __INTMAX_TYPE__ intmax_t;\n"
"typedef __UINTMAX_TYPE__ uintmax_t;\n"
"\n"
"/* C99 7.18.4 Macros for minimum-width integer constants.\n"
" *\n"
" * The standard requires that integer constant macros be defined for all the\n"
" * minimum-width types defined above. As 8-, 16-, 32-, and 64-bit minimum-width\n"
" * types are required, the corresponding integer constant macros are defined\n"
" * here. This implementation also defines minimum-width types for every other\n"
" * integer width that the target implements, so corresponding macros are\n"
" * defined below, too.\n"
" *\n"
" * These macros are defined using the same successive-shrinking approach as\n"
" * the type definitions above. It is likewise important that macros are defined\n"
" * in order of decending width.\n"
" *\n"
" * Note that C++ should not check __STDC_CONSTANT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#define __int_c_join(a, b) a##b\n"
"#define __int_c(v, suffix) __int_c_join(v, suffix)\n"
"#define __uint_c(v, suffix) __int_c_join(v##U, suffix)\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"#ifdef __INT64_C_SUFFIX__\n"
"#define __int64_c_suffix __INT64_C_SUFFIX__\n"
"#else\n"
"#undef __int64_c_suffix\n"
"#endif /* __INT64_C_SUFFIX__ */\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __int_least64_t\n"
"#ifdef __int64_c_suffix\n"
"#define INT64_C(v) __int_c(v, __int64_c_suffix)\n"
"#define UINT64_C(v) __uint_c(v, __int64_c_suffix)\n"
"#else\n"
"#define INT64_C(v) v\n"
"#define UINT64_C(v) v##U\n"
"#endif /* __int64_c_suffix */\n"
"#endif /* __int_least64_t */\n"
"\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"#ifdef __INT32_C_SUFFIX__\n"
"#define __int32_c_suffix __INT32_C_SUFFIX__\n"
"#else\n"
"#undef __int32_c_suffix\n"
"#endif /* __INT32_C_SUFFIX__ */\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __int_least32_t\n"
"#ifdef __int32_c_suffix\n"
"#define INT32_C(v) __int_c(v, __int32_c_suffix)\n"
"#define UINT32_C(v) __uint_c(v, __int32_c_suffix)\n"
"#else\n"
"#define INT32_C(v) v\n"
"#define UINT32_C(v) v##U\n"
"#endif /* __int32_c_suffix */\n"
"#endif /* __int_least32_t */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#ifdef __INT16_C_SUFFIX__\n"
"#define __int16_c_suffix __INT16_C_SUFFIX__\n"
"#else\n"
"#undef __int16_c_suffix\n"
"#endif /* __INT16_C_SUFFIX__ */\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __int_least16_t\n"
"#ifdef __int16_c_suffix\n"
"#define INT16_C(v) __int_c(v, __int16_c_suffix)\n"
"#define UINT16_C(v) __uint_c(v, __int16_c_suffix)\n"
"#else\n"
"#define INT16_C(v) v\n"
"#define UINT16_C(v) v##U\n"
"#endif /* __int16_c_suffix */\n"
"#endif /* __int_least16_t */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#ifdef __INT8_C_SUFFIX__\n"
"#define __int8_c_suffix __INT8_C_SUFFIX__\n"
"#else\n"
"#undef __int8_c_suffix\n"
"#endif /* __INT8_C_SUFFIX__ */\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __int_least8_t\n"
"#ifdef __int8_c_suffix\n"
"#define INT8_C(v) __int_c(v, __int8_c_suffix)\n"
"#define UINT8_C(v) __uint_c(v, __int8_c_suffix)\n"
"#else\n"
"#define INT8_C(v) v\n"
"#define UINT8_C(v) v##U\n"
"#endif /* __int8_c_suffix */\n"
"#endif /* __int_least8_t */\n"
"\n"
"/* C99 7.18.2.1 Limits of exact-width integer types.\n"
" * C99 7.18.2.2 Limits of minimum-width integer types.\n"
" * C99 7.18.2.3 Limits of fastest minimum-width integer types.\n"
" *\n"
" * The presence of limit macros are completely optional in C99.  This\n"
" * implementation defines limits for all of the types (exact- and\n"
" * minimum-width) that it defines above, using the limits of the minimum-width\n"
" * type for any types that do not have exact-width representations.\n"
" *\n"
" * As in the type definitions, this section takes an approach of\n"
" * successive-shrinking to determine which limits to use for the standard (8,\n"
" * 16, 32, 64) bit widths when they don't have exact representations. It is\n"
" * therefore important that the definitions be kept in order of decending\n"
" * widths.\n"
" *\n"
" * Note that C++ should not check __STDC_LIMIT_MACROS here, contrary to the\n"
" * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).\n"
" */\n"
"\n"
"#ifdef __INT64_TYPE__\n"
"#define INT64_MAX INT64_C(9223372036854775807)\n"
"#define INT64_MIN (-INT64_C(9223372036854775807) - 1)\n"
"#define UINT64_MAX UINT64_C(18446744073709551615)\n"
"#define __INT_LEAST64_MIN INT64_MIN\n"
"#define __INT_LEAST64_MAX INT64_MAX\n"
"#define __UINT_LEAST64_MAX UINT64_MAX\n"
"#endif /* __INT64_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST64_MIN\n"
"#define INT_LEAST64_MIN __INT_LEAST64_MIN\n"
"#define INT_LEAST64_MAX __INT_LEAST64_MAX\n"
"#define UINT_LEAST64_MAX __UINT_LEAST64_MAX\n"
"#define INT_FAST64_MIN __INT_LEAST64_MIN\n"
"#define INT_FAST64_MAX __INT_LEAST64_MAX\n"
"#define UINT_FAST64_MAX __UINT_LEAST64_MAX\n"
"#endif /* __INT_LEAST64_MIN */\n"
"\n"
"#ifdef __INT32_TYPE__\n"
"#define INT32_MAX INT32_C(2147483647)\n"
"#define INT32_MIN (-INT32_C(2147483647) - 1)\n"
"#define UINT32_MAX UINT32_C(4294967295)\n"
"#define __INT_LEAST32_MIN INT32_MIN\n"
"#define __INT_LEAST32_MAX INT32_MAX\n"
"#define __UINT_LEAST32_MAX UINT32_MAX\n"
"#endif /* __INT32_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST32_MIN\n"
"#define INT_LEAST32_MIN __INT_LEAST32_MIN\n"
"#define INT_LEAST32_MAX __INT_LEAST32_MAX\n"
"#define UINT_LEAST32_MAX __UINT_LEAST32_MAX\n"
"#define INT_FAST32_MIN __INT_LEAST32_MIN\n"
"#define INT_FAST32_MAX __INT_LEAST32_MAX\n"
"#define UINT_FAST32_MAX __UINT_LEAST32_MAX\n"
"#endif /* __INT_LEAST32_MIN */\n"
"\n"
"#ifdef __INT16_TYPE__\n"
"#define INT16_MAX INT16_C(32767)\n"
"#define INT16_MIN (-INT16_C(32767) - 1)\n"
"#define UINT16_MAX UINT16_C(65535)\n"
"#define __INT_LEAST16_MIN INT16_MIN\n"
"#define __INT_LEAST16_MAX INT16_MAX\n"
"#define __UINT_LEAST16_MAX UINT16_MAX\n"
"#endif /* __INT16_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST16_MIN\n"
"#define INT_LEAST16_MIN __INT_LEAST16_MIN\n"
"#define INT_LEAST16_MAX __INT_LEAST16_MAX\n"
"#define UINT_LEAST16_MAX __UINT_LEAST16_MAX\n"
"#define INT_FAST16_MIN __INT_LEAST16_MIN\n"
"#define INT_FAST16_MAX __INT_LEAST16_MAX\n"
"#define UINT_FAST16_MAX __UINT_LEAST16_MAX\n"
"#endif /* __INT_LEAST16_MIN */\n"
"\n"
"\n"
"#ifdef __INT8_TYPE__\n"
"#define INT8_MAX INT8_C(127)\n"
"#define INT8_MIN (-INT8_C(127) - 1)\n"
"#define UINT8_MAX UINT8_C(255)\n"
"#define __INT_LEAST8_MIN INT8_MIN\n"
"#define __INT_LEAST8_MAX INT8_MAX\n"
"#define __UINT_LEAST8_MAX UINT8_MAX\n"
"#endif /* __INT8_TYPE__ */\n"
"\n"
"#ifdef __INT_LEAST8_MIN\n"
"#define INT_LEAST8_MIN __INT_LEAST8_MIN\n"
"#define INT_LEAST8_MAX __INT_LEAST8_MAX\n"
"#define UINT_LEAST8_MAX __UINT_LEAST8_MAX\n"
"#define INT_FAST8_MIN __INT_LEAST8_MIN\n"
"#define INT_FAST8_MAX __INT_LEAST8_MAX\n"
"#define UINT_FAST8_MAX __UINT_LEAST8_MAX\n"
"#endif /* __INT_LEAST8_MIN */\n"
"\n"
"/* Some utility macros */\n"
"#define __INTN_MIN(n) __stdint_join3(INT, n, _MIN)\n"
"#define __INTN_MAX(n) __stdint_join3(INT, n, _MAX)\n"
"#define __UINTN_MAX(n) __stdint_join3(UINT, n, _MAX)\n"
"#define __INTN_C(n, v) __stdint_join3(INT, n, _C(v))\n"
"#define __UINTN_C(n, v) __stdint_join3(UINT, n, _C(v))\n"
"\n"
"/* C99 7.18.2.4 Limits of integer types capable of holding object pointers. */\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"\n"
"#define INTPTR_MIN (-__INTPTR_MAX__ - 1)\n"
"#define INTPTR_MAX __INTPTR_MAX__\n"
"#define UINTPTR_MAX __UINTPTR_MAX__\n"
"#define PTRDIFF_MIN (-__PTRDIFF_MAX__ - 1)\n"
"#define PTRDIFF_MAX __PTRDIFF_MAX__\n"
"#define SIZE_MAX __SIZE_MAX__\n"
"\n"
"/* ISO9899:2011 7.20 (C11 Annex K): Define RSIZE_MAX if __STDC_WANT_LIB_EXT1__\n"
" * is enabled. */\n"
"#if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1\n"
"#define RSIZE_MAX (SIZE_MAX >> 1)\n"
"#endif\n"
"\n"
"/* C99 7.18.2.5 Limits of greatest-width integer types. */\n"
"#define INTMAX_MIN (-__INTMAX_MAX__ - 1)\n"
"#define INTMAX_MAX __INTMAX_MAX__\n"
"#define UINTMAX_MAX __UINTMAX_MAX__\n"
"\n"
"/* C99 7.18.3 Limits of other integer types. */\n"
"#define SIG_ATOMIC_MIN __INTN_MIN(__SIG_ATOMIC_WIDTH__)\n"
"#define SIG_ATOMIC_MAX __INTN_MAX(__SIG_ATOMIC_WIDTH__)\n"
"#ifdef __WINT_UNSIGNED__\n"
"#define WINT_MIN __UINTN_C(__WINT_WIDTH__, 0)\n"
"#define WINT_MAX __UINTN_MAX(__WINT_WIDTH__)\n"
"#else\n"
"#define WINT_MIN __INTN_MIN(__WINT_WIDTH__)\n"
"#define WINT_MAX __INTN_MAX(__WINT_WIDTH__)\n"
"#endif\n"
"\n"
"#ifndef WCHAR_MAX\n"
"#define WCHAR_MAX __WCHAR_MAX__\n"
"#endif\n"
"#ifndef WCHAR_MIN\n"
"#if __WCHAR_MAX__ == __INTN_MAX(__WCHAR_WIDTH__)\n"
"#define WCHAR_MIN __INTN_MIN(__WCHAR_WIDTH__)\n"
"#else\n"
"#define WCHAR_MIN __UINTN_C(__WCHAR_WIDTH__, 0)\n"
"#endif\n"
"#endif\n"
"\n"
"/* 7.18.4.2 Macros for greatest-width integer constants. */\n"
"#define INTMAX_C(v) __int_c(v, __INTMAX_C_SUFFIX__)\n"
"#define UINTMAX_C(v) __int_c(v, __UINTMAX_C_SUFFIX__)\n"
"\n"
"\n"
"#endif // SLANG_LLVM_H\n"
"\n"
"#else // SLANG_LLVM\n"
"#if SLANG_GCC_FAMILY && __GNUC__ < 6\n"
"#include <cmath>\n"
"#define SLANG_PRELUDE_STD std::\n"
"#else\n"
"#include <math.h>\n"
"#define SLANG_PRELUDE_STD\n"
"#endif\n"
"\n"
"#include <assert.h>\n"
"#include <stdint.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#endif // SLANG_LLVM\n"
"\n"
"#ifndef SLANG_CORE_STRING_H\n"
"#define SLANG_CORE_STRING_H\n"
"\n"
"#pragma once\n"
"\n"
"#ifndef SLANG_CORE_SIGNAL_H\n"
"#define SLANG_CORE_SIGNAL_H\n"
"\n"
"\n"
"namespace Slang\n"
"{\n"
"\n"
"enum class SignalType\n"
"{\n"
"    Unexpected,\n"
"    Unimplemented,\n"
"    AssertFailure,\n"
"    Unreachable,\n"
"    InvalidOperation,\n"
"    AbortCompilation,\n"
"};\n"
"\n"
"\n"
"// Note that message can be passed as nullptr for no message.\n"
"[[noreturn]] void handleSignal(SignalType type, char const* message);\n"
"\n"
"#define SLANG_UNEXPECTED(reason) ::Slang::handleSignal(::Slang::SignalType::Unexpected, reason)\n"
"\n"
"#define SLANG_UNIMPLEMENTED_X(what) ::Slang::handleSignal(::Slang::SignalType::Unimplemented, what)\n"
"\n"
"#define SLANG_UNREACHABLE(msg) ::Slang::handleSignal(::Slang::SignalType::Unreachable, msg)\n"
"\n"
"#define SLANG_ASSERT_FAILURE(msg) ::Slang::handleSignal(::Slang::SignalType::AssertFailure, msg)\n"
"\n"
"#define SLANG_INVALID_OPERATION(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::InvalidOperation, msg)\n"
"\n"
"#define SLANG_ABORT_COMPILATION(msg) \\\n"
"    ::Slang::handleSignal(::Slang::SignalType::AbortCompilation, msg)\n"
"\n"
"\n"
"const char* getLastSignalMessage();\n"
"\n"
"} // namespace Slang\n"
"\n"
"#endif\n"
"\n"
"#ifndef SLANG_H\n"
"#define SLANG_H\n"
"\n"
"#ifdef SLANG_USER_CONFIG\n"
"    #include SLANG_USER_CONFIG\n"
"#endif\n"
"\n"
"/** \\file slang.h\n"
"\n"
"The Slang API provides services to compile, reflect, and specialize code\n"
"written in the Slang shading language.\n"
"*/\n"
"\n"
"/*\n"
"The following section attempts to detect the compiler and version in use.\n"
"\n"
"If an application defines `SLANG_COMPILER` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_COMPILER\n"
"    #define SLANG_COMPILER\n"
"\n"
"    /*\n"
"    Compiler defines, see http://sourceforge.net/p/predef/wiki/Compilers/\n"
"    NOTE that SLANG_VC holds the compiler version - not just 1 or 0\n"
"    */\n"
"    #if defined(_MSC_VER)\n"
"        #if _MSC_VER >= 1900\n"
"            #define SLANG_VC 14\n"
"        #elif _MSC_VER >= 1800\n"
"            #define SLANG_VC 12\n"
"        #elif _MSC_VER >= 1700\n"
"            #define SLANG_VC 11\n"
"        #elif _MSC_VER >= 1600\n"
"            #define SLANG_VC 10\n"
"        #elif _MSC_VER >= 1500\n"
"            #define SLANG_VC 9\n"
"        #else\n"
"            #error \"unknown version of Visual C++ compiler\"\n"
"        #endif\n"
"    #elif defined(__clang__)\n"
"        #define SLANG_CLANG 1\n"
"    #elif defined(__SNC__)\n"
"        #define SLANG_SNC 1\n"
"    #elif defined(__ghs__)\n"
"        #define SLANG_GHS 1\n"
"    #elif defined(__GNUC__) /* note: __clang__, __SNC__, or __ghs__ imply __GNUC__ */\n"
"        #define SLANG_GCC 1\n"
"    #else\n"
"        #error \"unknown compiler\"\n"
"    #endif\n"
"    /*\n"
"    Any compilers not detected by the above logic are now now explicitly zeroed out.\n"
"    */\n"
"    #ifndef SLANG_VC\n"
"        #define SLANG_VC 0\n"
"    #endif\n"
"    #ifndef SLANG_CLANG\n"
"        #define SLANG_CLANG 0\n"
"    #endif\n"
"    #ifndef SLANG_SNC\n"
"        #define SLANG_SNC 0\n"
"    #endif\n"
"    #ifndef SLANG_GHS\n"
"        #define SLANG_GHS 0\n"
"    #endif\n"
"    #ifndef SLANG_GCC\n"
"        #define SLANG_GCC 0\n"
"    #endif\n"
"#endif /* SLANG_COMPILER */\n"
"\n"
"/*\n"
"The following section attempts to detect the target platform being compiled for.\n"
"\n"
"If an application defines `SLANG_PLATFORM` before including this header,\n"
"they take responsibility for setting any compiler-dependent macros\n"
"used later in the file.\n"
"\n"
"Most applications should not need to touch this section.\n"
"*/\n"
"#ifndef SLANG_PLATFORM\n"
"    #define SLANG_PLATFORM\n"
"    /**\n"
"    Operating system defines, see http://sourceforge.net/p/predef/wiki/OperatingSystems/\n"
"    */\n"
"    #if defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_PARTITION_APP\n"
"        #define SLANG_WINRT 1 /* Windows Runtime, either on Windows RT or Windows 8 */\n"
"    #elif defined(XBOXONE)\n"
"        #define SLANG_XBOXONE 1\n"
"    #elif defined(_WIN64) /* note: XBOXONE implies _WIN64 */\n"
"        #define SLANG_WIN64 1\n"
"    #elif defined(_M_PPC)\n"
"        #define SLANG_X360 1\n"
"    #elif defined(_WIN32) /* note: _M_PPC implies _WIN32 */\n"
"        #define SLANG_WIN32 1\n"
"    #elif defined(__ANDROID__)\n"
"        #define SLANG_ANDROID 1\n"
"    #elif defined(__linux__) || defined(__CYGWIN__) /* note: __ANDROID__ implies __linux__ */\n"
"        #define SLANG_LINUX 1\n"
"    #elif defined(__APPLE__)\n"
"        #include \"TargetConditionals.h\"\n"
"        #if TARGET_OS_MAC\n"
"            #define SLANG_OSX 1\n"
"        #else\n"
"            #define SLANG_IOS 1\n"
"        #endif\n"
"    #elif defined(__CELLOS_LV2__)\n"
"        #define SLANG_PS3 1\n"
;
sb << 
"    #elif defined(__ORBIS__)\n"
"        #define SLANG_PS4 1\n"
"    #elif defined(__SNC__) && defined(__arm__)\n"
"        #define SLANG_PSP2 1\n"
"    #elif defined(__ghs__)\n"
"        #define SLANG_WIIU 1\n"
"    #elif defined(__EMSCRIPTEN__)\n"
"        #define SLANG_WASM 1\n"
"    #else\n"
"        #error \"unknown target platform\"\n"
"    #endif\n"
"    /*\n"
"    Any platforms not detected by the above logic are now now explicitly zeroed out.\n"
"    */\n"
"    #ifndef SLANG_WINRT\n"
"        #define SLANG_WINRT 0\n"
"    #endif\n"
"    #ifndef SLANG_XBOXONE\n"
"        #define SLANG_XBOXONE 0\n"
"    #endif\n"
"    #ifndef SLANG_WIN64\n"
"        #define SLANG_WIN64 0\n"
"    #endif\n"
"    #ifndef SLANG_X360\n"
"        #define SLANG_X360 0\n"
"    #endif\n"
"    #ifndef SLANG_WIN32\n"
"        #define SLANG_WIN32 0\n"
"    #endif\n"
"    #ifndef SLANG_ANDROID\n"
"        #define SLANG_ANDROID 0\n"
"    #endif\n"
"    #ifndef SLANG_LINUX\n"
"        #define SLANG_LINUX 0\n"
"    #endif\n"
"    #ifndef SLANG_IOS\n"
"        #define SLANG_IOS 0\n"
"    #endif\n"
"    #ifndef SLANG_OSX\n"
"        #define SLANG_OSX 0\n"
"    #endif\n"
"    #ifndef SLANG_PS3\n"
"        #define SLANG_PS3 0\n"
"    #endif\n"
"    #ifndef SLANG_PS4\n"
"        #define SLANG_PS4 0\n"
"    #endif\n"
"    #ifndef SLANG_PSP2\n"
"        #define SLANG_PSP2 0\n"
"    #endif\n"
"    #ifndef SLANG_WIIU\n"
"        #define SLANG_WIIU 0\n"
"    #endif\n"
"#endif /* SLANG_PLATFORM */\n"
"\n"
"/* Shorthands for \"families\" of compilers/platforms */\n"
"#define SLANG_GCC_FAMILY (SLANG_CLANG || SLANG_SNC || SLANG_GHS || SLANG_GCC)\n"
"#define SLANG_WINDOWS_FAMILY (SLANG_WINRT || SLANG_WIN32 || SLANG_WIN64)\n"
"#define SLANG_MICROSOFT_FAMILY (SLANG_XBOXONE || SLANG_X360 || SLANG_WINDOWS_FAMILY)\n"
"#define SLANG_LINUX_FAMILY (SLANG_LINUX || SLANG_ANDROID)\n"
"#define SLANG_APPLE_FAMILY (SLANG_IOS || SLANG_OSX) /* equivalent to #if __APPLE__ */\n"
"#define SLANG_UNIX_FAMILY \\\n"
"    (SLANG_LINUX_FAMILY || SLANG_APPLE_FAMILY) /* shortcut for unix/posix platforms */\n"
"\n"
"/* Macros concerning DirectX */\n"
"#if !defined(SLANG_CONFIG_DX_ON_VK) || !SLANG_CONFIG_DX_ON_VK\n"
"    #define SLANG_ENABLE_DXVK 0\n"
"    #define SLANG_ENABLE_VKD3D 0\n"
"#else\n"
"    #define SLANG_ENABLE_DXVK 1\n"
"    #define SLANG_ENABLE_VKD3D 1\n"
"#endif\n"
"\n"
"#if SLANG_WINDOWS_FAMILY\n"
"    #define SLANG_ENABLE_DIRECTX 1\n"
"    #define SLANG_ENABLE_DXGI_DEBUG 1\n"
"    #define SLANG_ENABLE_DXBC_SUPPORT 1\n"
"    #define SLANG_ENABLE_PIX 1\n"
"#elif SLANG_LINUX_FAMILY\n"
"    #define SLANG_ENABLE_DIRECTX (SLANG_ENABLE_DXVK || SLANG_ENABLE_VKD3D)\n"
"    #define SLANG_ENABLE_DXGI_DEBUG 0\n"
"    #define SLANG_ENABLE_DXBC_SUPPORT 0\n"
"    #define SLANG_ENABLE_PIX 0\n"
"#else\n"
"    #define SLANG_ENABLE_DIRECTX 0\n"
"    #define SLANG_ENABLE_DXGI_DEBUG 0\n"
"    #define SLANG_ENABLE_DXBC_SUPPORT 0\n"
"    #define SLANG_ENABLE_PIX 0\n"
"#endif\n"
"\n"
"/* Macro for declaring if a method is no throw. Should be set before the return parameter. */\n"
"#ifndef SLANG_NO_THROW\n"
"    #if SLANG_WINDOWS_FAMILY && !defined(SLANG_DISABLE_EXCEPTIONS)\n"
"        #define SLANG_NO_THROW __declspec(nothrow)\n"
"    #endif\n"
"#endif\n"
"#ifndef SLANG_NO_THROW\n"
"    #define SLANG_NO_THROW\n"
"#endif\n"
"\n"
"/* The `SLANG_STDCALL` and `SLANG_MCALL` defines are used to set the calling\n"
"convention for interface methods.\n"
"*/\n"
"#ifndef SLANG_STDCALL\n"
"    #if SLANG_MICROSOFT_FAMILY\n"
"        #define SLANG_STDCALL __stdcall\n"
"    #else\n"
"        #define SLANG_STDCALL\n"
"    #endif\n"
"#endif\n"
"#ifndef SLANG_MCALL\n"
"    #define SLANG_MCALL SLANG_STDCALL\n"
"#endif\n"
"\n"
"\n"
"#if !defined(SLANG_STATIC) && !defined(SLANG_DYNAMIC)\n"
"    #define SLANG_DYNAMIC\n"
"#endif\n"
"\n"
"#if defined(_MSC_VER)\n"
"    #define SLANG_DLL_EXPORT __declspec(dllexport)\n"
"#else\n"
"    #if SLANG_WINDOWS_FAMILY\n"
"        #define SLANG_DLL_EXPORT \\\n"
"            __attribute__((dllexport)) __attribute__((__visibility__(\"default\")))\n"
"    #else\n"
"        #define SLANG_DLL_EXPORT __attribute__((__visibility__(\"default\")))\n"
"    #endif\n"
"#endif\n"
"\n"
"#if defined(SLANG_DYNAMIC)\n"
"    #if defined(_MSC_VER)\n"
"        #ifdef SLANG_DYNAMIC_EXPORT\n"
"            #define SLANG_API SLANG_DLL_EXPORT\n"
"        #else\n"
"            #define SLANG_API __declspec(dllimport)\n"
"        #endif\n"
"    #else\n"
"        // TODO: need to consider compiler capabilities\n"
"        // #     ifdef SLANG_DYNAMIC_EXPORT\n"
"        #define SLANG_API SLANG_DLL_EXPORT\n"
"    // #     endif\n"
"    #endif\n"
"#endif\n"
"\n"
"#ifndef SLANG_API\n"
"    #define SLANG_API\n"
"#endif\n"
"\n"
"// GCC Specific\n"
"#if SLANG_GCC_FAMILY\n"
"    #define SLANG_NO_INLINE __attribute__((noinline))\n"
"    #define SLANG_FORCE_INLINE inline __attribute__((always_inline))\n"
"    #define SLANG_BREAKPOINT(id) __builtin_trap();\n"
"#endif // SLANG_GCC_FAMILY\n"
"\n"
"#if SLANG_GCC_FAMILY || defined(__clang__)\n"
"    // Use the builtin directly so we don't need to have an include of stddef.h\n"
"    #define SLANG_OFFSET_OF(T, ELEMENT) __builtin_offsetof(T, ELEMENT)\n"
"#endif\n"
"\n"
"#ifndef SLANG_OFFSET_OF\n"
"    #define SLANG_OFFSET_OF(T, ELEMENT) (size_t(&((T*)1)->ELEMENT) - 1)\n"
"#endif\n"
"\n"
"// Microsoft VC specific\n"
"#if SLANG_VC\n"
"    #define SLANG_NO_INLINE __declspec(noinline)\n"
"    #define SLANG_FORCE_INLINE __forceinline\n"
"    #define SLANG_BREAKPOINT(id) __debugbreak();\n"
"\n"
"    #define SLANG_INT64(x) (x##i64)\n"
"    #define SLANG_UINT64(x) (x##ui64)\n"
"#endif // SLANG_MICROSOFT_FAMILY\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"    #define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"#ifndef SLANG_NO_INLINE\n"
"    #define SLANG_NO_INLINE\n"
"#endif\n"
"\n"
"#ifndef SLANG_COMPILE_TIME_ASSERT\n"
"    #define SLANG_COMPILE_TIME_ASSERT(x) static_assert(x)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BREAKPOINT\n"
"    // Make it crash with a write to 0!\n"
"    #define SLANG_BREAKPOINT(id) (*((int*)0) = int(id));\n"
"#endif\n"
"\n"
"// Use for getting the amount of members of a standard C array.\n"
"// Use 0[x] here to catch the case where x has an overloaded subscript operator\n"
"#define SLANG_COUNT_OF(x) (SlangSSizeT(sizeof(x) / sizeof(0 [x])))\n"
"/// SLANG_INLINE exists to have a way to inline consistent with SLANG_ALWAYS_INLINE\n"
"#define SLANG_INLINE inline\n"
"\n"
"// If explicitly disabled and not set, set to not available\n"
"#if !defined(SLANG_HAS_EXCEPTIONS) && defined(SLANG_DISABLE_EXCEPTIONS)\n"
"    #define SLANG_HAS_EXCEPTIONS 0\n"
"#endif\n"
"\n"
"// If not set, the default is exceptions are available\n"
"#ifndef SLANG_HAS_EXCEPTIONS\n"
"    #define SLANG_HAS_EXCEPTIONS 1\n"
"#endif\n"
"\n"
"// Other defines\n"
"#define SLANG_STRINGIZE_HELPER(X) #X\n"
"#define SLANG_STRINGIZE(X) SLANG_STRINGIZE_HELPER(X)\n"
"\n"
"#define SLANG_CONCAT_HELPER(X, Y) X##Y\n"
"#define SLANG_CONCAT(X, Y) SLANG_CONCAT_HELPER(X, Y)\n"
"\n"
"#ifndef SLANG_UNUSED\n"
"    #define SLANG_UNUSED(v) (void)v;\n"
"#endif\n"
"\n"
"#if defined(__llvm__)\n"
"    #define SLANG_MAYBE_UNUSED [[maybe_unused]]\n"
"#else\n"
"    #define SLANG_MAYBE_UNUSED\n"
"#endif\n"
"\n"
"// Used for doing constant literals\n"
"#ifndef SLANG_INT64\n"
"    #define SLANG_INT64(x) (x##ll)\n"
"#endif\n"
"#ifndef SLANG_UINT64\n"
"    #define SLANG_UINT64(x) (x##ull)\n"
"#endif\n"
"\n"
"\n"
"#ifdef __cplusplus\n"
"    #define SLANG_EXTERN_C extern \"C\"\n"
"#else\n"
"    #define SLANG_EXTERN_C\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"    // C++ specific macros\n"
"    // Clang\n"
"    #if SLANG_CLANG\n"
"        #if (__clang_major__ * 10 + __clang_minor__) >= 33\n"
"            #define SLANG_HAS_MOVE_SEMANTICS 1\n"
"            #define SLANG_HAS_ENUM_CLASS 1\n"
"            #define SLANG_OVERRIDE override\n"
"        #endif\n"
"\n"
"    // Gcc\n"
"    #elif SLANG_GCC_FAMILY\n"
"        // Check for C++11\n"
"        #if (__cplusplus >= 201103L)\n"
"            #if (__GNUC__ * 100 + __GNUC_MINOR__) >= 405\n"
"                #define SLANG_HAS_MOVE_SEMANTICS 1\n"
"            #endif\n"
"            #if (__GNUC__ * 100 + __GNUC_MINOR__) >= 406\n"
"                #define SLANG_HAS_ENUM_CLASS 1\n"
"            #endif\n"
"            #if (__GNUC__ * 100 + __GNUC_MINOR__) >= 407\n"
"                #define SLANG_OVERRIDE override\n"
"            #endif\n"
"        #endif\n"
"    #endif // SLANG_GCC_FAMILY\n"
"\n"
"    // Visual Studio\n"
"\n"
"    #if SLANG_VC\n"
"        // C4481: nonstandard extension used: override specifier 'override'\n"
"        #if _MSC_VER < 1700\n"
"            #pragma warning(disable : 4481)\n"
"        #endif\n"
"        #define SLANG_OVERRIDE override\n"
"        #if _MSC_VER >= 1600\n"
"            #define SLANG_HAS_MOVE_SEMANTICS 1\n"
"        #endif\n"
"        #if _MSC_VER >= 1700\n"
"            #define SLANG_HAS_ENUM_CLASS 1\n"
"        #endif\n"
"    #endif // SLANG_VC\n"
"\n"
"    // Set non set\n"
"    #ifndef SLANG_OVERRIDE\n"
"        #define SLANG_OVERRIDE\n"
"    #endif\n"
"    #ifndef SLANG_HAS_ENUM_CLASS\n"
"        #define SLANG_HAS_ENUM_CLASS 0\n"
"    #endif\n"
"    #ifndef SLANG_HAS_MOVE_SEMANTICS\n"
"        #define SLANG_HAS_MOVE_SEMANTICS 0\n"
"    #endif\n"
"\n"
"#endif // __cplusplus\n"
"\n"
"/* Macros for detecting processor */\n"
"#if defined(_M_ARM) || defined(__ARM_EABI__)\n"
"    // This is special case for nVidia tegra\n"
"    #define SLANG_PROCESSOR_ARM 1\n"
"#elif defined(__i386__) || defined(_M_IX86)\n"
"    #define SLANG_PROCESSOR_X86 1\n"
"#elif defined(_M_AMD64) || defined(_M_X64) || defined(__amd64) || defined(__x86_64)\n"
"    #define SLANG_PROCESSOR_X86_64 1\n"
"#elif defined(_PPC_) || defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC)\n"
"    #if defined(__powerpc64__) || defined(__ppc64__) || defined(__PPC64__) || \\\n"
"        defined(__64BIT__) || defined(_LP64) || defined(__LP64__)\n"
"        #define SLANG_PROCESSOR_POWER_PC_64 1\n"
"    #else\n"
"        #define SLANG_PROCESSOR_POWER_PC 1\n"
"    #endif\n"
"#elif defined(__arm__)\n"
"    #define SLANG_PROCESSOR_ARM 1\n"
"#elif defined(_M_ARM64) || defined(__aarch64__) || defined(__ARM_ARCH_ISA_A64)\n"
"    #define SLANG_PROCESSOR_ARM_64 1\n"
"#elif defined(__EMSCRIPTEN__)\n"
"    #define SLANG_PROCESSOR_WASM 1\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_ARM\n"
"    #define SLANG_PROCESSOR_ARM 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_ARM_64\n"
"    #define SLANG_PROCESSOR_ARM_64 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_X86\n"
"    #define SLANG_PROCESSOR_X86 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_X86_64\n"
"    #define SLANG_PROCESSOR_X86_64 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_POWER_PC\n"
"    #define SLANG_PROCESSOR_POWER_PC 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_PROCESSOR_POWER_PC_64\n"
"    #define SLANG_PROCESSOR_POWER_PC_64 0\n"
"#endif\n"
"\n"
"// Processor families\n"
"\n"
"#define SLANG_PROCESSOR_FAMILY_X86 (SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_X86)\n"
"#define SLANG_PROCESSOR_FAMILY_ARM (SLANG_PROCESSOR_ARM | SLANG_PROCESSOR_ARM_64)\n"
"#define SLANG_PROCESSOR_FAMILY_POWER_PC (SLANG_PROCESSOR_POWER_PC_64 | SLANG_PROCESSOR_POWER_PC)\n"
"\n"
"// Pointer size\n"
"#define SLANG_PTR_IS_64 \\\n"
"    (SLANG_PROCESSOR_ARM_64 | SLANG_PROCESSOR_X86_64 | SLANG_PROCESSOR_POWER_PC_64)\n"
"#define SLANG_PTR_IS_32 (SLANG_PTR_IS_64 ^ 1)\n"
"\n"
"// Processor features\n"
"#if SLANG_PROCESSOR_FAMILY_X86\n"
"    #define SLANG_LITTLE_ENDIAN 1\n"
"    #define SLANG_UNALIGNED_ACCESS 1\n"
"#elif SLANG_PROCESSOR_FAMILY_ARM\n"
"    #if defined(__ARMEB__)\n"
"        #define SLANG_BIG_ENDIAN 1\n"
"    #else\n"
"        #define SLANG_LITTLE_ENDIAN 1\n"
"    #endif\n"
"#elif SLANG_PROCESSOR_FAMILY_POWER_PC\n"
"    #define SLANG_BIG_ENDIAN 1\n"
"#elif SLANG_WASM\n"
"    #define SLANG_LITTLE_ENDIAN 1\n"
"#endif\n"
"\n"
"#ifndef SLANG_LITTLE_ENDIAN\n"
"    #define SLANG_LITTLE_ENDIAN 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_BIG_ENDIAN\n"
"    #define SLANG_BIG_ENDIAN 0\n"
"#endif\n"
"\n"
"#ifndef SLANG_UNALIGNED_ACCESS\n"
"    #define SLANG_UNALIGNED_ACCESS 0\n"
"#endif\n"
"\n"
"// Backtrace\n"
"#if SLANG_LINUX_FAMILY\n"
"    #include <features.h> // for __GLIBC__ define, if using GNU libc\n"
"    #if defined(__GLIBC__) || (__ANDROID_API__ >= 33)\n"
"        #define SLANG_HAS_BACKTRACE 1\n"
"    #else\n"
"        #define SLANG_HAS_BACKTRACE 0\n"
"    #endif\n"
"#else\n"
"    #define SLANG_HAS_BACKTRACE 0\n"
"#endif\n"
"\n"
"// One endianness must be set\n"
"#if ((SLANG_BIG_ENDIAN | SLANG_LITTLE_ENDIAN) == 0)\n"
"    #error \"Couldn't determine endianness\"\n"
"#endif\n"
"\n"
"#ifndef SLANG_NO_INTTYPES\n"
"    #include <inttypes.h>\n"
"#endif // ! SLANG_NO_INTTYPES\n"
"\n"
"#ifndef SLANG_NO_STDDEF\n"
"    #include <stddef.h>\n"
"#endif // ! SLANG_NO_STDDEF\n"
"\n"
"#ifdef SLANG_NO_DEPRECATION\n"
"    #define SLANG_DEPRECATED\n"
"#else\n"
"    #define SLANG_DEPRECATED [[deprecated]]\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\"\n"
"{\n"
"#endif\n"
"    /*!\n"
"    @mainpage Introduction\n"
"\n"
"    API Reference: slang.h\n"
"\n"
"    @file slang.h\n"
"    */\n"
"\n"
"    typedef uint32_t SlangUInt32;\n"
"    typedef int32_t SlangInt32;\n"
"\n"
"    // Use SLANG_PTR_ macros to determine SlangInt/SlangUInt types.\n"
"    // This is used over say using size_t/ptrdiff_t/intptr_t/uintptr_t, because on some targets,\n"
"    // these types are distinct from their uint_t/int_t equivalents and so produce ambiguity with\n"
"    // function overloading.\n"
"    //\n"
"    // SlangSizeT is helpful as on some compilers size_t is distinct from a regular integer type and\n"
"    // so overloading doesn't work. Casting to SlangSizeT works around this.\n"
"#if SLANG_PTR_IS_64\n"
"    typedef int64_t SlangInt;\n"
"    typedef uint64_t SlangUInt;\n"
"\n"
"    typedef int64_t SlangSSizeT;\n"
"    typedef uint64_t SlangSizeT;\n"
"#else\n"
"typedef int32_t SlangInt;\n"
"typedef uint32_t SlangUInt;\n"
"\n"
"typedef int32_t SlangSSizeT;\n"
"typedef uint32_t SlangSizeT;\n"
"#endif\n"
"\n"
"    typedef bool SlangBool;\n"
"\n"
"\n"
"    /*!\n"
"    @brief Severity of a diagnostic generated by the compiler.\n"
"    Values come from the enum below, with higher values representing more severe\n"
"    conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation\n"
"    failure.\n"
"    */\n"
"    typedef int SlangSeverityIntegral;\n"
"    enum SlangSeverity : SlangSeverityIntegral\n"
"    {\n"
"        SLANG_SEVERITY_DISABLED = 0, /**< A message that is disabled, filtered out. */\n"
"        SLANG_SEVERITY_NOTE,         /**< An informative message. */\n"
"        SLANG_SEVERITY_WARNING,      /**< A warning, which indicates a possible problem. */\n"
"        SLANG_SEVERITY_ERROR,        /**< An error, indicating that compilation failed. */\n"
"        SLANG_SEVERITY_FATAL,    /**< An unrecoverable error, which forced compilation to abort. */\n"
"        SLANG_SEVERITY_INTERNAL, /**< An internal error, indicating a logic error in the compiler.\n"
"                                  */\n"
"    };\n"
"\n"
"    typedef int SlangDiagnosticFlags;\n"
"    enum\n"
"    {\n"
"        SLANG_DIAGNOSTIC_FLAG_VERBOSE_PATHS = 0x01,\n"
"        SLANG_DIAGNOSTIC_FLAG_TREAT_WARNINGS_AS_ERRORS = 0x02\n"
"    };\n"
"\n"
"    typedef int SlangBindableResourceIntegral;\n"
"    enum SlangBindableResourceType : SlangBindableResourceIntegral\n"
"    {\n"
"        SLANG_NON_BINDABLE = 0,\n"
"        SLANG_TEXTURE,\n"
"        SLANG_SAMPLER,\n"
"        SLANG_UNIFORM_BUFFER,\n"
"        SLANG_STORAGE_BUFFER,\n"
"    };\n"
"\n"
"    /* NOTE! To keep binary compatibility care is needed with this enum!\n"
"\n"
"    * To add value, only add at the bottom (before COUNT_OF)\n"
"    * To remove a value, add _DEPRECATED as a suffix, but leave in the list\n"
"\n"
"    This will make the enum values stable, and compatible with libraries that might not use the\n"
"    latest enum values.\n"
"    */\n"
"    typedef int SlangCompileTargetIntegral;\n"
"    enum SlangCompileTarget : SlangCompileTargetIntegral\n"
"    {\n"
"        SLANG_TARGET_UNKNOWN,\n"
"        SLANG_TARGET_NONE,\n"
"        SLANG_GLSL,\n"
"        SLANG_GLSL_VULKAN_DEPRECATED,          //< deprecated and removed: just use `SLANG_GLSL`.\n"
"        SLANG_GLSL_VULKAN_ONE_DESC_DEPRECATED, //< deprecated and removed.\n"
"        SLANG_HLSL,\n"
"        SLANG_SPIRV,\n"
"        SLANG_SPIRV_ASM,\n"
"        SLANG_DXBC,\n"
"        SLANG_DXBC_ASM,\n"
"        SLANG_DXIL,\n"
"        SLANG_DXIL_ASM,\n"
"        SLANG_C_SOURCE,              ///< The C language\n"
"        SLANG_CPP_SOURCE,            ///< C++ code for shader kernels.\n"
"        SLANG_HOST_EXECUTABLE,       ///< Standalone binary executable (for hosting CPU/OS)\n"
"        SLANG_SHADER_SHARED_LIBRARY, ///< A shared library/Dll for shader kernels (for hosting\n"
"                                     ///< CPU/OS)\n"
"        SLANG_SHADER_HOST_CALLABLE,  ///< A CPU target that makes the compiled shader code available\n"
"                                     ///< to be run immediately\n"
"        SLANG_CUDA_SOURCE,           ///< Cuda source\n"
"        SLANG_PTX,                   ///< PTX\n"
"        SLANG_CUDA_OBJECT_CODE,      ///< Object code that contains CUDA functions.\n"
"        SLANG_OBJECT_CODE,           ///< Object code that can be used for later linking\n"
"        SLANG_HOST_CPP_SOURCE,       ///< C++ code for host library or executable.\n"
"        SLANG_HOST_HOST_CALLABLE,    ///< Host callable host code (ie non kernel/shader)\n"
"        SLANG_CPP_PYTORCH_BINDING,   ///< C++ PyTorch binding code.\n"
"        SLANG_METAL,                 ///< Metal shading language\n"
"        SLANG_METAL_LIB,             ///< Metal library\n"
"        SLANG_METAL_LIB_ASM,         ///< Metal library assembly\n"
"        SLANG_HOST_SHARED_LIBRARY,   ///< A shared library/Dll for host code (for hosting CPU/OS)\n"
"        SLANG_WGSL,                  ///< WebGPU shading language\n"
"        SLANG_WGSL_SPIRV_ASM,        ///< SPIR-V assembly via WebGPU shading language\n"
"        SLANG_WGSL_SPIRV,            ///< SPIR-V via WebGPU shading language\n"
"\n"
"        SLANG_HOST_VM, ///< Bytecode that can be interpreted by the Slang VM\n"
"        SLANG_TARGET_COUNT_OF,\n"
"    };\n"
"\n"
"    /* A \"container format\" describes the way that the outputs\n"
"    for multiple files, entry points, targets, etc. should be\n"
"    combined into a single artifact for output. */\n"
"    typedef int SlangContainerFormatIntegral;\n"
"    enum SlangContainerFormat : SlangContainerFormatIntegral\n"
"    {\n"
"        /* Don't generate a container. */\n"
"        SLANG_CONTAINER_FORMAT_NONE,\n"
"\n"
"        /* Generate a container in the `.slang-module` format,\n"
"        which includes reflection information, compiled kernels, etc. */\n"
"        SLANG_CONTAINER_FORMAT_SLANG_MODULE,\n"
"    };\n"
"\n"
"    typedef int SlangPassThroughIntegral;\n"
"    enum SlangPassThrough : SlangPassThroughIntegral\n"
"    {\n"
"        SLANG_PASS_THROUGH_NONE,\n"
"        SLANG_PASS_THROUGH_FXC,\n"
"        SLANG_PASS_THROUGH_DXC,\n"
;
sb << 
"        SLANG_PASS_THROUGH_GLSLANG,\n"
"        SLANG_PASS_THROUGH_SPIRV_DIS,\n"
"        SLANG_PASS_THROUGH_CLANG,         ///< Clang C/C++ compiler\n"
"        SLANG_PASS_THROUGH_VISUAL_STUDIO, ///< Visual studio C/C++ compiler\n"
"        SLANG_PASS_THROUGH_GCC,           ///< GCC C/C++ compiler\n"
"        SLANG_PASS_THROUGH_GENERIC_C_CPP, ///< Generic C or C++ compiler, which is decided by the\n"
"                                          ///< source type\n"
"        SLANG_PASS_THROUGH_NVRTC,         ///< NVRTC Cuda compiler\n"
"        SLANG_PASS_THROUGH_LLVM,          ///< LLVM 'compiler' - includes LLVM and Clang\n"
"        SLANG_PASS_THROUGH_SPIRV_OPT,     ///< SPIRV-opt\n"
"        SLANG_PASS_THROUGH_METAL,         ///< Metal compiler\n"
"        SLANG_PASS_THROUGH_TINT,          ///< Tint WGSL compiler\n"
"        SLANG_PASS_THROUGH_SPIRV_LINK,    ///< SPIRV-link\n"
"        SLANG_PASS_THROUGH_COUNT_OF,\n"
"    };\n"
"\n"
"    /* Defines an archive type used to holds a 'file system' type structure. */\n"
"    typedef int SlangArchiveTypeIntegral;\n"
"    enum SlangArchiveType : SlangArchiveTypeIntegral\n"
"    {\n"
"        SLANG_ARCHIVE_TYPE_UNDEFINED,\n"
"        SLANG_ARCHIVE_TYPE_ZIP,\n"
"        SLANG_ARCHIVE_TYPE_RIFF, ///< Riff container with no compression\n"
"        SLANG_ARCHIVE_TYPE_RIFF_DEFLATE,\n"
"        SLANG_ARCHIVE_TYPE_RIFF_LZ4,\n"
"        SLANG_ARCHIVE_TYPE_COUNT_OF,\n"
"    };\n"
"\n"
"    /*!\n"
"    Flags to control compilation behavior.\n"
"    */\n"
"    typedef unsigned int SlangCompileFlags;\n"
"    enum\n"
"    {\n"
"        /* Do as little mangling of names as possible, to try to preserve original names */\n"
"        SLANG_COMPILE_FLAG_NO_MANGLING = 1 << 3,\n"
"\n"
"        /* Skip code generation step, just check the code and generate layout */\n"
"        SLANG_COMPILE_FLAG_NO_CODEGEN = 1 << 4,\n"
"\n"
"        /* Obfuscate shader names on release products */\n"
"        SLANG_COMPILE_FLAG_OBFUSCATE = 1 << 5,\n"
"\n"
"        /* Deprecated flags: kept around to allow existing applications to\n"
"        compile. Note that the relevant features will still be left in\n"
"        their default state. */\n"
"        SLANG_COMPILE_FLAG_NO_CHECKING = 0,\n"
"        SLANG_COMPILE_FLAG_SPLIT_MIXED_TYPES = 0,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Flags to control code generation behavior of a compilation target */\n"
"    typedef unsigned int SlangTargetFlags;\n"
"    enum\n"
"    {\n"
"        /* When compiling for a D3D Shader Model 5.1 or higher target, allocate\n"
"           distinct register spaces for parameter blocks.\n"
"\n"
"           @deprecated This behavior is now enabled unconditionally.\n"
"        */\n"
"        SLANG_TARGET_FLAG_PARAMETER_BLOCKS_USE_REGISTER_SPACES = 1 << 4,\n"
"\n"
"        /* When set, will generate target code that contains all entrypoints defined\n"
"           in the input source or specified via the `spAddEntryPoint` function in a\n"
"           single output module (library/source file).\n"
"        */\n"
"        SLANG_TARGET_FLAG_GENERATE_WHOLE_PROGRAM = 1 << 8,\n"
"\n"
"        /* When set, will dump out the IR between intermediate compilation steps.*/\n"
"        SLANG_TARGET_FLAG_DUMP_IR = 1 << 9,\n"
"\n"
"        /* When set, will generate SPIRV directly rather than via glslang. */\n"
"        // This flag will be deprecated, use CompilerOption instead.\n"
"        SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY = 1 << 10,\n"
"    };\n"
"    inline constexpr SlangTargetFlags kDefaultTargetFlags =\n"
"        SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY;\n"
"\n"
"    /*!\n"
"    @brief Options to control floating-point precision guarantees for a target.\n"
"    */\n"
"    typedef unsigned int SlangFloatingPointModeIntegral;\n"
"    enum SlangFloatingPointMode : SlangFloatingPointModeIntegral\n"
"    {\n"
"        SLANG_FLOATING_POINT_MODE_DEFAULT = 0,\n"
"        SLANG_FLOATING_POINT_MODE_FAST,\n"
"        SLANG_FLOATING_POINT_MODE_PRECISE,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Options to control floating-point denormal handling mode for a target.\n"
"    */\n"
"    typedef unsigned int SlangFpDenormalModeIntegral;\n"
"    enum SlangFpDenormalMode : SlangFpDenormalModeIntegral\n"
"    {\n"
"        SLANG_FP_DENORM_MODE_ANY = 0,\n"
"        SLANG_FP_DENORM_MODE_PRESERVE,\n"
"        SLANG_FP_DENORM_MODE_FTZ,\n"
"    };\n"
"\n"
"    /*!\n"
"    @brief Options to control emission of `#line` directives\n"
"    */\n"
"    typedef unsigned int SlangLineDirectiveModeIntegral;\n"
"    enum SlangLineDirectiveMode : SlangLineDirectiveModeIntegral\n"
"    {\n"
"        SLANG_LINE_DIRECTIVE_MODE_DEFAULT =\n"
"            0,                              /**< Default behavior: pick behavior base on target. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_NONE,     /**< Don't emit line directives at all. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_STANDARD, /**< Emit standard C-style `#line` directives. */\n"
"        SLANG_LINE_DIRECTIVE_MODE_GLSL, /**< Emit GLSL-style directives with file *number* instead\n"
"                                           of name */\n"
"        SLANG_LINE_DIRECTIVE_MODE_SOURCE_MAP, /**< Use a source map to track line mappings (ie no\n"
"                                                 #line will appear in emitting source) */\n"
"    };\n"
"\n"
"    typedef int SlangSourceLanguageIntegral;\n"
"    enum SlangSourceLanguage : SlangSourceLanguageIntegral\n"
"    {\n"
"        SLANG_SOURCE_LANGUAGE_UNKNOWN,\n"
"        SLANG_SOURCE_LANGUAGE_SLANG,\n"
"        SLANG_SOURCE_LANGUAGE_HLSL,\n"
"        SLANG_SOURCE_LANGUAGE_GLSL,\n"
"        SLANG_SOURCE_LANGUAGE_C,\n"
"        SLANG_SOURCE_LANGUAGE_CPP,\n"
"        SLANG_SOURCE_LANGUAGE_CUDA,\n"
"        SLANG_SOURCE_LANGUAGE_SPIRV,\n"
"        SLANG_SOURCE_LANGUAGE_METAL,\n"
"        SLANG_SOURCE_LANGUAGE_WGSL,\n"
"        SLANG_SOURCE_LANGUAGE_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangProfileIDIntegral;\n"
"    enum SlangProfileID : SlangProfileIDIntegral\n"
"    {\n"
"        SLANG_PROFILE_UNKNOWN,\n"
"    };\n"
"\n"
"\n"
"    typedef SlangInt32 SlangCapabilityIDIntegral;\n"
"    enum SlangCapabilityID : SlangCapabilityIDIntegral\n"
"    {\n"
"        SLANG_CAPABILITY_UNKNOWN = 0,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangMatrixLayoutModeIntegral;\n"
"    enum SlangMatrixLayoutMode : SlangMatrixLayoutModeIntegral\n"
"    {\n"
"        SLANG_MATRIX_LAYOUT_MODE_UNKNOWN = 0,\n"
"        SLANG_MATRIX_LAYOUT_ROW_MAJOR,\n"
"        SLANG_MATRIX_LAYOUT_COLUMN_MAJOR,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangStageIntegral;\n"
"    enum SlangStage : SlangStageIntegral\n"
"    {\n"
"        SLANG_STAGE_NONE,\n"
"        SLANG_STAGE_VERTEX,\n"
"        SLANG_STAGE_HULL,\n"
"        SLANG_STAGE_DOMAIN,\n"
"        SLANG_STAGE_GEOMETRY,\n"
"        SLANG_STAGE_FRAGMENT,\n"
"        SLANG_STAGE_COMPUTE,\n"
"        SLANG_STAGE_RAY_GENERATION,\n"
"        SLANG_STAGE_INTERSECTION,\n"
"        SLANG_STAGE_ANY_HIT,\n"
"        SLANG_STAGE_CLOSEST_HIT,\n"
"        SLANG_STAGE_MISS,\n"
"        SLANG_STAGE_CALLABLE,\n"
"        SLANG_STAGE_MESH,\n"
"        SLANG_STAGE_AMPLIFICATION,\n"
"        SLANG_STAGE_DISPATCH,\n"
"        //\n"
"        SLANG_STAGE_COUNT,\n"
"\n"
"        // alias:\n"
"        SLANG_STAGE_PIXEL = SLANG_STAGE_FRAGMENT,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangDebugInfoLevelIntegral;\n"
"    enum SlangDebugInfoLevel : SlangDebugInfoLevelIntegral\n"
"    {\n"
"        SLANG_DEBUG_INFO_LEVEL_NONE = 0, /**< Don't emit debug information at all. */\n"
"        SLANG_DEBUG_INFO_LEVEL_MINIMAL,  /**< Emit as little debug information as possible, while\n"
"                                            still supporting stack trackers. */\n"
"        SLANG_DEBUG_INFO_LEVEL_STANDARD, /**< Emit whatever is the standard level of debug\n"
"                                            information for each target. */\n"
"        SLANG_DEBUG_INFO_LEVEL_MAXIMAL,  /**< Emit as much debug information as possible for each\n"
"                                            target. */\n"
"    };\n"
"\n"
"    /* Describes the debugging information format produced during a compilation. */\n"
"    typedef SlangUInt32 SlangDebugInfoFormatIntegral;\n"
"    enum SlangDebugInfoFormat : SlangDebugInfoFormatIntegral\n"
"    {\n"
"        SLANG_DEBUG_INFO_FORMAT_DEFAULT, ///< Use the default debugging format for the target\n"
"        SLANG_DEBUG_INFO_FORMAT_C7,  ///< CodeView C7 format (typically means debugging information\n"
"                                     ///< is embedded in the binary)\n"
"        SLANG_DEBUG_INFO_FORMAT_PDB, ///< Program database\n"
"\n"
"        SLANG_DEBUG_INFO_FORMAT_STABS, ///< Stabs\n"
"        SLANG_DEBUG_INFO_FORMAT_COFF,  ///< COFF debug info\n"
"        SLANG_DEBUG_INFO_FORMAT_DWARF, ///< DWARF debug info (we may want to support specifying the\n"
"                                       ///< version)\n"
"\n"
"        SLANG_DEBUG_INFO_FORMAT_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangOptimizationLevelIntegral;\n"
"    enum SlangOptimizationLevel : SlangOptimizationLevelIntegral\n"
"    {\n"
"        SLANG_OPTIMIZATION_LEVEL_NONE = 0, /**< Don't optimize at all. */\n"
"        SLANG_OPTIMIZATION_LEVEL_DEFAULT,  /**< Default optimization level: balance code quality and\n"
"                                              compilation time. */\n"
"        SLANG_OPTIMIZATION_LEVEL_HIGH,     /**< Optimize aggressively. */\n"
"        SLANG_OPTIMIZATION_LEVEL_MAXIMAL, /**< Include optimizations that may take a very long time,\n"
"                                             or may involve severe space-vs-speed tradeoffs */\n"
"    };\n"
"\n"
"    enum SlangEmitSpirvMethod\n"
"    {\n"
"        SLANG_EMIT_SPIRV_DEFAULT = 0,\n"
"        SLANG_EMIT_SPIRV_VIA_GLSL,\n"
"        SLANG_EMIT_SPIRV_DIRECTLY,\n"
"    };\n"
"\n"
"    // All compiler option names supported by Slang.\n"
"    namespace slang\n"
"    {\n"
"    enum class CompilerOptionName\n"
"    {\n"
"        MacroDefine, // stringValue0: macro name;  stringValue1: macro value\n"
"        DepFile,\n"
"        EntryPointName,\n"
"        Specialize,\n"
"        Help,\n"
"        HelpStyle,\n"
"        Include, // stringValue: additional include path.\n"
"        Language,\n"
"        MatrixLayoutColumn,         // bool\n"
"        MatrixLayoutRow,            // bool\n"
"        ZeroInitialize,             // bool\n"
"        IgnoreCapabilities,         // bool\n"
"        RestrictiveCapabilityCheck, // bool\n"
"        ModuleName,                 // stringValue0: module name.\n"
"        Output,\n"
"        Profile, // intValue0: profile\n"
"        Stage,   // intValue0: stage\n"
"        Target,  // intValue0: CodeGenTarget\n"
"        Version,\n"
"        WarningsAsErrors, // stringValue0: \"all\" or comma separated list of warning codes or names.\n"
"        DisableWarnings,  // stringValue0: comma separated list of warning codes or names.\n"
"        EnableWarning,    // stringValue0: warning code or name.\n"
"        DisableWarning,   // stringValue0: warning code or name.\n"
"        DumpWarningDiagnostics,\n"
"        InputFilesRemain,\n"
"        EmitIr,                        // bool\n"
"        ReportDownstreamTime,          // bool\n"
"        ReportPerfBenchmark,           // bool\n"
"        ReportCheckpointIntermediates, // bool\n"
"        SkipSPIRVValidation,           // bool\n"
"        SourceEmbedStyle,\n"
"        SourceEmbedName,\n"
"        SourceEmbedLanguage,\n"
"        DisableShortCircuit,            // bool\n"
"        MinimumSlangOptimization,       // bool\n"
"        DisableNonEssentialValidations, // bool\n"
"        DisableSourceMap,               // bool\n"
"        UnscopedEnum,                   // bool\n"
"        PreserveParameters, // bool: preserve all resource parameters in the output code.\n"
"        // Target\n"
"\n"
"        Capability,                // intValue0: CapabilityName\n"
"        DefaultImageFormatUnknown, // bool\n"
"        DisableDynamicDispatch,    // bool\n"
"        DisableSpecialization,     // bool\n"
"        FloatingPointMode,         // intValue0: FloatingPointMode\n"
"        DebugInformation,          // intValue0: DebugInfoLevel\n"
"        LineDirectiveMode,\n"
"        Optimization, // intValue0: OptimizationLevel\n"
"        Obfuscate,    // bool\n"
"\n"
"        VulkanBindShift, // intValue0 (higher 8 bits): kind; intValue0(lower bits): set; intValue1:\n"
"                         // shift\n"
"        VulkanBindGlobals,       // intValue0: index; intValue1: set\n"
"        VulkanInvertY,           // bool\n"
"        VulkanUseDxPositionW,    // bool\n"
"        VulkanUseEntryPointName, // bool\n"
"        VulkanUseGLLayout,       // bool\n"
"        VulkanEmitReflection,    // bool\n"
"\n"
"        GLSLForceScalarLayout,   // bool\n"
"        EnableEffectAnnotations, // bool\n"
"\n"
"        EmitSpirvViaGLSL,     // bool (will be deprecated)\n"
"        EmitSpirvDirectly,    // bool (will be deprecated)\n"
"        SPIRVCoreGrammarJSON, // stringValue0: json path\n"
"        IncompleteLibrary,    // bool, when set, will not issue an error when the linked program has\n"
"                              // unresolved extern function symbols.\n"
"\n"
"        // Downstream\n"
"\n"
"        CompilerPath,\n"
"        DefaultDownstreamCompiler,\n"
"        DownstreamArgs, // stringValue0: downstream compiler name. stringValue1: argument list, one\n"
"                        // per line.\n"
"        PassThrough,\n"
"\n"
"        // Repro\n"
"\n"
"        DumpRepro,\n"
"        DumpReproOnError,\n"
"        ExtractRepro,\n"
"        LoadRepro,\n"
"        LoadReproDirectory,\n"
"        ReproFallbackDirectory,\n"
"\n"
"        // Debugging\n"
"\n"
"        DumpAst,\n"
"        DumpIntermediatePrefix,\n"
"        DumpIntermediates, // bool\n"
"        DumpIr,            // bool\n"
"        DumpIrIds,\n"
"        PreprocessorOutput,\n"
"        OutputIncludes,\n"
"        ReproFileSystem,\n"
"        REMOVED_SerialIR, // deprecated and removed\n"
"        SkipCodeGen,      // bool\n"
"        ValidateIr,       // bool\n"
"        VerbosePaths,\n"
"        VerifyDebugSerialIr,\n"
"        NoCodeGen, // Not used.\n"
"\n"
"        // Experimental\n"
"\n"
"        FileSystem,\n"
"        Heterogeneous,\n"
"        NoMangle,\n"
"        NoHLSLBinding,\n"
"        NoHLSLPackConstantBufferElements,\n"
"        ValidateUniformity,\n"
"        AllowGLSL,\n"
"        EnableExperimentalPasses,\n"
"        BindlessSpaceIndex, // int\n"
"\n"
"        // Internal\n"
"\n"
"        ArchiveType,\n"
"        CompileCoreModule,\n"
"        Doc,\n"
"\n"
"        IrCompression, //< deprecated\n"
"\n"
"        LoadCoreModule,\n"
"        ReferenceModule,\n"
"        SaveCoreModule,\n"
"        SaveCoreModuleBinSource,\n"
"        TrackLiveness,\n"
"        LoopInversion, // bool, enable loop inversion optimization\n"
"\n"
"        ParameterBlocksUseRegisterSpaces, // Deprecated\n"
"        LanguageVersion,                  // intValue0: SlangLanguageVersion\n"
"        TypeConformance, // stringValue0: additional type conformance to link, in the format of\n"
"                         // \"<TypeName>:<IInterfaceName>[=<sequentialId>]\", for example\n"
"                         // \"Impl:IFoo=3\" or \"Impl:IFoo\".\n"
"        EnableExperimentalDynamicDispatch, // bool, experimental\n"
"        EmitReflectionJSON,                // bool\n"
"\n"
"        CountOfParsableOptions,\n"
"\n"
"        // Used in parsed options only.\n"
"        DebugInformationFormat,  // intValue0: DebugInfoFormat\n"
"        VulkanBindShiftAll,      // intValue0: kind; intValue1: shift\n"
"        GenerateWholeProgram,    // bool\n"
"        UseUpToDateBinaryModule, // bool, when set, will only load\n"
"                                 // precompiled modules if it is up-to-date with its source.\n"
"        EmbedDownstreamIR,       // bool\n"
"        ForceDXLayout,           // bool\n"
"\n"
"        // Add this new option to the end of the list to avoid breaking ABI as much as possible.\n"
"        // Setting of EmitSpirvDirectly or EmitSpirvViaGLSL will turn into this option internally.\n"
"        EmitSpirvMethod, // enum SlangEmitSpirvMethod\n"
"\n"
"        SaveGLSLModuleBinSource,\n"
"\n"
"        SkipDownstreamLinking, // bool, experimental\n"
"        DumpModule,\n"
"\n"
"        GetModuleInfo,              // Print serialized module version and name\n"
"        GetSupportedModuleVersions, // Print the min and max module versions this compiler supports\n"
"\n"
"        EmitSeparateDebug, // bool\n"
"\n"
"        // Floating point denormal handling modes\n"
"        DenormalModeFp16,\n"
"        DenormalModeFp32,\n"
"        DenormalModeFp64,\n"
"\n"
"        // Bitfield options\n"
"        UseMSVCStyleBitfieldPacking, // bool\n"
"\n"
"        ForceCLayout, // bool\n"
"\n"
"        CountOf,\n"
"    };\n"
"\n"
"    enum class CompilerOptionValueKind\n"
"    {\n"
"        Int,\n"
"        String\n"
"    };\n"
"\n"
"    struct CompilerOptionValue\n"
"    {\n"
"        CompilerOptionValueKind kind = CompilerOptionValueKind::Int;\n"
"        int32_t intValue0 = 0;\n"
"        int32_t intValue1 = 0;\n"
"        const char* stringValue0 = nullptr;\n"
"        const char* stringValue1 = nullptr;\n"
"    };\n"
"\n"
"    struct CompilerOptionEntry\n"
"    {\n"
"        CompilerOptionName name;\n"
"        CompilerOptionValue value;\n"
"    };\n"
"    } // namespace slang\n"
"\n"
"    /** A result code for a Slang API operation.\n"
"\n"
"    This type is generally compatible with the Windows API `HRESULT` type. In particular, negative\n"
"    values indicate failure results, while zero or positive results indicate success.\n"
"\n"
"    In general, Slang APIs always return a zero result on success, unless documented otherwise.\n"
"    Strictly speaking a negative value indicates an error, a positive (or 0) value indicates\n"
"    success. This can be tested for with the macros SLANG_SUCCEEDED(x) or SLANG_FAILED(x).\n"
"\n"
"    It can represent if the call was successful or not. It can also specify in an extensible manner\n"
"    what facility produced the result (as the integral 'facility') as well as what caused it (as an\n"
"    integral 'code'). Under the covers SlangResult is represented as a int32_t.\n"
"\n"
"    SlangResult is designed to be compatible with COM HRESULT.\n"
"\n"
"    It's layout in bits is as follows\n"
"\n"
"    Severity | Facility | Code\n"
"    ---------|----------|-----\n"
"    31       |    30-16 | 15-0\n"
"\n"
;
sb << 
"    Severity - 1 fail, 0 is success - as SlangResult is signed 32 bits, means negative number\n"
"    indicates failure. Facility is where the error originated from. Code is the code specific to the\n"
"    facility.\n"
"\n"
"    Result codes have the following styles,\n"
"    1) SLANG_name\n"
"    2) SLANG_s_f_name\n"
"    3) SLANG_s_name\n"
"\n"
"    where s is S for success, E for error\n"
"    f is the short version of the facility name\n"
"\n"
"    Style 1 is reserved for SLANG_OK and SLANG_FAIL as they are so commonly used.\n"
"\n"
"    It is acceptable to expand 'f' to a longer name to differentiate a name or drop if unique\n"
"    without it. ie for a facility 'DRIVER' it might make sense to have an error of the form\n"
"    SLANG_E_DRIVER_OUT_OF_MEMORY\n"
"    */\n"
"\n"
"    typedef int32_t SlangResult;\n"
"\n"
"    //! Use to test if a result was failure. Never use result != SLANG_OK to test for failure, as\n"
"    //! there may be successful codes != SLANG_OK.\n"
"#define SLANG_FAILED(status) ((status) < 0)\n"
"    //! Use to test if a result succeeded. Never use result == SLANG_OK to test for success, as will\n"
"    //! detect other successful codes as a failure.\n"
"#define SLANG_SUCCEEDED(status) ((status) >= 0)\n"
"\n"
"    //! Get the facility the result is associated with\n"
"#define SLANG_GET_RESULT_FACILITY(r) ((int32_t)(((r) >> 16) & 0x7fff))\n"
"    //! Get the result code for the facility\n"
"#define SLANG_GET_RESULT_CODE(r) ((int32_t)((r) & 0xffff))\n"
"\n"
"#define SLANG_MAKE_ERROR(fac, code) \\\n"
"    ((((int32_t)(fac)) << 16) | ((int32_t)(code)) | int32_t(0x80000000))\n"
"#define SLANG_MAKE_SUCCESS(fac, code) ((((int32_t)(fac)) << 16) | ((int32_t)(code)))\n"
"\n"
"    /*************************** Facilities ************************************/\n"
"\n"
"    //! Facilities compatible with windows COM - only use if known code is compatible\n"
"#define SLANG_FACILITY_WIN_GENERAL 0\n"
"#define SLANG_FACILITY_WIN_INTERFACE 4\n"
"#define SLANG_FACILITY_WIN_API 7\n"
"\n"
"    //! Base facility -> so as to not clash with HRESULT values (values in 0x200 range do not appear\n"
"    //! used)\n"
"#define SLANG_FACILITY_BASE 0x200\n"
"\n"
"    /*! Facilities numbers must be unique across a project to make the resulting result a unique\n"
"    number. It can be useful to have a consistent short name for a facility, as used in the name\n"
"    prefix */\n"
"#define SLANG_FACILITY_CORE SLANG_FACILITY_BASE\n"
"    /* Facility for codes, that are not uniquely defined/protected. Can be used to pass back a\n"
"    specific error without requiring system wide facility uniqueness. Codes should never be part of\n"
"    a public API. */\n"
"#define SLANG_FACILITY_INTERNAL SLANG_FACILITY_BASE + 1\n"
"\n"
"    /// Base for external facilities. Facilities should be unique across modules.\n"
"#define SLANG_FACILITY_EXTERNAL_BASE 0x210\n"
"\n"
"    /* ************************ Win COM compatible Results ******************************/\n"
"    // https://msdn.microsoft.com/en-us/library/windows/desktop/aa378137(v=vs.85).aspx\n"
"\n"
"    //! SLANG_OK indicates success, and is equivalent to\n"
"    //! SLANG_MAKE_SUCCESS(SLANG_FACILITY_WIN_GENERAL, 0)\n"
"#define SLANG_OK 0\n"
"    //! SLANG_FAIL is the generic failure code - meaning a serious error occurred and the call\n"
"    //! couldn't complete\n"
"#define SLANG_FAIL SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, 0x4005)\n"
"\n"
"#define SLANG_MAKE_WIN_GENERAL_ERROR(code) SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_GENERAL, code)\n"
"\n"
"    //! Functionality is not implemented\n"
"#define SLANG_E_NOT_IMPLEMENTED SLANG_MAKE_WIN_GENERAL_ERROR(0x4001)\n"
"    //! Interface not be found\n"
"#define SLANG_E_NO_INTERFACE SLANG_MAKE_WIN_GENERAL_ERROR(0x4002)\n"
"    //! Operation was aborted (did not correctly complete)\n"
"#define SLANG_E_ABORT SLANG_MAKE_WIN_GENERAL_ERROR(0x4004)\n"
"\n"
"    //! Indicates that a handle passed in as parameter to a method is invalid.\n"
"#define SLANG_E_INVALID_HANDLE SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 6)\n"
"    //! Indicates that an argument passed in as parameter to a method is invalid.\n"
"#define SLANG_E_INVALID_ARG SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0x57)\n"
"    //! Operation could not complete - ran out of memory\n"
"#define SLANG_E_OUT_OF_MEMORY SLANG_MAKE_ERROR(SLANG_FACILITY_WIN_API, 0xe)\n"
"\n"
"    /* *************************** other Results **************************************/\n"
"\n"
"#define SLANG_MAKE_CORE_ERROR(code) SLANG_MAKE_ERROR(SLANG_FACILITY_CORE, code)\n"
"\n"
"    // Supplied buffer is too small to be able to complete\n"
"#define SLANG_E_BUFFER_TOO_SMALL SLANG_MAKE_CORE_ERROR(1)\n"
"    //! Used to identify a Result that has yet to be initialized.\n"
"    //! It defaults to failure such that if used incorrectly will fail, as similar in concept to\n"
"    //! using an uninitialized variable.\n"
"#define SLANG_E_UNINITIALIZED SLANG_MAKE_CORE_ERROR(2)\n"
"    //! Returned from an async method meaning the output is invalid (thus an error), but a result\n"
"    //! for the request is pending, and will be returned on a subsequent call with the async handle.\n"
"#define SLANG_E_PENDING SLANG_MAKE_CORE_ERROR(3)\n"
"    //! Indicates a file/resource could not be opened\n"
"#define SLANG_E_CANNOT_OPEN SLANG_MAKE_CORE_ERROR(4)\n"
"    //! Indicates a file/resource could not be found\n"
"#define SLANG_E_NOT_FOUND SLANG_MAKE_CORE_ERROR(5)\n"
"    //! An unhandled internal failure (typically from unhandled exception)\n"
"#define SLANG_E_INTERNAL_FAIL SLANG_MAKE_CORE_ERROR(6)\n"
"    //! Could not complete because some underlying feature (hardware or software) was not available\n"
"#define SLANG_E_NOT_AVAILABLE SLANG_MAKE_CORE_ERROR(7)\n"
"    //! Could not complete because the operation times out.\n"
"#define SLANG_E_TIME_OUT SLANG_MAKE_CORE_ERROR(8)\n"
"\n"
"    /** A \"Universally Unique Identifier\" (UUID)\n"
"\n"
"    The Slang API uses UUIDs to identify interfaces when\n"
"    using `queryInterface`.\n"
"\n"
"    This type is compatible with the `GUID` type defined\n"
"    by the Component Object Model (COM), but Slang is\n"
"    not dependent on COM.\n"
"    */\n"
"    struct SlangUUID\n"
"    {\n"
"        uint32_t data1;\n"
"        uint16_t data2;\n"
"        uint16_t data3;\n"
"        uint8_t data4[8];\n"
"    };\n"
"\n"
"// Place at the start of an interface with the guid.\n"
"// Guid should be specified as SLANG_COM_INTERFACE(0x00000000, 0x0000, 0x0000, { 0xC0, 0x00, 0x00,\n"
"// 0x00, 0x00, 0x00, 0x00, 0x46 }) NOTE: it's the typical guid struct definition, without the\n"
"// surrounding {} It is not necessary to use the multiple parameters (we can wrap in parens), but\n"
"// this is simple.\n"
"#define SLANG_COM_INTERFACE(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \\\n"
"public:                                                              \\\n"
"    SLANG_FORCE_INLINE constexpr static SlangUUID getTypeGuid()      \\\n"
"    {                                                                \\\n"
"        return {a, b, c, d0, d1, d2, d3, d4, d5, d6, d7};            \\\n"
"    }\n"
"\n"
"// Sometimes it's useful to associate a guid with a class to identify it. This macro can used for\n"
"// this, and the guid extracted via the getTypeGuid() function defined in the type\n"
"#define SLANG_CLASS_GUID(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7) \\\n"
"    SLANG_FORCE_INLINE constexpr static SlangUUID getTypeGuid()   \\\n"
"    {                                                             \\\n"
"        return {a, b, c, d0, d1, d2, d3, d4, d5, d6, d7};         \\\n"
"    }\n"
"\n"
"// Helper to fill in pairs of GUIDs and return pointers. This ensures that the\n"
"// type of the GUID passed matches the pointer type, and that it is derived\n"
"// from ISlangUnknown,\n"
"// TODO(c++20): would is_derived_from be more appropriate here for private inheritance of\n"
"// ISlangUnknown?\n"
"//\n"
"// with     : void createFoo(SlangUUID, void**);\n"
"//            Slang::ComPtr<Bar> myBar;\n"
"// call with: createFoo(SLANG_IID_PPV_ARGS(myBar.writeRef()))\n"
"// to call  : createFoo(Bar::getTypeGuid(), (void**)(myBar.writeRef()))\n"
"#define SLANG_IID_PPV_ARGS(ppType)                                                         \\\n"
"    std::decay_t<decltype(**(ppType))>::getTypeGuid(),                                     \\\n"
"        (                                                                                  \\\n"
"            (void)[] {                                                                     \\\n"
"                static_assert(                                                             \\\n"
"                    std::is_base_of_v<ISlangUnknown, std::decay_t<decltype(**(ppType))>>); \\\n"
"            },                                                                             \\\n"
"            reinterpret_cast<void**>(ppType))\n"
"\n"
"\n"
"    /** Base interface for components exchanged through the API.\n"
"\n"
"    This interface definition is compatible with the COM `IUnknown`,\n"
"    and uses the same UUID, but Slang does not require applications\n"
"    to use or initialize COM.\n"
"    */\n"
"    struct ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x00000000,\n"
"            0x0000,\n"
"            0x0000,\n"
"            {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46})\n"
"\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        queryInterface(SlangUUID const& uuid, void** outObject) = 0;\n"
"        virtual SLANG_NO_THROW uint32_t SLANG_MCALL addRef() = 0;\n"
"        virtual SLANG_NO_THROW uint32_t SLANG_MCALL release() = 0;\n"
"\n"
"        /*\n"
"        Inline methods are provided to allow the above operations to be called\n"
"        using their traditional COM names/signatures:\n"
"        */\n"
"        SlangResult QueryInterface(struct _GUID const& uuid, void** outObject)\n"
"        {\n"
"            return queryInterface(*(SlangUUID const*)&uuid, outObject);\n"
"        }\n"
"        uint32_t AddRef() { return addRef(); }\n"
"        uint32_t Release() { return release(); }\n"
"    };\n"
"#define SLANG_UUID_ISlangUnknown ISlangUnknown::getTypeGuid()\n"
"\n"
"\n"
"    /* An interface to provide a mechanism to cast, that doesn't require ref counting\n"
"    and doesn't have to return a pointer to a ISlangUnknown derived class */\n"
"    class ISlangCastable : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x87ede0e1,\n"
"            0x4852,\n"
"            0x44b0,\n"
"            {0x8b, 0xf2, 0xcb, 0x31, 0x87, 0x4d, 0xe2, 0x39});\n"
"\n"
"        /// Can be used to cast to interfaces without reference counting.\n"
"        /// Also provides access to internal implementations, when they provide a guid\n"
"        /// Can simulate a 'generated' interface as long as kept in scope by cast from.\n"
"        virtual SLANG_NO_THROW void* SLANG_MCALL castAs(const SlangUUID& guid) = 0;\n"
"    };\n"
"\n"
"    class ISlangClonable : public ISlangCastable\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x1ec36168,\n"
"            0xe9f4,\n"
"            0x430d,\n"
"            {0xbb, 0x17, 0x4, 0x8a, 0x80, 0x46, 0xb3, 0x1f});\n"
"\n"
"        /// Note the use of guid is for the desired interface/object.\n"
"        /// The object is returned *not* ref counted. Any type that can implements the interface,\n"
"        /// derives from ICastable, and so (not withstanding some other issue) will always return\n"
"        /// an ICastable interface which other interfaces/types are accessible from via castAs\n"
"        SLANG_NO_THROW virtual void* SLANG_MCALL clone(const SlangUUID& guid) = 0;\n"
"    };\n"
"\n"
"    /** A \"blob\" of binary data.\n"
"\n"
"    This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces.\n"
"    */\n"
"    struct ISlangBlob : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x8BA5FB08,\n"
"            0x5195,\n"
"            0x40e2,\n"
"            {0xAC, 0x58, 0x0D, 0x98, 0x9C, 0x3A, 0x01, 0x02})\n"
"\n"
"        virtual SLANG_NO_THROW void const* SLANG_MCALL getBufferPointer() = 0;\n"
"        virtual SLANG_NO_THROW size_t SLANG_MCALL getBufferSize() = 0;\n"
"    };\n"
"#define SLANG_UUID_ISlangBlob ISlangBlob::getTypeGuid()\n"
"\n"
"    /* Can be requested from ISlangCastable cast to indicate the contained chars are null\n"
"     * terminated.\n"
"     */\n"
"    struct SlangTerminatedChars\n"
"    {\n"
"        SLANG_CLASS_GUID(\n"
"            0xbe0db1a8,\n"
"            0x3594,\n"
"            0x4603,\n"
"            {0xa7, 0x8b, 0xc4, 0x86, 0x84, 0x30, 0xdf, 0xbb});\n"
"        operator const char*() const { return chars; }\n"
"        char chars[1];\n"
"    };\n"
"\n"
"    /** A (real or virtual) file system.\n"
"\n"
"    Slang can make use of this interface whenever it would otherwise try to load files\n"
"    from disk, allowing applications to hook and/or override filesystem access from\n"
"    the compiler.\n"
"\n"
"    It is the responsibility of\n"
"    the caller of any method that returns a ISlangBlob to release the blob when it is no\n"
"    longer used (using 'release').\n"
"    */\n"
"\n"
"    struct ISlangFileSystem : public ISlangCastable\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x003A09FC,\n"
"            0x3A4D,\n"
"            0x4BA0,\n"
"            {0xAD, 0x60, 0x1F, 0xD8, 0x63, 0xA9, 0x15, 0xAB})\n"
"\n"
"        /** Load a file from `path` and return a blob of its contents\n"
"        @param path The path to load from, as a null-terminated UTF-8 string.\n"
"        @param outBlob A destination pointer to receive the blob of the file contents.\n"
"        @returns A `SlangResult` to indicate success or failure in loading the file.\n"
"\n"
"        NOTE! This is a *binary* load - the blob should contain the exact same bytes\n"
"        as are found in the backing file.\n"
"\n"
"        If load is successful, the implementation should create a blob to hold\n"
"        the file's content, store it to `outBlob`, and return 0.\n"
"        If the load fails, the implementation should return a failure status\n"
"        (any negative value will do).\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        loadFile(char const* path, ISlangBlob** outBlob) = 0;\n"
"    };\n"
"#define SLANG_UUID_ISlangFileSystem ISlangFileSystem::getTypeGuid()\n"
"\n"
"\n"
"    typedef void (*SlangFuncPtr)(void);\n"
"\n"
"    /**\n"
"    (DEPRECATED) ISlangSharedLibrary\n"
"    */\n"
"    struct ISlangSharedLibrary_Dep1 : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x9c9d5bc5,\n"
"            0xeb61,\n"
"            0x496f,\n"
"            {0x80, 0xd7, 0xd1, 0x47, 0xc4, 0xa2, 0x37, 0x30})\n"
"\n"
"        virtual SLANG_NO_THROW void* SLANG_MCALL findSymbolAddressByName(char const* name) = 0;\n"
"    };\n"
"#define SLANG_UUID_ISlangSharedLibrary_Dep1 ISlangSharedLibrary_Dep1::getTypeGuid()\n"
"\n"
"    /** An interface that can be used to encapsulate access to a shared library. An implementation\n"
"    does not have to implement the library as a shared library\n"
"    */\n"
"    struct ISlangSharedLibrary : public ISlangCastable\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x70dbc7c4,\n"
"            0xdc3b,\n"
"            0x4a07,\n"
"            {0xae, 0x7e, 0x75, 0x2a, 0xf6, 0xa8, 0x15, 0x55})\n"
"\n"
"        /** Get a function by name. If the library is unloaded will only return nullptr.\n"
"        @param name The name of the function\n"
"        @return The function pointer related to the name or nullptr if not found\n"
"        */\n"
"        SLANG_FORCE_INLINE SlangFuncPtr findFuncByName(char const* name)\n"
"        {\n"
"            return (SlangFuncPtr)findSymbolAddressByName(name);\n"
"        }\n"
"\n"
"        /** Get a symbol by name. If the library is unloaded will only return nullptr.\n"
"        @param name The name of the symbol\n"
"        @return The pointer related to the name or nullptr if not found\n"
"        */\n"
"        virtual SLANG_NO_THROW void* SLANG_MCALL findSymbolAddressByName(char const* name) = 0;\n"
"    };\n"
"#define SLANG_UUID_ISlangSharedLibrary ISlangSharedLibrary::getTypeGuid()\n"
"\n"
"    struct ISlangSharedLibraryLoader : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x6264ab2b,\n"
"            0xa3e8,\n"
"            0x4a06,\n"
"            {0x97, 0xf1, 0x49, 0xbc, 0x2d, 0x2a, 0xb1, 0x4d})\n"
"\n"
"        /** Load a shared library. In typical usage the library name should *not* contain any\n"
"        platform specific elements. For example on windows a dll name should *not* be passed with a\n"
"        '.dll' extension, and similarly on linux a shared library should *not* be passed with the\n"
"        'lib' prefix and '.so' extension\n"
"        @path path The unadorned filename and/or path for the shared library\n"
"        @ param sharedLibraryOut Holds the shared library if successfully loaded */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        loadSharedLibrary(const char* path, ISlangSharedLibrary** sharedLibraryOut) = 0;\n"
"    };\n"
"#define SLANG_UUID_ISlangSharedLibraryLoader ISlangSharedLibraryLoader::getTypeGuid()\n"
"\n"
"    /* Type that identifies how a path should be interpreted */\n"
"    typedef unsigned int SlangPathTypeIntegral;\n"
"    enum SlangPathType : SlangPathTypeIntegral\n"
"    {\n"
"        SLANG_PATH_TYPE_DIRECTORY, /**< Path specified specifies a directory. */\n"
"        SLANG_PATH_TYPE_FILE,      /**< Path specified is to a file. */\n"
"    };\n"
"\n"
"    /* Callback to enumerate the contents of of a directory in a ISlangFileSystemExt.\n"
"    The name is the name of a file system object (directory/file) in the specified path (ie it is\n"
"    without a path) */\n"
"    typedef void (\n"
"        *FileSystemContentsCallBack)(SlangPathType pathType, const char* name, void* userData);\n"
"\n"
"    /* Determines how paths map to files on the OS file system */\n"
"    enum class OSPathKind : uint8_t\n"
"    {\n"
"        None,            ///< Paths do not map to the file system\n"
;
sb << 
"        Direct,          ///< Paths map directly to the file system\n"
"        OperatingSystem, ///< Only paths gained via PathKind::OperatingSystem map to the operating\n"
"                         ///< system file system\n"
"    };\n"
"\n"
"    /* Used to determine what kind of path is required from an input path */\n"
"    enum class PathKind\n"
"    {\n"
"        /// Given a path, returns a simplified version of that path.\n"
"        /// This typically means removing '..' and/or '.' from the path.\n"
"        /// A simplified path must point to the same object as the original.\n"
"        Simplified,\n"
"\n"
"        /// Given a path, returns a 'canonical path' to the item.\n"
"        /// This may be the operating system 'canonical path' that is the unique path to the item.\n"
"        ///\n"
"        /// If the item exists the returned canonical path should always be usable to access the\n"
"        /// item.\n"
"        ///\n"
"        /// If the item the path specifies doesn't exist, the canonical path may not be returnable\n"
"        /// or be a path simplification.\n"
"        /// Not all file systems support canonical paths.\n"
"        Canonical,\n"
"\n"
"        /// Given a path returns a path such that it is suitable to be displayed to the user.\n"
"        ///\n"
"        /// For example if the file system is a zip file - it might include the path to the zip\n"
"        /// container as well as the path to the specific file.\n"
"        ///\n"
"        /// NOTE! The display path won't necessarily work on the file system to access the item\n"
"        Display,\n"
"\n"
"        /// Get the path to the item on the *operating system* file system, if available.\n"
"        OperatingSystem,\n"
"\n"
"        CountOf,\n"
"    };\n"
"\n"
"    /** An extended file system abstraction.\n"
"\n"
"    Implementing and using this interface over ISlangFileSystem gives much more control over how\n"
"    paths are managed, as well as how it is determined if two files 'are the same'.\n"
"\n"
"    All paths as input char*, or output as ISlangBlobs are always encoded as UTF-8 strings.\n"
"    Blobs that contain strings are always zero terminated.\n"
"    */\n"
"    struct ISlangFileSystemExt : public ISlangFileSystem\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x5fb632d2,\n"
"            0x979d,\n"
"            0x4481,\n"
"            {0x9f, 0xee, 0x66, 0x3c, 0x3f, 0x14, 0x49, 0xe1})\n"
"\n"
"        /** Get a uniqueIdentity which uniquely identifies an object of the file system.\n"
"\n"
"        Given a path, returns a 'uniqueIdentity' which ideally is the same value for the same object\n"
"        on the file system.\n"
"\n"
"        The uniqueIdentity is used to compare if two paths are the same - which amongst other things\n"
"        allows Slang to cache source contents internally. It is also used for #pragma once\n"
"        functionality.\n"
"\n"
"        A *requirement* is for any implementation is that two paths can only return the same\n"
"        uniqueIdentity if the contents of the two files are *identical*. If an implementation breaks\n"
"        this constraint it can produce incorrect compilation. If an implementation cannot *strictly*\n"
"        identify *the same* files, this will only have an effect on #pragma once behavior.\n"
"\n"
"        The string for the uniqueIdentity is held zero terminated in the ISlangBlob of\n"
"        outUniqueIdentity.\n"
"\n"
"        Note that there are many ways a uniqueIdentity may be generated for a file. For example it\n"
"        could be the 'canonical path' - assuming it is available and unambiguous for a file system.\n"
"        Another possible mechanism could be to store the filename combined with the file date time\n"
"        to uniquely identify it.\n"
"\n"
"        The client must ensure the blob be released when no longer used, otherwise memory will leak.\n"
"\n"
"        NOTE! Ideally this method would be called 'getPathUniqueIdentity' but for historical reasons\n"
"        and backward compatibility it's name remains with 'File' even though an implementation\n"
"        should be made to work with directories too.\n"
"\n"
"        @param path\n"
"        @param outUniqueIdentity\n"
"        @returns A `SlangResult` to indicate success or failure getting the uniqueIdentity.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        getFileUniqueIdentity(const char* path, ISlangBlob** outUniqueIdentity) = 0;\n"
"\n"
"        /** Calculate a path combining the 'fromPath' with 'path'\n"
"\n"
"        The client must ensure the blob be released when no longer used, otherwise memory will leak.\n"
"\n"
"        @param fromPathType How to interpret the from path - as a file or a directory.\n"
"        @param fromPath The from path.\n"
"        @param path Path to be determined relative to the fromPath\n"
"        @param pathOut Holds the string which is the relative path. The string is held in the blob\n"
"        zero terminated.\n"
"        @returns A `SlangResult` to indicate success or failure in loading the file.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL calcCombinedPath(\n"
"            SlangPathType fromPathType,\n"
"            const char* fromPath,\n"
"            const char* path,\n"
"            ISlangBlob** pathOut) = 0;\n"
"\n"
"        /** Gets the type of path that path is on the file system.\n"
"        @param path\n"
"        @param pathTypeOut\n"
"        @returns SLANG_OK if located and type is known, else an error. SLANG_E_NOT_FOUND if not\n"
"        found.\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        getPathType(const char* path, SlangPathType* pathTypeOut) = 0;\n"
"\n"
"        /** Get a path based on the kind.\n"
"\n"
"        @param kind The kind of path wanted\n"
"        @param path The input path\n"
"        @param outPath The output path held in a blob\n"
"        @returns SLANG_OK if successfully simplified the path (SLANG_E_NOT_IMPLEMENTED if not\n"
"        implemented, or some other error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        getPath(PathKind kind, const char* path, ISlangBlob** outPath) = 0;\n"
"\n"
"        /** Clears any cached information */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL clearCache() = 0;\n"
"\n"
"        /** Enumerate the contents of the path\n"
"\n"
"        Note that for normal Slang operation it isn't necessary to enumerate contents this can\n"
"        return SLANG_E_NOT_IMPLEMENTED.\n"
"\n"
"        @param The path to enumerate\n"
"        @param callback This callback is called for each entry in the path.\n"
"        @param userData This is passed to the callback\n"
"        @returns SLANG_OK if successful\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL enumeratePathContents(\n"
"            const char* path,\n"
"            FileSystemContentsCallBack callback,\n"
"            void* userData) = 0;\n"
"\n"
"        /** Returns how paths map to the OS file system\n"
"\n"
"        @returns OSPathKind that describes how paths map to the Operating System file system\n"
"        */\n"
"        virtual SLANG_NO_THROW OSPathKind SLANG_MCALL getOSPathKind() = 0;\n"
"    };\n"
"\n"
"#define SLANG_UUID_ISlangFileSystemExt ISlangFileSystemExt::getTypeGuid()\n"
"\n"
"    struct ISlangMutableFileSystem : public ISlangFileSystemExt\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0xa058675c,\n"
"            0x1d65,\n"
"            0x452a,\n"
"            {0x84, 0x58, 0xcc, 0xde, 0xd1, 0x42, 0x71, 0x5})\n"
"\n"
"        /** Write data to the specified path.\n"
"\n"
"        @param path The path for data to be saved to\n"
"        @param data The data to be saved\n"
"        @param size The size of the data in bytes\n"
"        @returns SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other\n"
"        error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        saveFile(const char* path, const void* data, size_t size) = 0;\n"
"\n"
"        /** Write data in the form of a blob to the specified path.\n"
"\n"
"        Depending on the implementation writing a blob might be faster/use less memory. It is\n"
"        assumed the blob is *immutable* and that an implementation can reference count it.\n"
"\n"
"        It is not guaranteed loading the same file will return the *same* blob - just a blob with\n"
"        same contents.\n"
"\n"
"        @param path The path for data to be saved to\n"
"        @param dataBlob The data to be saved\n"
"        @returns SLANG_OK if successful (SLANG_E_NOT_IMPLEMENTED if not implemented, or some other\n"
"        error code)\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        saveFileBlob(const char* path, ISlangBlob* dataBlob) = 0;\n"
"\n"
"        /** Remove the entry in the path (directory of file). Will only delete an empty directory,\n"
"        if not empty will return an error.\n"
"\n"
"        @param path The path to remove\n"
"        @returns SLANG_OK if successful\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL remove(const char* path) = 0;\n"
"\n"
"        /** Create a directory.\n"
"\n"
"        The path to the directory must exist\n"
"\n"
"        @param path To the directory to create. The parent path *must* exist otherwise will return\n"
"        an error.\n"
"        @returns SLANG_OK if successful\n"
"        */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL createDirectory(const char* path) = 0;\n"
"    };\n"
"\n"
"#define SLANG_UUID_ISlangMutableFileSystem ISlangMutableFileSystem::getTypeGuid()\n"
"\n"
"    /* Identifies different types of writer target*/\n"
"    typedef unsigned int SlangWriterChannelIntegral;\n"
"    enum SlangWriterChannel : SlangWriterChannelIntegral\n"
"    {\n"
"        SLANG_WRITER_CHANNEL_DIAGNOSTIC,\n"
"        SLANG_WRITER_CHANNEL_STD_OUTPUT,\n"
"        SLANG_WRITER_CHANNEL_STD_ERROR,\n"
"        SLANG_WRITER_CHANNEL_COUNT_OF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangWriterModeIntegral;\n"
"    enum SlangWriterMode : SlangWriterModeIntegral\n"
"    {\n"
"        SLANG_WRITER_MODE_TEXT,\n"
"        SLANG_WRITER_MODE_BINARY,\n"
"    };\n"
"\n"
"    /** A stream typically of text, used for outputting diagnostic as well as other information.\n"
"     */\n"
"    struct ISlangWriter : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0xec457f0e,\n"
"            0x9add,\n"
"            0x4e6b,\n"
"            {0x85, 0x1c, 0xd7, 0xfa, 0x71, 0x6d, 0x15, 0xfd})\n"
"\n"
"        /** Begin an append buffer.\n"
"        NOTE! Only one append buffer can be active at any time.\n"
"        @param maxNumChars The maximum of chars that will be appended\n"
"        @returns The start of the buffer for appending to. */\n"
"        virtual SLANG_NO_THROW char* SLANG_MCALL beginAppendBuffer(size_t maxNumChars) = 0;\n"
"        /** Ends the append buffer, and is equivalent to a write of the append buffer.\n"
"        NOTE! That an endAppendBuffer is not necessary if there are no characters to write.\n"
"        @param buffer is the start of the data to append and must be identical to last value\n"
"        returned from beginAppendBuffer\n"
"        @param numChars must be a value less than or equal to what was returned from last call to\n"
"        beginAppendBuffer\n"
"        @returns Result, will be SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        endAppendBuffer(char* buffer, size_t numChars) = 0;\n"
"        /** Write text to the writer\n"
"        @param chars The characters to write out\n"
"        @param numChars The amount of characters\n"
"        @returns SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"        write(const char* chars, size_t numChars) = 0;\n"
"        /** Flushes any content to the output */\n"
"        virtual SLANG_NO_THROW void SLANG_MCALL flush() = 0;\n"
"        /** Determines if the writer stream is to the console, and can be used to alter the output\n"
"        @returns Returns true if is a console writer */\n"
"        virtual SLANG_NO_THROW SlangBool SLANG_MCALL isConsole() = 0;\n"
"        /** Set the mode for the writer to use\n"
"        @param mode The mode to use\n"
"        @returns SLANG_OK on success */\n"
"        virtual SLANG_NO_THROW SlangResult SLANG_MCALL setMode(SlangWriterMode mode) = 0;\n"
"    };\n"
"\n"
"#define SLANG_UUID_ISlangWriter ISlangWriter::getTypeGuid()\n"
"\n"
"    struct ISlangProfiler : public ISlangUnknown\n"
"    {\n"
"        SLANG_COM_INTERFACE(\n"
"            0x197772c7,\n"
"            0x0155,\n"
"            0x4b91,\n"
"            {0x84, 0xe8, 0x66, 0x68, 0xba, 0xff, 0x06, 0x19})\n"
"        virtual SLANG_NO_THROW size_t SLANG_MCALL getEntryCount() = 0;\n"
"        virtual SLANG_NO_THROW const char* SLANG_MCALL getEntryName(uint32_t index) = 0;\n"
"        virtual SLANG_NO_THROW long SLANG_MCALL getEntryTimeMS(uint32_t index) = 0;\n"
"        virtual SLANG_NO_THROW uint32_t SLANG_MCALL getEntryInvocationTimes(uint32_t index) = 0;\n"
"    };\n"
"#define SLANG_UUID_ISlangProfiler ISlangProfiler::getTypeGuid()\n"
"\n"
"    namespace slang\n"
"    {\n"
"    struct IGlobalSession;\n"
"    struct ICompileRequest;\n"
"\n"
"    } // namespace slang\n"
"\n"
"    /*!\n"
"    @brief An instance of the Slang library.\n"
"    */\n"
"    typedef slang::IGlobalSession SlangSession;\n"
"\n"
"\n"
"    typedef struct SlangProgramLayout SlangProgramLayout;\n"
"\n"
"    /*!\n"
"    @brief A request for one or more compilation actions to be performed.\n"
"    */\n"
"    typedef struct slang::ICompileRequest SlangCompileRequest;\n"
"\n"
"\n"
"    /*!\n"
"@brief Callback type used for diagnostic output.\n"
"*/\n"
"    typedef void (*SlangDiagnosticCallback)(char const* message, void* userData);\n"
"\n"
"    /*!\n"
"    @brief Get the build version 'tag' string. The string is the same as\n"
"    produced via `git describe --tags --match v*` for the project. If such a\n"
"    version could not be determined at build time then the contents will be\n"
"    0.0.0-unknown. Any string can be set by passing\n"
"    -DSLANG_VERSION_FULL=whatever during the cmake invocation.\n"
"\n"
"    This function will return exactly the same result as the method\n"
"    getBuildTagString on IGlobalSession.\n"
"\n"
"    An advantage of using this function over the method is that doing so does\n"
"    not require the creation of a session, which can be a fairly costly\n"
"    operation.\n"
"\n"
"    @return The build tag string\n"
"    */\n"
"    SLANG_API const char* spGetBuildTagString();\n"
"\n"
"    /*\n"
"    Forward declarations of types used in the reflection interface;\n"
"    */\n"
"\n"
"    typedef struct SlangProgramLayout SlangProgramLayout;\n"
"    typedef struct SlangEntryPoint SlangEntryPoint;\n"
"    typedef struct SlangEntryPointLayout SlangEntryPointLayout;\n"
"\n"
"    typedef struct SlangReflectionDecl SlangReflectionDecl;\n"
"    typedef struct SlangReflectionModifier SlangReflectionModifier;\n"
"    typedef struct SlangReflectionType SlangReflectionType;\n"
"    typedef struct SlangReflectionTypeLayout SlangReflectionTypeLayout;\n"
"    typedef struct SlangReflectionVariable SlangReflectionVariable;\n"
"    typedef struct SlangReflectionVariableLayout SlangReflectionVariableLayout;\n"
"    typedef struct SlangReflectionTypeParameter SlangReflectionTypeParameter;\n"
"    typedef struct SlangReflectionUserAttribute SlangReflectionUserAttribute;\n"
"    typedef SlangReflectionUserAttribute SlangReflectionAttribute;\n"
"    typedef struct SlangReflectionFunction SlangReflectionFunction;\n"
"    typedef struct SlangReflectionGeneric SlangReflectionGeneric;\n"
"\n"
"    union SlangReflectionGenericArg\n"
"    {\n"
"        SlangReflectionType* typeVal;\n"
"        int64_t intVal;\n"
"        bool boolVal;\n"
"    };\n"
"\n"
"    enum SlangReflectionGenericArgType\n"
"    {\n"
"        SLANG_GENERIC_ARG_TYPE = 0,\n"
"        SLANG_GENERIC_ARG_INT = 1,\n"
"        SLANG_GENERIC_ARG_BOOL = 2\n"
"    };\n"
"\n"
"    /*\n"
"    Type aliases to maintain backward compatibility.\n"
"    */\n"
"    typedef SlangProgramLayout SlangReflection;\n"
"    typedef SlangEntryPointLayout SlangReflectionEntryPoint;\n"
"\n"
"    // type reflection\n"
"\n"
"    typedef unsigned int SlangTypeKindIntegral;\n"
"    enum SlangTypeKind : SlangTypeKindIntegral\n"
"    {\n"
"        SLANG_TYPE_KIND_NONE,\n"
"        SLANG_TYPE_KIND_STRUCT,\n"
"        SLANG_TYPE_KIND_ARRAY,\n"
"        SLANG_TYPE_KIND_MATRIX,\n"
"        SLANG_TYPE_KIND_VECTOR,\n"
"        SLANG_TYPE_KIND_SCALAR,\n"
"        SLANG_TYPE_KIND_CONSTANT_BUFFER,\n"
"        SLANG_TYPE_KIND_RESOURCE,\n"
"        SLANG_TYPE_KIND_SAMPLER_STATE,\n"
"        SLANG_TYPE_KIND_TEXTURE_BUFFER,\n"
"        SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER,\n"
"        SLANG_TYPE_KIND_PARAMETER_BLOCK,\n"
"        SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER,\n"
"        SLANG_TYPE_KIND_INTERFACE,\n"
"        SLANG_TYPE_KIND_OUTPUT_STREAM,\n"
"        SLANG_TYPE_KIND_MESH_OUTPUT,\n"
"        SLANG_TYPE_KIND_SPECIALIZED,\n"
"        SLANG_TYPE_KIND_FEEDBACK,\n"
"        SLANG_TYPE_KIND_POINTER,\n"
"        SLANG_TYPE_KIND_DYNAMIC_RESOURCE,\n"
"        SLANG_TYPE_KIND_COUNT,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangScalarTypeIntegral;\n"
"    enum SlangScalarType : SlangScalarTypeIntegral\n"
"    {\n"
"        SLANG_SCALAR_TYPE_NONE,\n"
"        SLANG_SCALAR_TYPE_VOID,\n"
"        SLANG_SCALAR_TYPE_BOOL,\n"
"        SLANG_SCALAR_TYPE_INT32,\n"
"        SLANG_SCALAR_TYPE_UINT32,\n"
"        SLANG_SCALAR_TYPE_INT64,\n"
"        SLANG_SCALAR_TYPE_UINT64,\n"
"        SLANG_SCALAR_TYPE_FLOAT16,\n"
"        SLANG_SCALAR_TYPE_FLOAT32,\n"
"        SLANG_SCALAR_TYPE_FLOAT64,\n"
"        SLANG_SCALAR_TYPE_INT8,\n"
"        SLANG_SCALAR_TYPE_UINT8,\n"
"        SLANG_SCALAR_TYPE_INT16,\n"
"        SLANG_SCALAR_TYPE_UINT16,\n"
"        SLANG_SCALAR_TYPE_INTPTR,\n"
"        SLANG_SCALAR_TYPE_UINTPTR\n"
"    };\n"
"\n"
"    // abstract decl reflection\n"
"    typedef unsigned int SlangDeclKindIntegral;\n"
"    enum SlangDeclKind : SlangDeclKindIntegral\n"
"    {\n"
"        SLANG_DECL_KIND_UNSUPPORTED_FOR_REFLECTION,\n"
"        SLANG_DECL_KIND_STRUCT,\n"
;
sb << 
"        SLANG_DECL_KIND_FUNC,\n"
"        SLANG_DECL_KIND_MODULE,\n"
"        SLANG_DECL_KIND_GENERIC,\n"
"        SLANG_DECL_KIND_VARIABLE,\n"
"        SLANG_DECL_KIND_NAMESPACE\n"
"    };\n"
"\n"
"#ifndef SLANG_RESOURCE_SHAPE\n"
"    #define SLANG_RESOURCE_SHAPE\n"
"    typedef unsigned int SlangResourceShapeIntegral;\n"
"    enum SlangResourceShape : SlangResourceShapeIntegral\n"
"    {\n"
"        SLANG_RESOURCE_BASE_SHAPE_MASK = 0x0F,\n"
"\n"
"        SLANG_RESOURCE_NONE = 0x00,\n"
"\n"
"        SLANG_TEXTURE_1D = 0x01,\n"
"        SLANG_TEXTURE_2D = 0x02,\n"
"        SLANG_TEXTURE_3D = 0x03,\n"
"        SLANG_TEXTURE_CUBE = 0x04,\n"
"        SLANG_TEXTURE_BUFFER = 0x05,\n"
"\n"
"        SLANG_STRUCTURED_BUFFER = 0x06,\n"
"        SLANG_BYTE_ADDRESS_BUFFER = 0x07,\n"
"        SLANG_RESOURCE_UNKNOWN = 0x08,\n"
"        SLANG_ACCELERATION_STRUCTURE = 0x09,\n"
"        SLANG_TEXTURE_SUBPASS = 0x0A,\n"
"\n"
"        SLANG_RESOURCE_EXT_SHAPE_MASK = 0x1F0,\n"
"\n"
"        SLANG_TEXTURE_FEEDBACK_FLAG = 0x10,\n"
"        SLANG_TEXTURE_SHADOW_FLAG = 0x20,\n"
"        SLANG_TEXTURE_ARRAY_FLAG = 0x40,\n"
"        SLANG_TEXTURE_MULTISAMPLE_FLAG = 0x80,\n"
"        SLANG_TEXTURE_COMBINED_FLAG = 0x100,\n"
"\n"
"        SLANG_TEXTURE_1D_ARRAY = SLANG_TEXTURE_1D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"        SLANG_TEXTURE_2D_ARRAY = SLANG_TEXTURE_2D | SLANG_TEXTURE_ARRAY_FLAG,\n"
"        SLANG_TEXTURE_CUBE_ARRAY = SLANG_TEXTURE_CUBE | SLANG_TEXTURE_ARRAY_FLAG,\n"
"\n"
"        SLANG_TEXTURE_2D_MULTISAMPLE = SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"        SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY =\n"
"            SLANG_TEXTURE_2D | SLANG_TEXTURE_MULTISAMPLE_FLAG | SLANG_TEXTURE_ARRAY_FLAG,\n"
"        SLANG_TEXTURE_SUBPASS_MULTISAMPLE = SLANG_TEXTURE_SUBPASS | SLANG_TEXTURE_MULTISAMPLE_FLAG,\n"
"    };\n"
"#endif\n"
"    typedef unsigned int SlangResourceAccessIntegral;\n"
"    enum SlangResourceAccess : SlangResourceAccessIntegral\n"
"    {\n"
"        SLANG_RESOURCE_ACCESS_NONE,\n"
"        SLANG_RESOURCE_ACCESS_READ,\n"
"        SLANG_RESOURCE_ACCESS_READ_WRITE,\n"
"        SLANG_RESOURCE_ACCESS_RASTER_ORDERED,\n"
"        SLANG_RESOURCE_ACCESS_APPEND,\n"
"        SLANG_RESOURCE_ACCESS_CONSUME,\n"
"        SLANG_RESOURCE_ACCESS_WRITE,\n"
"        SLANG_RESOURCE_ACCESS_FEEDBACK,\n"
"        SLANG_RESOURCE_ACCESS_UNKNOWN = 0x7FFFFFFF,\n"
"    };\n"
"\n"
"    typedef unsigned int SlangParameterCategoryIntegral;\n"
"    enum SlangParameterCategory : SlangParameterCategoryIntegral\n"
"    {\n"
"        SLANG_PARAMETER_CATEGORY_NONE,\n"
"        SLANG_PARAMETER_CATEGORY_MIXED,\n"
"        SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"        SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE,\n"
"        SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS,\n"
"        SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"        SLANG_PARAMETER_CATEGORY_SAMPLER_STATE,\n"
"        SLANG_PARAMETER_CATEGORY_UNIFORM,\n"
"        SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT,\n"
"        SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT,\n"
"        SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER,\n"
"\n"
"        // HLSL register `space`, Vulkan GLSL `set`\n"
"        SLANG_PARAMETER_CATEGORY_REGISTER_SPACE,\n"
"\n"
"        // TODO: Ellie, Both APIs treat mesh outputs as more or less varying output,\n"
"        // Does it deserve to be represented here??\n"
"\n"
"        // A parameter whose type is to be specialized by a global generic type argument\n"
"        SLANG_PARAMETER_CATEGORY_GENERIC,\n"
"\n"
"        SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD,\n"
"        SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES,\n"
"        SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD,\n"
"        SLANG_PARAMETER_CATEGORY_SHADER_RECORD,\n"
"\n"
"        // An existential type parameter represents a \"hole\" that\n"
"        // needs to be filled with a concrete type to enable\n"
"        // generation of specialized code.\n"
"        //\n"
"        // Consider this example:\n"
"        //\n"
"        //      struct MyParams\n"
"        //      {\n"
"        //          IMaterial material;\n"
"        //          ILight lights[3];\n"
"        //      };\n"
"        //\n"
"        // This `MyParams` type introduces two existential type parameters:\n"
"        // one for `material` and one for `lights`. Even though `lights`\n"
"        // is an array, it only introduces one type parameter, because\n"
"        // we need to have a *single* concrete type for all the array\n"
"        // elements to be able to generate specialized code.\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM,\n"
"\n"
"        // An existential object parameter represents a value\n"
"        // that needs to be passed in to provide data for some\n"
"        // interface-type shader parameter.\n"
"        //\n"
"        // Consider this example:\n"
"        //\n"
"        //      struct MyParams\n"
"        //      {\n"
"        //          IMaterial material;\n"
"        //          ILight lights[3];\n"
"        //      };\n"
"        //\n"
"        // This `MyParams` type introduces four existential object parameters:\n"
"        // one for `material` and three for `lights` (one for each array\n"
"        // element). This is consistent with the number of interface-type\n"
"        // \"objects\" that are being passed through to the shader.\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM,\n"
"\n"
"        // The register space offset for the sub-elements that occupies register spaces.\n"
"        SLANG_PARAMETER_CATEGORY_SUB_ELEMENT_REGISTER_SPACE,\n"
"\n"
"        // The input_attachment_index subpass occupancy tracker\n"
"        SLANG_PARAMETER_CATEGORY_SUBPASS,\n"
"\n"
"        // Metal tier-1 argument buffer element [[id]].\n"
"        SLANG_PARAMETER_CATEGORY_METAL_ARGUMENT_BUFFER_ELEMENT,\n"
"\n"
"        // Metal [[attribute]] inputs.\n"
"        SLANG_PARAMETER_CATEGORY_METAL_ATTRIBUTE,\n"
"\n"
"        // Metal [[payload]] inputs\n"
"        SLANG_PARAMETER_CATEGORY_METAL_PAYLOAD,\n"
"\n"
"        //\n"
"        SLANG_PARAMETER_CATEGORY_COUNT,\n"
"\n"
"        // Aliases for Metal-specific categories.\n"
"        SLANG_PARAMETER_CATEGORY_METAL_BUFFER = SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"        SLANG_PARAMETER_CATEGORY_METAL_TEXTURE = SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE,\n"
"        SLANG_PARAMETER_CATEGORY_METAL_SAMPLER = SLANG_PARAMETER_CATEGORY_SAMPLER_STATE,\n"
"\n"
"        // DEPRECATED:\n"
"        SLANG_PARAMETER_CATEGORY_VERTEX_INPUT = SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"        SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT = SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"        SLANG_PARAMETER_CATEGORY_COUNT_V1 = SLANG_PARAMETER_CATEGORY_SUBPASS,\n"
"    };\n"
"\n"
"    /** Types of API-managed bindings that a parameter might use.\n"
"\n"
"    `SlangBindingType` represents the distinct types of binding ranges that might be\n"
"    understood by an underlying graphics API or cross-API abstraction layer.\n"
"    Several of the enumeration cases here correspond to cases of `VkDescriptorType`\n"
"    defined by the Vulkan API. Note however that the values of this enumeration\n"
"    are not the same as those of any particular API.\n"
"\n"
"    The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`\n"
"    because `SlangParameterCategory` differentiates the types of parameters for\n"
"    the purposes of layout, where the layout rules of some targets will treat\n"
"    parameters of different types as occupying the same binding space for layout\n"
"    (e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of\n"
"    `binding` indices, and are not allowed to overlap), while those same types\n"
"    map to different types of bindings in the API (e.g., both textures and samplers\n"
"    use different `VkDescriptorType` values).\n"
"\n"
"    When you want to answer \"what register/binding did this parameter use?\" you\n"
"    should use `SlangParameterCategory`.\n"
"\n"
"    When you want to answer \"what type of descriptor range should this parameter use?\"\n"
"    you should use `SlangBindingType`.\n"
"    */\n"
"    typedef SlangUInt32 SlangBindingTypeIntegral;\n"
"    enum SlangBindingType : SlangBindingTypeIntegral\n"
"    {\n"
"        SLANG_BINDING_TYPE_UNKNOWN = 0,\n"
"\n"
"        SLANG_BINDING_TYPE_SAMPLER,\n"
"        SLANG_BINDING_TYPE_TEXTURE,\n"
"        SLANG_BINDING_TYPE_CONSTANT_BUFFER,\n"
"        SLANG_BINDING_TYPE_PARAMETER_BLOCK,\n"
"        SLANG_BINDING_TYPE_TYPED_BUFFER,\n"
"        SLANG_BINDING_TYPE_RAW_BUFFER,\n"
"        SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER,\n"
"        SLANG_BINDING_TYPE_INPUT_RENDER_TARGET,\n"
"        SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA,\n"
"        SLANG_BINDING_TYPE_RAY_TRACING_ACCELERATION_STRUCTURE,\n"
"\n"
"        SLANG_BINDING_TYPE_VARYING_INPUT,\n"
"        SLANG_BINDING_TYPE_VARYING_OUTPUT,\n"
"\n"
"        SLANG_BINDING_TYPE_EXISTENTIAL_VALUE,\n"
"        SLANG_BINDING_TYPE_PUSH_CONSTANT,\n"
"\n"
"        SLANG_BINDING_TYPE_MUTABLE_FLAG = 0x100,\n"
"\n"
"        SLANG_BINDING_TYPE_MUTABLE_TETURE =\n"
"            SLANG_BINDING_TYPE_TEXTURE | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"        SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER =\n"
"            SLANG_BINDING_TYPE_TYPED_BUFFER | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"        SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER =\n"
"            SLANG_BINDING_TYPE_RAW_BUFFER | SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"\n"
"        SLANG_BINDING_TYPE_BASE_MASK = 0x00FF,\n"
"        SLANG_BINDING_TYPE_EXT_MASK = 0xFF00,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangLayoutRulesIntegral;\n"
"    enum SlangLayoutRules : SlangLayoutRulesIntegral\n"
"    {\n"
"        SLANG_LAYOUT_RULES_DEFAULT,\n"
"        SLANG_LAYOUT_RULES_METAL_ARGUMENT_BUFFER_TIER_2,\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangModifierIDIntegral;\n"
"    enum SlangModifierID : SlangModifierIDIntegral\n"
"    {\n"
"        SLANG_MODIFIER_SHARED,\n"
"        SLANG_MODIFIER_NO_DIFF,\n"
"        SLANG_MODIFIER_STATIC,\n"
"        SLANG_MODIFIER_CONST,\n"
"        SLANG_MODIFIER_EXPORT,\n"
"        SLANG_MODIFIER_EXTERN,\n"
"        SLANG_MODIFIER_DIFFERENTIABLE,\n"
"        SLANG_MODIFIER_MUTATING,\n"
"        SLANG_MODIFIER_IN,\n"
"        SLANG_MODIFIER_OUT,\n"
"        SLANG_MODIFIER_INOUT\n"
"    };\n"
"\n"
"    typedef SlangUInt32 SlangImageFormatIntegral;\n"
"    enum SlangImageFormat : SlangImageFormatIntegral\n"
"    {\n"
"#define SLANG_FORMAT(NAME, DESC) SLANG_IMAGE_FORMAT_##NAME,\n"
"// slang-image-format-defs.h\n"
"#ifndef SLANG_FORMAT\n"
"    #error Must define SLANG_FORMAT macro before including image-format-defs.h\n"
"#endif\n"
"\n"
"SLANG_FORMAT(unknown, (NONE, 0, 0))\n"
"SLANG_FORMAT(rgba32f, (FLOAT32, 4, sizeof(float) * 4))\n"
"SLANG_FORMAT(rgba16f, (FLOAT16, 4, sizeof(uint16_t) * 4))\n"
"SLANG_FORMAT(rg32f, (FLOAT32, 2, sizeof(float) * 2))\n"
"SLANG_FORMAT(rg16f, (FLOAT16, 2, sizeof(uint16_t) * 2))\n"
"SLANG_FORMAT(r11f_g11f_b10f, (NONE, 3, sizeof(uint32_t)))\n"
"SLANG_FORMAT(r32f, (FLOAT32, 1, sizeof(float)))\n"
"SLANG_FORMAT(r16f, (FLOAT16, 1, sizeof(uint16_t)))\n"
"SLANG_FORMAT(rgba16, (UINT16, 4, sizeof(uint16_t) * 4))\n"
"SLANG_FORMAT(rgb10_a2, (NONE, 4, sizeof(uint32_t)))\n"
"SLANG_FORMAT(rgba8, (UINT8, 4, sizeof(uint32_t)))\n"
"SLANG_FORMAT(rg16, (UINT16, 2, sizeof(uint16_t) * 2))\n"
"SLANG_FORMAT(rg8, (UINT8, 2, sizeof(char) * 2))\n"
"SLANG_FORMAT(r16, (UINT16, 1, sizeof(uint16_t)))\n"
"SLANG_FORMAT(r8, (UINT8, 1, sizeof(uint8_t)))\n"
"SLANG_FORMAT(rgba16_snorm, (UINT16, 4, sizeof(uint16_t) * 4))\n"
"SLANG_FORMAT(rgba8_snorm, (UINT8, 4, sizeof(uint8_t) * 4))\n"
"SLANG_FORMAT(rg16_snorm, (UINT16, 2, sizeof(uint16_t) * 2))\n"
"SLANG_FORMAT(rg8_snorm, (UINT8, 2, sizeof(uint8_t) * 2))\n"
"SLANG_FORMAT(r16_snorm, (UINT16, 1, sizeof(uint16_t)))\n"
"SLANG_FORMAT(r8_snorm, (UINT8, 1, sizeof(uint8_t)))\n"
"SLANG_FORMAT(rgba32i, (INT32, 4, sizeof(int32_t) * 4))\n"
"SLANG_FORMAT(rgba16i, (INT16, 4, sizeof(int16_t) * 4))\n"
"SLANG_FORMAT(rgba8i, (INT8, 4, sizeof(int8_t) * 4))\n"
"SLANG_FORMAT(rg32i, (INT32, 2, sizeof(int32_t) * 2))\n"
"SLANG_FORMAT(rg16i, (INT16, 2, sizeof(int16_t) * 2))\n"
"SLANG_FORMAT(rg8i, (INT8, 2, sizeof(int8_t) * 2))\n"
"SLANG_FORMAT(r32i, (INT32, 1, sizeof(int32_t)))\n"
"SLANG_FORMAT(r16i, (INT16, 1, sizeof(int16_t)))\n"
"SLANG_FORMAT(r8i, (INT8, 1, sizeof(int8_t)))\n"
"SLANG_FORMAT(rgba32ui, (UINT32, 4, sizeof(uint32_t) * 4))\n"
"SLANG_FORMAT(rgba16ui, (UINT16, 4, sizeof(uint16_t) * 4))\n"
"SLANG_FORMAT(rgb10_a2ui, (NONE, 4, sizeof(uint32_t)))\n"
"SLANG_FORMAT(rgba8ui, (UINT8, 4, sizeof(uint8_t) * 4))\n"
"SLANG_FORMAT(rg32ui, (UINT32, 2, sizeof(uint32_t) * 2))\n"
"SLANG_FORMAT(rg16ui, (UINT16, 2, sizeof(uint16_t) * 2))\n"
"SLANG_FORMAT(rg8ui, (UINT8, 2, sizeof(uint8_t) * 2))\n"
"SLANG_FORMAT(r32ui, (UINT32, 1, sizeof(uint32_t)))\n"
"SLANG_FORMAT(r16ui, (UINT16, 1, sizeof(uint16_t)))\n"
"SLANG_FORMAT(r8ui, (UINT8, 1, sizeof(uint8_t)))\n"
"SLANG_FORMAT(r64ui, (UINT64, 1, sizeof(uint64_t)))\n"
"SLANG_FORMAT(r64i, (INT64, 1, sizeof(int64_t)))\n"
"SLANG_FORMAT(bgra8, (UINT8, 4, sizeof(uint32_t)))\n"
"\n"
"#undef SLANG_FORMAT\n"
"\n"
"#undef SLANG_FORMAT\n"
"    };\n"
"\n"
"#define SLANG_UNBOUNDED_SIZE (~size_t(0))\n"
"\n"
"    // Shader Parameter Reflection\n"
"\n"
"    typedef SlangReflectionVariableLayout SlangReflectionParameter;\n"
"\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"namespace slang\n"
"{\n"
"struct ISession;\n"
"}\n"
"#endif\n"
"\n"
"#pragma once\n"
"\n"
"\n"
"/* DEPRECATED DEFINITIONS\n"
"\n"
"Everything in this file represents deprecated APIs/definition that are only\n"
"being kept around for source/binary compatibility with old client code. New\n"
"code should not use any of these declarations, and the Slang API will drop these\n"
"declarations over time.\n"
"*/\n"
"\n"
"#ifdef __cplusplus\n"
"extern \"C\"\n"
"{\n"
"#endif\n"
"\n"
"    /*!\n"
"    @brief Initialize an instance of the Slang library.\n"
"    */\n"
"    SLANG_API SlangSession* spCreateSession(const char* deprecated = 0);\n"
"\n"
"    /*!\n"
"    @brief Clean up after an instance of the Slang library.\n"
"    */\n"
"    SLANG_API void spDestroySession(SlangSession* session);\n"
"\n"
"    /** @see slang::IGlobalSession::setSharedLibraryLoader\n"
"     */\n"
"    SLANG_API void spSessionSetSharedLibraryLoader(\n"
"        SlangSession* session,\n"
"        ISlangSharedLibraryLoader* loader);\n"
"\n"
"    /** @see slang::IGlobalSession::getSharedLibraryLoader\n"
"     */\n"
"    SLANG_API ISlangSharedLibraryLoader* spSessionGetSharedLibraryLoader(SlangSession* session);\n"
"\n"
"    /** @see slang::IGlobalSession::checkCompileTargetSupport\n"
"     */\n"
"    SLANG_API SlangResult\n"
"    spSessionCheckCompileTargetSupport(SlangSession* session, SlangCompileTarget target);\n"
"\n"
"    /** @see slang::IGlobalSession::checkPassThroughSupport\n"
"     */\n"
"    SLANG_API SlangResult\n"
"    spSessionCheckPassThroughSupport(SlangSession* session, SlangPassThrough passThrough);\n"
"\n"
"    /** @see slang::IGlobalSession::addBuiltins\n"
"     */\n"
"    SLANG_API void spAddBuiltins(\n"
"        SlangSession* session,\n"
"        char const* sourcePath,\n"
"        char const* sourceString);\n"
"\n"
"    /* @see slang::IGlobalSession::createCompileRequest\n"
"     */\n"
"    SLANG_API SlangCompileRequest* spCreateCompileRequest(SlangSession* session);\n"
"\n"
"    /*!\n"
"    @brief Destroy a compile request.\n"
"    Note a request is a COM object and can be destroyed via 'Release'.\n"
"    */\n"
"    SLANG_API void spDestroyCompileRequest(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::setFileSystem */\n"
"    SLANG_API void spSetFileSystem(SlangCompileRequest* request, ISlangFileSystem* fileSystem);\n"
"\n"
"    /*! @see slang::ICompileRequest::setCompileFlags */\n"
"    SLANG_API void spSetCompileFlags(SlangCompileRequest* request, SlangCompileFlags flags);\n"
"\n"
"    /*! @see slang::ICompileRequest::getCompileFlags */\n"
"    SLANG_API SlangCompileFlags spGetCompileFlags(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDumpIntermediates */\n"
"    SLANG_API void spSetDumpIntermediates(SlangCompileRequest* request, int enable);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDumpIntermediatePrefix */\n"
"    SLANG_API void spSetDumpIntermediatePrefix(SlangCompileRequest* request, const char* prefix);\n"
"\n"
"    /*! DEPRECATED: use `spSetTargetLineDirectiveMode` instead.\n"
"        @see slang::ICompileRequest::setLineDirectiveMode */\n"
"    SLANG_API void spSetLineDirectiveMode(\n"
"        SlangCompileRequest* request,\n"
"        SlangLineDirectiveMode mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetLineDirectiveMode */\n"
"    SLANG_API void spSetTargetLineDirectiveMode(\n"
"        SlangCompileRequest* request,\n"
"        int targetIndex,\n"
"        SlangLineDirectiveMode mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetLineDirectiveMode */\n"
"    SLANG_API void spSetTargetForceGLSLScalarBufferLayout(\n"
"        SlangCompileRequest* request,\n"
"        int targetIndex,\n"
"        bool forceScalarLayout);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetUseMinimumSlangOptimization */\n"
"    SLANG_API void spSetTargetUseMinimumSlangOptimization(\n"
"        slang::ICompileRequest* request,\n"
"        int targetIndex,\n"
"        bool val);\n"
"\n"
"    /*! @see slang::ICompileRequest::setIgnoreCapabilityCheck */\n"
"    SLANG_API void spSetIgnoreCapabilityCheck(slang::ICompileRequest* request, bool val);\n"
"\n"
"    /*! @see slang::ICompileRequest::setCodeGenTarget */\n"
"    SLANG_API void spSetCodeGenTarget(SlangCompileRequest* request, SlangCompileTarget target);\n"
"\n"
"    /*! @see slang::ICompileRequest::addCodeGenTarget */\n"
"    SLANG_API int spAddCodeGenTarget(SlangCompileRequest* request, SlangCompileTarget target);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetProfile */\n"
"    SLANG_API void spSetTargetProfile(\n"
"        SlangCompileRequest* request,\n"
"        int targetIndex,\n"
"        SlangProfileID profile);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetFlags */\n"
"    SLANG_API void spSetTargetFlags(\n"
"        SlangCompileRequest* request,\n"
"        int targetIndex,\n"
"        SlangTargetFlags flags);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::setTargetFloatingPointMode */\n"
;
sb << 
"    SLANG_API void spSetTargetFloatingPointMode(\n"
"        SlangCompileRequest* request,\n"
"        int targetIndex,\n"
"        SlangFloatingPointMode mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTargetCapability */\n"
"    SLANG_API void spAddTargetCapability(\n"
"        slang::ICompileRequest* request,\n"
"        int targetIndex,\n"
"        SlangCapabilityID capability);\n"
"\n"
"    /* DEPRECATED: use `spSetMatrixLayoutMode` instead. */\n"
"    SLANG_API void spSetTargetMatrixLayoutMode(\n"
"        SlangCompileRequest* request,\n"
"        int targetIndex,\n"
"        SlangMatrixLayoutMode mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setMatrixLayoutMode */\n"
"    SLANG_API void spSetMatrixLayoutMode(SlangCompileRequest* request, SlangMatrixLayoutMode mode);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDebugInfoLevel */\n"
"    SLANG_API void spSetDebugInfoLevel(SlangCompileRequest* request, SlangDebugInfoLevel level);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDebugInfoFormat */\n"
"    SLANG_API void spSetDebugInfoFormat(SlangCompileRequest* request, SlangDebugInfoFormat format);\n"
"\n"
"    /*! @see slang::ICompileRequest::setOptimizationLevel */\n"
"    SLANG_API void spSetOptimizationLevel(\n"
"        SlangCompileRequest* request,\n"
"        SlangOptimizationLevel level);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::setOutputContainerFormat */\n"
"    SLANG_API void spSetOutputContainerFormat(\n"
"        SlangCompileRequest* request,\n"
"        SlangContainerFormat format);\n"
"\n"
"    /*! @see slang::ICompileRequest::setPassThrough */\n"
"    SLANG_API void spSetPassThrough(SlangCompileRequest* request, SlangPassThrough passThrough);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDiagnosticCallback */\n"
"    SLANG_API void spSetDiagnosticCallback(\n"
"        SlangCompileRequest* request,\n"
"        SlangDiagnosticCallback callback,\n"
"        void const* userData);\n"
"\n"
"    /*! @see slang::ICompileRequest::setWriter */\n"
"    SLANG_API void spSetWriter(\n"
"        SlangCompileRequest* request,\n"
"        SlangWriterChannel channel,\n"
"        ISlangWriter* writer);\n"
"\n"
"    /*! @see slang::ICompileRequest::getWriter */\n"
"    SLANG_API ISlangWriter* spGetWriter(SlangCompileRequest* request, SlangWriterChannel channel);\n"
"\n"
"    /*! @see slang::ICompileRequest::addSearchPath */\n"
"    SLANG_API void spAddSearchPath(SlangCompileRequest* request, const char* searchDir);\n"
"\n"
"    /*! @see slang::ICompileRequest::addPreprocessorDefine */\n"
"    SLANG_API void spAddPreprocessorDefine(\n"
"        SlangCompileRequest* request,\n"
"        const char* key,\n"
"        const char* value);\n"
"\n"
"    /*! @see slang::ICompileRequest::processCommandLineArguments */\n"
"    SLANG_API SlangResult spProcessCommandLineArguments(\n"
"        SlangCompileRequest* request,\n"
"        char const* const* args,\n"
"        int argCount);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnit */\n"
"    SLANG_API int spAddTranslationUnit(\n"
"        SlangCompileRequest* request,\n"
"        SlangSourceLanguage language,\n"
"        char const* name);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::setDefaultModuleName */\n"
"    SLANG_API void spSetDefaultModuleName(\n"
"        SlangCompileRequest* request,\n"
"        const char* defaultModuleName);\n"
"\n"
"    /*! @see slang::ICompileRequest::addPreprocessorDefine */\n"
"    SLANG_API void spTranslationUnit_addPreprocessorDefine(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex,\n"
"        const char* key,\n"
"        const char* value);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceFile */\n"
"    SLANG_API void spAddTranslationUnitSourceFile(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex,\n"
"        char const* path);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceString */\n"
"    SLANG_API void spAddTranslationUnitSourceString(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex,\n"
"        char const* path,\n"
"        char const* source);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::addLibraryReference */\n"
"    SLANG_API SlangResult spAddLibraryReference(\n"
"        SlangCompileRequest* request,\n"
"        const char* basePath,\n"
"        const void* libData,\n"
"        size_t libDataSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceStringSpan */\n"
"    SLANG_API void spAddTranslationUnitSourceStringSpan(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex,\n"
"        char const* path,\n"
"        char const* sourceBegin,\n"
"        char const* sourceEnd);\n"
"\n"
"    /*! @see slang::ICompileRequest::addTranslationUnitSourceBlob */\n"
"    SLANG_API void spAddTranslationUnitSourceBlob(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex,\n"
"        char const* path,\n"
"        ISlangBlob* sourceBlob);\n"
"\n"
"    /*! @see slang::IGlobalSession::findProfile */\n"
"    SLANG_API SlangProfileID spFindProfile(SlangSession* session, char const* name);\n"
"\n"
"    /*! @see slang::IGlobalSession::findCapability */\n"
"    SLANG_API SlangCapabilityID spFindCapability(SlangSession* session, char const* name);\n"
"\n"
"    /*! @see slang::ICompileRequest::addEntryPoint */\n"
"    SLANG_API int spAddEntryPoint(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex,\n"
"        char const* name,\n"
"        SlangStage stage);\n"
"\n"
"    /*! @see slang::ICompileRequest::addEntryPointEx */\n"
"    SLANG_API int spAddEntryPointEx(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex,\n"
"        char const* name,\n"
"        SlangStage stage,\n"
"        int genericArgCount,\n"
"        char const** genericArgs);\n"
"\n"
"    /*! @see slang::ICompileRequest::setGlobalGenericArgs */\n"
"    SLANG_API SlangResult spSetGlobalGenericArgs(\n"
"        SlangCompileRequest* request,\n"
"        int genericArgCount,\n"
"        char const** genericArgs);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTypeNameForGlobalExistentialTypeParam */\n"
"    SLANG_API SlangResult spSetTypeNameForGlobalExistentialTypeParam(\n"
"        SlangCompileRequest* request,\n"
"        int slotIndex,\n"
"        char const* typeName);\n"
"\n"
"    /*! @see slang::ICompileRequest::setTypeNameForEntryPointExistentialTypeParam */\n"
"    SLANG_API SlangResult spSetTypeNameForEntryPointExistentialTypeParam(\n"
"        SlangCompileRequest* request,\n"
"        int entryPointIndex,\n"
"        int slotIndex,\n"
"        char const* typeName);\n"
"\n"
"    /*! @see slang::ICompileRequest::compile */\n"
"    SLANG_API SlangResult spCompile(SlangCompileRequest* request);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticOutput */\n"
"    SLANG_API char const* spGetDiagnosticOutput(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticOutputBlob */\n"
"    SLANG_API SlangResult\n"
"    spGetDiagnosticOutputBlob(SlangCompileRequest* request, ISlangBlob** outBlob);\n"
"\n"
"\n"
"    /*! @see slang::ICompileRequest::getDependencyFileCount */\n"
"    SLANG_API int spGetDependencyFileCount(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDependencyFilePath */\n"
"    SLANG_API char const* spGetDependencyFilePath(SlangCompileRequest* request, int index);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTranslationUnitCount */\n"
"    SLANG_API int spGetTranslationUnitCount(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointSource */\n"
"    SLANG_API char const* spGetEntryPointSource(SlangCompileRequest* request, int entryPointIndex);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointCode */\n"
"    SLANG_API void const* spGetEntryPointCode(\n"
"        SlangCompileRequest* request,\n"
"        int entryPointIndex,\n"
"        size_t* outSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointCodeBlob */\n"
"    SLANG_API SlangResult spGetEntryPointCodeBlob(\n"
"        SlangCompileRequest* request,\n"
"        int entryPointIndex,\n"
"        int targetIndex,\n"
"        ISlangBlob** outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::getEntryPointHostCallable */\n"
"    SLANG_API SlangResult spGetEntryPointHostCallable(\n"
"        SlangCompileRequest* request,\n"
"        int entryPointIndex,\n"
"        int targetIndex,\n"
"        ISlangSharedLibrary** outSharedLibrary);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTargetCodeBlob */\n"
"    SLANG_API SlangResult\n"
"    spGetTargetCodeBlob(SlangCompileRequest* request, int targetIndex, ISlangBlob** outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::getTargetHostCallable */\n"
"    SLANG_API SlangResult spGetTargetHostCallable(\n"
"        SlangCompileRequest* request,\n"
"        int targetIndex,\n"
"        ISlangSharedLibrary** outSharedLibrary);\n"
"\n"
"    /*! @see slang::ICompileRequest::getCompileRequestCode */\n"
"    SLANG_API void const* spGetCompileRequestCode(SlangCompileRequest* request, size_t* outSize);\n"
"\n"
"    /*! @see slang::ICompileRequest::getContainerCode */\n"
"    SLANG_API SlangResult spGetContainerCode(SlangCompileRequest* request, ISlangBlob** outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::loadRepro */\n"
"    SLANG_API SlangResult spLoadRepro(\n"
"        SlangCompileRequest* request,\n"
"        ISlangFileSystem* fileSystem,\n"
"        const void* data,\n"
"        size_t size);\n"
"\n"
"    /*! @see slang::ICompileRequest::saveRepro */\n"
"    SLANG_API SlangResult spSaveRepro(SlangCompileRequest* request, ISlangBlob** outBlob);\n"
"\n"
"    /*! @see slang::ICompileRequest::enableReproCapture */\n"
"    SLANG_API SlangResult spEnableReproCapture(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::getCompileTimeProfile */\n"
"    SLANG_API SlangResult spGetCompileTimeProfile(\n"
"        SlangCompileRequest* request,\n"
"        ISlangProfiler** compileTimeProfile,\n"
"        bool shouldClear);\n"
"\n"
"\n"
"    /** Extract contents of a repro.\n"
"\n"
"    Writes the contained files and manifest with their 'unique' names into fileSystem. For more\n"
"    details read the docs/repro.md documentation.\n"
"\n"
"    @param session          The slang session\n"
"    @param reproData        Holds the repro data\n"
"    @param reproDataSize    The size of the repro data\n"
"    @param fileSystem       File system that the contents of the repro will be written to\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    SLANG_API SlangResult spExtractRepro(\n"
"        SlangSession* session,\n"
"        const void* reproData,\n"
"        size_t reproDataSize,\n"
"        ISlangMutableFileSystem* fileSystem);\n"
"\n"
"    /* Turns a repro into a file system.\n"
"\n"
"    Makes the contents of the repro available as a file system - that is able to access the files\n"
"    with the same paths as were used on the original repro file system.\n"
"\n"
"    @param session          The slang session\n"
"    @param reproData        The repro data\n"
"    @param reproDataSize    The size of the repro data\n"
"    @param replaceFileSystem  Will attempt to load by unique names from this file system before\n"
"    using contents of the repro. Optional.\n"
"    @param outFileSystem    The file system that can be used to access contents\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    SLANG_API SlangResult spLoadReproAsFileSystem(\n"
"        SlangSession* session,\n"
"        const void* reproData,\n"
"        size_t reproDataSize,\n"
"        ISlangFileSystem* replaceFileSystem,\n"
"        ISlangFileSystemExt** outFileSystem);\n"
"\n"
"    /*! @see slang::ICompileRequest::overrideDiagnosticSeverity */\n"
"    SLANG_API void spOverrideDiagnosticSeverity(\n"
"        SlangCompileRequest* request,\n"
"        SlangInt messageID,\n"
"        SlangSeverity overrideSeverity);\n"
"\n"
"    /*! @see slang::ICompileRequest::getDiagnosticFlags */\n"
"    SLANG_API SlangDiagnosticFlags spGetDiagnosticFlags(SlangCompileRequest* request);\n"
"\n"
"    /*! @see slang::ICompileRequest::setDiagnosticFlags */\n"
"    SLANG_API void spSetDiagnosticFlags(SlangCompileRequest* request, SlangDiagnosticFlags flags);\n"
"\n"
"\n"
"    // get reflection data from a compilation request\n"
"    SLANG_API SlangReflection* spGetReflection(SlangCompileRequest* request);\n"
"\n"
"    // User Attribute\n"
"    SLANG_API char const* spReflectionUserAttribute_GetName(SlangReflectionUserAttribute* attrib);\n"
"    SLANG_API unsigned int spReflectionUserAttribute_GetArgumentCount(\n"
"        SlangReflectionUserAttribute* attrib);\n"
"    SLANG_API SlangReflectionType* spReflectionUserAttribute_GetArgumentType(\n"
"        SlangReflectionUserAttribute* attrib,\n"
"        unsigned int index);\n"
"    SLANG_API SlangResult spReflectionUserAttribute_GetArgumentValueInt(\n"
"        SlangReflectionUserAttribute* attrib,\n"
"        unsigned int index,\n"
"        int* rs);\n"
"    SLANG_API SlangResult spReflectionUserAttribute_GetArgumentValueFloat(\n"
"        SlangReflectionUserAttribute* attrib,\n"
"        unsigned int index,\n"
"        float* rs);\n"
"\n"
"    /** Returns the string-typed value of a user attribute argument\n"
"        The string returned is not null-terminated. The length of the string is returned via\n"
"       `outSize`. If index of out of range, or if the specified argument is not a string, the\n"
"       function will return nullptr.\n"
"    */\n"
"    SLANG_API const char* spReflectionUserAttribute_GetArgumentValueString(\n"
"        SlangReflectionUserAttribute* attrib,\n"
"        unsigned int index,\n"
"        size_t* outSize);\n"
"\n"
"    // Type Reflection\n"
"\n"
"    SLANG_API SlangTypeKind spReflectionType_GetKind(SlangReflectionType* type);\n"
"    SLANG_API unsigned int spReflectionType_GetUserAttributeCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionType_GetUserAttribute(\n"
"        SlangReflectionType* type,\n"
"        unsigned int index);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionType_FindUserAttributeByName(\n"
"        SlangReflectionType* type,\n"
"        char const* name);\n"
"    SLANG_API SlangReflectionType* spReflectionType_applySpecializations(\n"
"        SlangReflectionType* type,\n"
"        SlangReflectionGeneric* generic);\n"
"\n"
"    SLANG_API unsigned int spReflectionType_GetFieldCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionVariable* spReflectionType_GetFieldByIndex(\n"
"        SlangReflectionType* type,\n"
"        unsigned index);\n"
"\n"
"    /** Returns the number of elements in the given type.\n"
"\n"
"    This operation is valid for vector and array types. For other types it returns zero.\n"
"\n"
"    When invoked on an unbounded-size array it will return `SLANG_UNBOUNDED_SIZE`,\n"
"    which is defined to be `~size_t(0)`.\n"
"\n"
"    If the size of a type cannot be statically computed, perhaps because it depends on\n"
"    a generic parameter that has not been bound to a specific value, this function returns zero.\n"
"\n"
"    Use spReflectionType_GetSpecializedElementCount if the size is dependent on\n"
"    a link time constant\n"
"    */\n"
"    SLANG_API size_t spReflectionType_GetElementCount(SlangReflectionType* type);\n"
"\n"
"    /** The same as spReflectionType_GetElementCount except it takes into account specialization\n"
"     * information from the given reflection info\n"
"     */\n"
"    SLANG_API size_t spReflectionType_GetSpecializedElementCount(\n"
"        SlangReflectionType* type,\n"
"        SlangReflection* reflection);\n"
"\n"
"    SLANG_API SlangReflectionType* spReflectionType_GetElementType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API unsigned int spReflectionType_GetRowCount(SlangReflectionType* type);\n"
"    SLANG_API unsigned int spReflectionType_GetColumnCount(SlangReflectionType* type);\n"
"    SLANG_API SlangScalarType spReflectionType_GetScalarType(SlangReflectionType* type);\n"
"\n"
"    SLANG_API SlangResourceShape spReflectionType_GetResourceShape(SlangReflectionType* type);\n"
"    SLANG_API SlangResourceAccess spReflectionType_GetResourceAccess(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionType* spReflectionType_GetResourceResultType(\n"
"        SlangReflectionType* type);\n"
"\n"
"    SLANG_API char const* spReflectionType_GetName(SlangReflectionType* type);\n"
"    SLANG_API SlangResult\n"
"    spReflectionType_GetFullName(SlangReflectionType* type, ISlangBlob** outNameBlob);\n"
"    SLANG_API SlangReflectionGeneric* spReflectionType_GetGenericContainer(\n"
"        SlangReflectionType* type);\n"
"\n"
"    // Type Layout Reflection\n"
"\n"
"    SLANG_API SlangReflectionType* spReflectionTypeLayout_GetType(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangTypeKind spReflectionTypeLayout_getKind(SlangReflectionTypeLayout* type);\n"
"    SLANG_API size_t spReflectionTypeLayout_GetSize(\n"
"        SlangReflectionTypeLayout* type,\n"
"        SlangParameterCategory category);\n"
"    SLANG_API size_t spReflectionTypeLayout_GetStride(\n"
"        SlangReflectionTypeLayout* type,\n"
"        SlangParameterCategory category);\n"
"    SLANG_API int32_t spReflectionTypeLayout_getAlignment(\n"
"        SlangReflectionTypeLayout* type,\n"
"        SlangParameterCategory category);\n"
"\n"
"    SLANG_API uint32_t spReflectionTypeLayout_GetFieldCount(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetFieldByIndex(\n"
"        SlangReflectionTypeLayout* type,\n"
"        unsigned index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_findFieldIndexByName(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        const char* nameBegin,\n"
"        const char* nameEnd);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetExplicitCounter(\n"
"        SlangReflectionTypeLayout* typeLayout);\n"
"\n"
"    SLANG_API size_t spReflectionTypeLayout_GetElementStride(\n"
"        SlangReflectionTypeLayout* type,\n"
;
sb << 
"        SlangParameterCategory category);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_GetElementTypeLayout(\n"
"        SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_GetElementVarLayout(\n"
"        SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getContainerVarLayout(\n"
"        SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangParameterCategory\n"
"    spReflectionTypeLayout_GetParameterCategory(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API unsigned spReflectionTypeLayout_GetCategoryCount(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangParameterCategory\n"
"    spReflectionTypeLayout_GetCategoryByIndex(SlangReflectionTypeLayout* type, unsigned index);\n"
"\n"
"    SLANG_API SlangMatrixLayoutMode\n"
"    spReflectionTypeLayout_GetMatrixLayoutMode(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API int spReflectionTypeLayout_getGenericParamIndex(SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getPendingDataTypeLayout(\n"
"        SlangReflectionTypeLayout* type);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout*\n"
"    spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout(SlangReflectionTypeLayout* type);\n"
"    SLANG_API SlangInt spReflectionType_getSpecializedTypeArgCount(SlangReflectionType* type);\n"
"    SLANG_API SlangReflectionType* spReflectionType_getSpecializedTypeArgType(\n"
"        SlangReflectionType* type,\n"
"        SlangInt index);\n"
"\n"
"    SLANG_API SlangInt\n"
"    spReflectionTypeLayout_getBindingRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getBindingRangeType(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_isBindingRangeSpecializable(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeBindingCount(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getBindingRangeLeafTypeLayout(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangReflectionVariable* spReflectionTypeLayout_getBindingRangeLeafVariable(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangImageFormat spReflectionTypeLayout_getBindingRangeImageFormat(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getFieldBindingRangeOffset(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt fieldIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getExplicitCounterBindingRangeOffset(\n"
"        SlangReflectionTypeLayout* inTypeLayout);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeDescriptorSetIndex(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getBindingRangeDescriptorRangeCount(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt index);\n"
"\n"
"    SLANG_API SlangInt\n"
"    spReflectionTypeLayout_getDescriptorSetCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetSpaceOffset(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt setIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt setIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt setIndex,\n"
"        SlangInt rangeIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt setIndex,\n"
"        SlangInt rangeIndex);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getDescriptorSetDescriptorRangeType(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt setIndex,\n"
"        SlangInt rangeIndex);\n"
"    SLANG_API SlangParameterCategory spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt setIndex,\n"
"        SlangInt rangeIndex);\n"
"\n"
"    SLANG_API SlangInt\n"
"    spReflectionTypeLayout_getSubObjectRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeSpaceOffset(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionTypeLayout_getSubObjectRangeOffset(\n"
"        SlangReflectionTypeLayout* typeLayout,\n"
"        SlangInt subObjectRangeIndex);\n"
"\n"
"#if 0\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeCount(SlangReflectionTypeLayout* typeLayout);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeObjectCount(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionTypeLayout_getSubObjectRangeTypeLayout(SlangReflectionTypeLayout* typeLayout, SlangInt index);\n"
"\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeCount(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex);\n"
"    SLANG_API SlangBindingType spReflectionTypeLayout_getSubObjectRangeDescriptorRangeBindingType(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeBindingCount(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeIndexOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"    SLANG_API SlangInt spReflectionTypeLayout_getSubObjectRangeDescriptorRangeSpaceOffset(SlangReflectionTypeLayout* typeLayout, SlangInt subObjectRangeIndex, SlangInt bindingRangeIndexInSubObject);\n"
"#endif\n"
"\n"
"    // Variable Reflection\n"
"\n"
"    SLANG_API char const* spReflectionVariable_GetName(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionType* spReflectionVariable_GetType(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionModifier* spReflectionVariable_FindModifier(\n"
"        SlangReflectionVariable* var,\n"
"        SlangModifierID modifierID);\n"
"    SLANG_API unsigned int spReflectionVariable_GetUserAttributeCount(SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionVariable_GetUserAttribute(\n"
"        SlangReflectionVariable* var,\n"
"        unsigned int index);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionVariable_FindUserAttributeByName(\n"
"        SlangReflectionVariable* var,\n"
"        SlangSession* globalSession,\n"
"        char const* name);\n"
"    SLANG_API bool spReflectionVariable_HasDefaultValue(SlangReflectionVariable* inVar);\n"
"    SLANG_API SlangResult\n"
"    spReflectionVariable_GetDefaultValueInt(SlangReflectionVariable* inVar, int64_t* rs);\n"
"    SLANG_API SlangReflectionGeneric* spReflectionVariable_GetGenericContainer(\n"
"        SlangReflectionVariable* var);\n"
"    SLANG_API SlangReflectionVariable* spReflectionVariable_applySpecializations(\n"
"        SlangReflectionVariable* var,\n"
"        SlangReflectionGeneric* generic);\n"
"\n"
"    // Variable Layout Reflection\n"
"\n"
"    SLANG_API SlangReflectionVariable* spReflectionVariableLayout_GetVariable(\n"
"        SlangReflectionVariableLayout* var);\n"
"\n"
"    SLANG_API SlangReflectionTypeLayout* spReflectionVariableLayout_GetTypeLayout(\n"
"        SlangReflectionVariableLayout* var);\n"
"\n"
"    SLANG_API size_t spReflectionVariableLayout_GetOffset(\n"
"        SlangReflectionVariableLayout* var,\n"
"        SlangParameterCategory category);\n"
"    SLANG_API size_t spReflectionVariableLayout_GetSpace(\n"
"        SlangReflectionVariableLayout* var,\n"
"        SlangParameterCategory category);\n"
"    SLANG_API SlangImageFormat\n"
"    spReflectionVariableLayout_GetImageFormat(SlangReflectionVariableLayout* var);\n"
"\n"
"    SLANG_API char const* spReflectionVariableLayout_GetSemanticName(\n"
"        SlangReflectionVariableLayout* var);\n"
"    SLANG_API size_t\n"
"    spReflectionVariableLayout_GetSemanticIndex(SlangReflectionVariableLayout* var);\n"
"\n"
"\n"
"    // Function Reflection\n"
"\n"
"    SLANG_API SlangReflectionDecl* spReflectionFunction_asDecl(SlangReflectionFunction* func);\n"
"    SLANG_API char const* spReflectionFunction_GetName(SlangReflectionFunction* func);\n"
"    SLANG_API SlangReflectionModifier* spReflectionFunction_FindModifier(\n"
"        SlangReflectionFunction* var,\n"
"        SlangModifierID modifierID);\n"
"    SLANG_API unsigned int spReflectionFunction_GetUserAttributeCount(\n"
"        SlangReflectionFunction* func);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionFunction_GetUserAttribute(\n"
"        SlangReflectionFunction* func,\n"
"        unsigned int index);\n"
"    SLANG_API SlangReflectionUserAttribute* spReflectionFunction_FindUserAttributeByName(\n"
"        SlangReflectionFunction* func,\n"
"        SlangSession* globalSession,\n"
"        char const* name);\n"
"    SLANG_API unsigned int spReflectionFunction_GetParameterCount(SlangReflectionFunction* func);\n"
"    SLANG_API SlangReflectionVariable* spReflectionFunction_GetParameter(\n"
"        SlangReflectionFunction* func,\n"
"        unsigned index);\n"
"    SLANG_API SlangReflectionType* spReflectionFunction_GetResultType(\n"
"        SlangReflectionFunction* func);\n"
"    SLANG_API SlangReflectionGeneric* spReflectionFunction_GetGenericContainer(\n"
"        SlangReflectionFunction* func);\n"
"    SLANG_API SlangReflectionFunction* spReflectionFunction_applySpecializations(\n"
"        SlangReflectionFunction* func,\n"
"        SlangReflectionGeneric* generic);\n"
"    SLANG_API SlangReflectionFunction* spReflectionFunction_specializeWithArgTypes(\n"
"        SlangReflectionFunction* func,\n"
"        SlangInt argTypeCount,\n"
"        SlangReflectionType* const* argTypes);\n"
"    SLANG_API bool spReflectionFunction_isOverloaded(SlangReflectionFunction* func);\n"
"    SLANG_API unsigned int spReflectionFunction_getOverloadCount(SlangReflectionFunction* func);\n"
"    SLANG_API SlangReflectionFunction* spReflectionFunction_getOverload(\n"
"        SlangReflectionFunction* func,\n"
"        unsigned int index);\n"
"\n"
"    // Abstract Decl Reflection\n"
"\n"
"    SLANG_API unsigned int spReflectionDecl_getChildrenCount(SlangReflectionDecl* parentDecl);\n"
"    SLANG_API SlangReflectionDecl* spReflectionDecl_getChild(\n"
"        SlangReflectionDecl* parentDecl,\n"
"        unsigned int index);\n"
"    SLANG_API char const* spReflectionDecl_getName(SlangReflectionDecl* decl);\n"
"    SLANG_API SlangDeclKind spReflectionDecl_getKind(SlangReflectionDecl* decl);\n"
"    SLANG_API SlangReflectionFunction* spReflectionDecl_castToFunction(SlangReflectionDecl* decl);\n"
"    SLANG_API SlangReflectionVariable* spReflectionDecl_castToVariable(SlangReflectionDecl* decl);\n"
"    SLANG_API SlangReflectionGeneric* spReflectionDecl_castToGeneric(SlangReflectionDecl* decl);\n"
"    SLANG_API SlangReflectionType* spReflection_getTypeFromDecl(SlangReflectionDecl* decl);\n"
"    SLANG_API SlangReflectionDecl* spReflectionDecl_getParent(SlangReflectionDecl* decl);\n"
"    SLANG_API SlangReflectionModifier* spReflectionDecl_findModifier(\n"
"        SlangReflectionDecl* decl,\n"
"        SlangModifierID modifierID);\n"
"\n"
"    // Generic Reflection\n"
"\n"
"    SLANG_API SlangReflectionDecl* spReflectionGeneric_asDecl(SlangReflectionGeneric* generic);\n"
"    SLANG_API char const* spReflectionGeneric_GetName(SlangReflectionGeneric* generic);\n"
"    SLANG_API unsigned int spReflectionGeneric_GetTypeParameterCount(\n"
"        SlangReflectionGeneric* generic);\n"
"    SLANG_API SlangReflectionVariable* spReflectionGeneric_GetTypeParameter(\n"
"        SlangReflectionGeneric* generic,\n"
"        unsigned index);\n"
"    SLANG_API unsigned int spReflectionGeneric_GetValueParameterCount(\n"
"        SlangReflectionGeneric* generic);\n"
"    SLANG_API SlangReflectionVariable* spReflectionGeneric_GetValueParameter(\n"
"        SlangReflectionGeneric* generic,\n"
"        unsigned index);\n"
"    SLANG_API unsigned int spReflectionGeneric_GetTypeParameterConstraintCount(\n"
"        SlangReflectionGeneric* generic,\n"
"        SlangReflectionVariable* typeParam);\n"
"    SLANG_API SlangReflectionType* spReflectionGeneric_GetTypeParameterConstraintType(\n"
"        SlangReflectionGeneric* generic,\n"
"        SlangReflectionVariable* typeParam,\n"
"        unsigned index);\n"
"    SLANG_API SlangDeclKind spReflectionGeneric_GetInnerKind(SlangReflectionGeneric* generic);\n"
"    SLANG_API SlangReflectionDecl* spReflectionGeneric_GetInnerDecl(\n"
"        SlangReflectionGeneric* generic);\n"
"    SLANG_API SlangReflectionGeneric* spReflectionGeneric_GetOuterGenericContainer(\n"
"        SlangReflectionGeneric* generic);\n"
"    SLANG_API SlangReflectionType* spReflectionGeneric_GetConcreteType(\n"
"        SlangReflectionGeneric* generic,\n"
"        SlangReflectionVariable* typeParam);\n"
"    SLANG_API int64_t spReflectionGeneric_GetConcreteIntVal(\n"
"        SlangReflectionGeneric* generic,\n"
"        SlangReflectionVariable* valueParam);\n"
"    SLANG_API SlangReflectionGeneric* spReflectionGeneric_applySpecializations(\n"
"        SlangReflectionGeneric* currGeneric,\n"
"        SlangReflectionGeneric* generic);\n"
"\n"
"\n"
"    /** Get the stage that a variable belongs to (if any).\n"
"\n"
"    A variable \"belongs\" to a specific stage when it is a varying input/output\n"
"    parameter either defined as part of the parameter list for an entry\n"
"    point *or* at the global scope of a stage-specific GLSL code file (e.g.,\n"
"    an `in` parameter in a GLSL `.vs` file belongs to the vertex stage).\n"
"    */\n"
"    SLANG_API SlangStage spReflectionVariableLayout_getStage(SlangReflectionVariableLayout* var);\n"
"\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionVariableLayout_getPendingDataLayout(\n"
"        SlangReflectionVariableLayout* var);\n"
"\n"
"    // Shader Parameter Reflection\n"
"\n"
"    SLANG_API unsigned spReflectionParameter_GetBindingIndex(SlangReflectionParameter* parameter);\n"
"    SLANG_API unsigned spReflectionParameter_GetBindingSpace(SlangReflectionParameter* parameter);\n"
"\n"
"    SLANG_API SlangResult spIsParameterLocationUsed(\n"
"        SlangCompileRequest* request,\n"
"        SlangInt entryPointIndex,\n"
"        SlangInt targetIndex,\n"
"        SlangParameterCategory category, // is this a `t` register? `s` register?\n"
"        SlangUInt spaceIndex,            // `space` for D3D12, `set` for Vulkan\n"
"        SlangUInt registerIndex,         // `register` for D3D12, `binding` for Vulkan\n"
"        bool& outUsed);\n"
"\n"
"    // Entry Point Reflection\n"
"\n"
"    SLANG_API char const* spReflectionEntryPoint_getName(SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API char const* spReflectionEntryPoint_getNameOverride(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionFunction* spReflectionEntryPoint_getFunction(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API unsigned spReflectionEntryPoint_getParameterCount(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getParameterByIndex(\n"
"        SlangReflectionEntryPoint* entryPoint,\n"
"        unsigned index);\n"
"\n"
"    SLANG_API SlangStage spReflectionEntryPoint_getStage(SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API void spReflectionEntryPoint_getComputeThreadGroupSize(\n"
"        SlangReflectionEntryPoint* entryPoint,\n"
"        SlangUInt axisCount,\n"
"        SlangUInt* outSizeAlongAxis);\n"
"\n"
"    SLANG_API void spReflectionEntryPoint_getComputeWaveSize(\n"
"        SlangReflectionEntryPoint* entryPoint,\n"
"        SlangUInt* outWaveSize);\n"
"\n"
"    SLANG_API int spReflectionEntryPoint_usesAnySampleRateInput(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getVarLayout(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API SlangReflectionVariableLayout* spReflectionEntryPoint_getResultVarLayout(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    SLANG_API int spReflectionEntryPoint_hasDefaultConstantBuffer(\n"
"        SlangReflectionEntryPoint* entryPoint);\n"
"\n"
"    // SlangReflectionTypeParameter\n"
"    SLANG_API char const* spReflectionTypeParameter_GetName(\n"
;
sb << 
"        SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API unsigned spReflectionTypeParameter_GetIndex(SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API unsigned spReflectionTypeParameter_GetConstraintCount(\n"
"        SlangReflectionTypeParameter* typeParam);\n"
"    SLANG_API SlangReflectionType* spReflectionTypeParameter_GetConstraintByIndex(\n"
"        SlangReflectionTypeParameter* typeParam,\n"
"        unsigned int index);\n"
"\n"
"    // Shader Reflection\n"
"\n"
"    SLANG_API SlangResult spReflection_ToJson(\n"
"        SlangReflection* reflection,\n"
"        SlangCompileRequest* request,\n"
"        ISlangBlob** outBlob);\n"
"\n"
"    SLANG_API unsigned spReflection_GetParameterCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionParameter* spReflection_GetParameterByIndex(\n"
"        SlangReflection* reflection,\n"
"        unsigned index);\n"
"\n"
"    SLANG_API unsigned int spReflection_GetTypeParameterCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionTypeParameter* spReflection_GetTypeParameterByIndex(\n"
"        SlangReflection* reflection,\n"
"        unsigned int index);\n"
"    SLANG_API SlangReflectionTypeParameter* spReflection_FindTypeParameter(\n"
"        SlangReflection* reflection,\n"
"        char const* name);\n"
"\n"
"    SLANG_API SlangReflectionType* spReflection_FindTypeByName(\n"
"        SlangReflection* reflection,\n"
"        char const* name);\n"
"    SLANG_API SlangReflectionTypeLayout* spReflection_GetTypeLayout(\n"
"        SlangReflection* reflection,\n"
"        SlangReflectionType* reflectionType,\n"
"        SlangLayoutRules rules);\n"
"\n"
"    SLANG_API SlangReflectionFunction* spReflection_FindFunctionByName(\n"
"        SlangReflection* reflection,\n"
"        char const* name);\n"
"    SLANG_API SlangReflectionFunction* spReflection_FindFunctionByNameInType(\n"
"        SlangReflection* reflection,\n"
"        SlangReflectionType* reflType,\n"
"        char const* name);\n"
"    SLANG_API SlangReflectionVariable* spReflection_FindVarByNameInType(\n"
"        SlangReflection* reflection,\n"
"        SlangReflectionType* reflType,\n"
"        char const* name);\n"
"    SLANG_API SlangReflectionFunction* spReflection_TryResolveOverloadedFunction(\n"
"        SlangReflection* reflection,\n"
"        uint32_t candidateCount,\n"
"        SlangReflectionFunction** candidates);\n"
"\n"
"    SLANG_API SlangUInt spReflection_getEntryPointCount(SlangReflection* reflection);\n"
"    SLANG_API SlangReflectionEntryPoint* spReflection_getEntryPointByIndex(\n"
"        SlangReflection* reflection,\n"
"        SlangUInt index);\n"
"    SLANG_API SlangReflectionEntryPoint* spReflection_findEntryPointByName(\n"
"        SlangReflection* reflection,\n"
"        char const* name);\n"
"\n"
"    SLANG_API SlangUInt spReflection_getGlobalConstantBufferBinding(SlangReflection* reflection);\n"
"    SLANG_API size_t spReflection_getGlobalConstantBufferSize(SlangReflection* reflection);\n"
"\n"
"    SLANG_API SlangReflectionType* spReflection_specializeType(\n"
"        SlangReflection* reflection,\n"
"        SlangReflectionType* type,\n"
"        SlangInt specializationArgCount,\n"
"        SlangReflectionType* const* specializationArgs,\n"
"        ISlangBlob** outDiagnostics);\n"
"\n"
"    SLANG_API SlangReflectionGeneric* spReflection_specializeGeneric(\n"
"        SlangReflection* inProgramLayout,\n"
"        SlangReflectionGeneric* generic,\n"
"        SlangInt argCount,\n"
"        SlangReflectionGenericArgType const* argTypes,\n"
"        SlangReflectionGenericArg const* args,\n"
"        ISlangBlob** outDiagnostics);\n"
"\n"
"    SLANG_API bool spReflection_isSubType(\n"
"        SlangReflection* reflection,\n"
"        SlangReflectionType* subType,\n"
"        SlangReflectionType* superType);\n"
"\n"
"    /// Get the number of hashed strings\n"
"    SLANG_API SlangUInt spReflection_getHashedStringCount(SlangReflection* reflection);\n"
"\n"
"    /// Get a hashed string. The number of chars is written in outCount.\n"
"    /// The count does *NOT* including terminating 0. The returned string will be 0 terminated.\n"
"    SLANG_API const char* spReflection_getHashedString(\n"
"        SlangReflection* reflection,\n"
"        SlangUInt index,\n"
"        size_t* outCount);\n"
"\n"
"    /// Compute a string hash.\n"
"    /// Count should *NOT* include terminating zero.\n"
"    SLANG_API SlangUInt32 spComputeStringHash(const char* chars, size_t count);\n"
"\n"
"    /// Get a type layout representing reflection information for the global-scope parameters.\n"
"    SLANG_API SlangReflectionTypeLayout* spReflection_getGlobalParamsTypeLayout(\n"
"        SlangReflection* reflection);\n"
"\n"
"    /// Get a variable layout representing reflection information for the global-scope parameters.\n"
"    SLANG_API SlangReflectionVariableLayout* spReflection_getGlobalParamsVarLayout(\n"
"        SlangReflection* reflection);\n"
"\n"
"    SLANG_API char const* spGetTranslationUnitSource(\n"
"        SlangCompileRequest* request,\n"
"        int translationUnitIndex);\n"
"#ifdef __cplusplus\n"
"}\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"SLANG_API slang::ISession* spReflection_GetSession(SlangReflection* reflection);\n"
"\n"
"namespace slang\n"
"{\n"
"struct IComponentType;\n"
"struct IModule;\n"
"} // namespace slang\n"
"\n"
"extern \"C\"\n"
"{\n"
"    /** @see slang::ICompileRequest::getProgram\n"
"     */\n"
"    SLANG_API SlangResult\n"
"    spCompileRequest_getProgram(SlangCompileRequest* request, slang::IComponentType** outProgram);\n"
"\n"
"    /** @see slang::ICompileRequest::getProgramWithEntryPoints\n"
"     */\n"
"    SLANG_API SlangResult spCompileRequest_getProgramWithEntryPoints(\n"
"        SlangCompileRequest* request,\n"
"        slang::IComponentType** outProgram);\n"
"\n"
"    /** @see slang::ICompileRequest::getEntryPoint\n"
"     */\n"
"    SLANG_API SlangResult spCompileRequest_getEntryPoint(\n"
"        SlangCompileRequest* request,\n"
"        SlangInt entryPointIndex,\n"
"        slang::IComponentType** outEntryPoint);\n"
"\n"
"    /** @see slang::ICompileRequest::getModule\n"
"     */\n"
"    SLANG_API SlangResult spCompileRequest_getModule(\n"
"        SlangCompileRequest* request,\n"
"        SlangInt translationUnitIndex,\n"
"        slang::IModule** outModule);\n"
"\n"
"    /** @see slang::ICompileRequest::getSession\n"
"     */\n"
"    SLANG_API SlangResult\n"
"    spCompileRequest_getSession(SlangCompileRequest* request, slang::ISession** outSession);\n"
"}\n"
"\n"
"namespace slang\n"
"{\n"
"/*!\n"
"@brief A request for one or more compilation actions to be performed.\n"
"*/\n"
"struct ICompileRequest : public ISlangUnknown\n"
"{\n"
"    SLANG_COM_INTERFACE(\n"
"        0x96d33993,\n"
"        0x317c,\n"
"        0x4db5,\n"
"        {0xaf, 0xd8, 0x66, 0x6e, 0xe7, 0x72, 0x48, 0xe2})\n"
"\n"
"    /** Set the filesystem hook to use for a compile request\n"
"\n"
"    The provided `fileSystem` will be used to load any files that\n"
"    need to be loaded during processing of the compile `request`.\n"
"    This includes:\n"
"\n"
"      - Source files loaded via `spAddTranslationUnitSourceFile`\n"
"      - Files referenced via `#include`\n"
"      - Files loaded to resolve `#import` operations\n"
"        */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setFileSystem(ISlangFileSystem* fileSystem) = 0;\n"
"\n"
"    /*!\n"
"    @brief Set flags to be used for compilation.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setCompileFlags(SlangCompileFlags flags) = 0;\n"
"\n"
"    /*!\n"
"    @brief Returns the compilation flags previously set with `setCompileFlags`\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangCompileFlags SLANG_MCALL getCompileFlags() = 0;\n"
"\n"
"    /*!\n"
"    @brief Set whether to dump intermediate results (for debugging) or not.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediates(int enable) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setDumpIntermediatePrefix(const char* prefix) = 0;\n"
"\n"
"    /*!\n"
"    @brief Set whether (and how) `#line` directives should be output.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setLineDirectiveMode(SlangLineDirectiveMode mode) = 0;\n"
"\n"
"    /*!\n"
"    @brief Sets the target for code generation.\n"
"    @param target The code generation target. Possible values are:\n"
"    - SLANG_GLSL. Generates GLSL code.\n"
"    - SLANG_HLSL. Generates HLSL code.\n"
"    - SLANG_SPIRV. Generates SPIR-V code.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setCodeGenTarget(SlangCompileTarget target) = 0;\n"
"\n"
"    /*!\n"
"    @brief Add a code-generation target to be used.\n"
"    */\n"
"    virtual SLANG_NO_THROW int SLANG_MCALL addCodeGenTarget(SlangCompileTarget target) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetProfile(int targetIndex, SlangProfileID profile) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetFlags(int targetIndex, SlangTargetFlags flags) = 0;\n"
"\n"
"    /*!\n"
"    @brief Set the floating point mode (e.g., precise or fast) to use a target.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetFloatingPointMode(int targetIndex, SlangFloatingPointMode mode) = 0;\n"
"\n"
"    /* DEPRECATED: use `spSetMatrixLayoutMode` instead. */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetMatrixLayoutMode(int targetIndex, SlangMatrixLayoutMode mode) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setMatrixLayoutMode(SlangMatrixLayoutMode mode) = 0;\n"
"\n"
"    /*!\n"
"    @brief Set the level of debug information to produce.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setDebugInfoLevel(SlangDebugInfoLevel level) = 0;\n"
"\n"
"    /*!\n"
"    @brief Set the level of optimization to perform.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setOptimizationLevel(SlangOptimizationLevel level) = 0;\n"
"\n"
"\n"
"    /*!\n"
"    @brief Set the container format to be used for binary output.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setOutputContainerFormat(SlangContainerFormat format) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setPassThrough(SlangPassThrough passThrough) = 0;\n"
"\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setDiagnosticCallback(SlangDiagnosticCallback callback, void const* userData) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setWriter(SlangWriterChannel channel, ISlangWriter* writer) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW ISlangWriter* SLANG_MCALL getWriter(SlangWriterChannel channel) = 0;\n"
"\n"
"    /*!\n"
"    @brief Add a path to use when searching for referenced files.\n"
"    This will be used for both `#include` directives and also for explicit `__import` declarations.\n"
"    @param ctx The compilation context.\n"
"    @param searchDir The additional search directory.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL addSearchPath(const char* searchDir) = 0;\n"
"\n"
"    /*!\n"
"    @brief Add a macro definition to be used during preprocessing.\n"
"    @param key The name of the macro to define.\n"
"    @param value The value of the macro to define.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    addPreprocessorDefine(const char* key, const char* value) = 0;\n"
"\n"
"    /*!\n"
"    @brief Set options using arguments as if specified via command line.\n"
"    @return Returns SlangResult. On success SLANG_SUCCEEDED(result) is true.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    processCommandLineArguments(char const* const* args, int argCount) = 0;\n"
"\n"
"    /** Add a distinct translation unit to the compilation request\n"
"\n"
"    `name` is optional.\n"
"    Returns the zero-based index of the translation unit created.\n"
"    */\n"
"    virtual SLANG_NO_THROW int SLANG_MCALL\n"
"    addTranslationUnit(SlangSourceLanguage language, char const* name) = 0;\n"
"\n"
"\n"
"    /** Set a default module name. Translation units will default to this module name if one is not\n"
"    passed. If not set each translation unit will get a unique name.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setDefaultModuleName(const char* defaultModuleName) = 0;\n"
"\n"
"    /** Add a preprocessor definition that is scoped to a single translation unit.\n"
"\n"
"    @param translationUnitIndex The index of the translation unit to get the definition.\n"
"    @param key The name of the macro to define.\n"
"    @param value The value of the macro to define.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitPreprocessorDefine(\n"
"        int translationUnitIndex,\n"
"        const char* key,\n"
"        const char* value) = 0;\n"
"\n"
"\n"
"    /** Add a source file to the given translation unit.\n"
"\n"
"    If a user-defined file system has been specified via\n"
"    `spSetFileSystem`, then it will be used to load the\n"
"    file at `path`. Otherwise, Slang will use the OS\n"
"    file system.\n"
"\n"
"    This function does *not* search for a file using\n"
"    the registered search paths (`spAddSearchPath`),\n"
"    and instead using the given `path` as-is.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    addTranslationUnitSourceFile(int translationUnitIndex, char const* path) = 0;\n"
"\n"
"    /** Add a source string to the given translation unit.\n"
"\n"
"    @param translationUnitIndex The index of the translation unit to add source to.\n"
"    @param path The file-system path that should be assumed for the source code.\n"
"    @param source A null-terminated UTF-8 encoded string of source code.\n"
"\n"
"    The implementation will make a copy of the source code data.\n"
"    An application may free the buffer immediately after this call returns.\n"
"\n"
"    The `path` will be used in any diagnostic output, as well\n"
"    as to determine the base path when resolving relative\n"
"    `#include`s.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceString(\n"
"        int translationUnitIndex,\n"
"        char const* path,\n"
"        char const* source) = 0;\n"
"\n"
"\n"
"    /** Add a slang library - such that its contents can be referenced during linking.\n"
"    This is equivalent to the -r command line option.\n"
"\n"
"    @param basePath The base path used to lookup referenced modules.\n"
"    @param libData The library data\n"
"    @param libDataSize The size of the library data\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    addLibraryReference(const char* basePath, const void* libData, size_t libDataSize) = 0;\n"
"\n"
"    /** Add a source string to the given translation unit.\n"
"\n"
"    @param translationUnitIndex The index of the translation unit to add source to.\n"
"    @param path The file-system path that should be assumed for the source code.\n"
"    @param sourceBegin A pointer to a buffer of UTF-8 encoded source code.\n"
"    @param sourceEnd A pointer to to the end of the buffer specified in `sourceBegin`\n"
"\n"
"    The implementation will make a copy of the source code data.\n"
"    An application may free the buffer immediately after this call returns.\n"
"\n"
"    The `path` will be used in any diagnostic output, as well\n"
"    as to determine the base path when resolving relative\n"
"    `#include`s.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceStringSpan(\n"
"        int translationUnitIndex,\n"
"        char const* path,\n"
"        char const* sourceBegin,\n"
"        char const* sourceEnd) = 0;\n"
"\n"
"    /** Add a blob of source code to the given translation unit.\n"
"\n"
"    @param translationUnitIndex The index of the translation unit to add source to.\n"
"    @param path The file-system path that should be assumed for the source code.\n"
"    @param sourceBlob A blob containing UTF-8 encoded source code.\n"
"    @param sourceEnd A pointer to to the end of the buffer specified in `sourceBegin`\n"
"\n"
"    The compile request will retain a reference to the blob.\n"
"\n"
"    The `path` will be used in any diagnostic output, as well\n"
"    as to determine the base path when resolving relative\n"
"    `#include`s.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL addTranslationUnitSourceBlob(\n"
"        int translationUnitIndex,\n"
"        char const* path,\n"
"        ISlangBlob* sourceBlob) = 0;\n"
"\n"
"    /** Add an entry point in a particular translation unit\n"
"     */\n"
"    virtual SLANG_NO_THROW int SLANG_MCALL\n"
"    addEntryPoint(int translationUnitIndex, char const* name, SlangStage stage) = 0;\n"
"\n"
"    /** Add an entry point in a particular translation unit,\n"
"        with additional arguments that specify the concrete\n"
"        type names for entry-point generic type parameters.\n"
"    */\n"
"    virtual SLANG_NO_THROW int SLANG_MCALL addEntryPointEx(\n"
"        int translationUnitIndex,\n"
"        char const* name,\n"
"        SlangStage stage,\n"
"        int genericArgCount,\n"
"        char const** genericArgs) = 0;\n"
"\n"
"    /** Specify the arguments to use for global generic parameters.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    setGlobalGenericArgs(int genericArgCount, char const** genericArgs) = 0;\n"
"\n"
"    /** Specify the concrete type to be used for a global \"existential slot.\"\n"
"\n"
"    Every shader parameter (or leaf field of a `struct`-type shader parameter)\n"
"    that has an interface or array-of-interface type introduces an existential\n"
"    slot. The number of slots consumed by a shader parameter, and the starting\n"
"    slot of each parameter can be queried via the reflection API using\n"
"    `SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.\n"
"\n"
"    In order to generate specialized code, a concrete type needs to be specified\n"
"    for each existential slot. This function specifies the name of the type\n"
"    (or in general a type *expression*) to use for a specific slot at the\n"
"    global scope.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    setTypeNameForGlobalExistentialTypeParam(int slotIndex, char const* typeName) = 0;\n"
"\n"
"    /** Specify the concrete type to be used for an entry-point \"existential slot.\"\n"
"\n"
;
sb << 
"    Every shader parameter (or leaf field of a `struct`-type shader parameter)\n"
"    that has an interface or array-of-interface type introduces an existential\n"
"    slot. The number of slots consumed by a shader parameter, and the starting\n"
"    slot of each parameter can be queried via the reflection API using\n"
"    `SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM`.\n"
"\n"
"    In order to generate specialized code, a concrete type needs to be specified\n"
"    for each existential slot. This function specifies the name of the type\n"
"    (or in general a type *expression*) to use for a specific slot at the\n"
"    entry-point scope.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL setTypeNameForEntryPointExistentialTypeParam(\n"
"        int entryPointIndex,\n"
"        int slotIndex,\n"
"        char const* typeName) = 0;\n"
"\n"
"    /** Enable or disable an experimental, best-effort GLSL frontend\n"
"     */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setAllowGLSLInput(bool value) = 0;\n"
"\n"
"    /** Execute the compilation request.\n"
"\n"
"    @returns  SlangResult, SLANG_OK on success. Use SLANG_SUCCEEDED() and SLANG_FAILED() to test\n"
"    SlangResult.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL compile() = 0;\n"
"\n"
"\n"
"    /** Get any diagnostic messages reported by the compiler.\n"
"\n"
"    @returns A null-terminated UTF-8 encoded string of diagnostic messages.\n"
"\n"
"    The returned pointer is only guaranteed to be valid\n"
"    until `request` is destroyed. Applications that wish to\n"
"    hold on to the diagnostic output for longer should use\n"
"    `getDiagnosticOutputBlob`.\n"
"    */\n"
"    virtual SLANG_NO_THROW char const* SLANG_MCALL getDiagnosticOutput() = 0;\n"
"\n"
"    /** Get diagnostic messages reported by the compiler.\n"
"\n"
"    @param outBlob A pointer to receive a blob holding a nul-terminated UTF-8 encoded string of\n"
"    diagnostic messages.\n"
"    @returns A `SlangResult` indicating success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getDiagnosticOutputBlob(ISlangBlob** outBlob) = 0;\n"
"\n"
"\n"
"    /** Get the number of files that this compilation depended on.\n"
"\n"
"    This includes both the explicit source files, as well as any\n"
"    additional files that were transitively referenced (e.g., via\n"
"    a `#include` directive).\n"
"    */\n"
"    virtual SLANG_NO_THROW int SLANG_MCALL getDependencyFileCount() = 0;\n"
"\n"
"    /** Get the path to a file this compilation depended on.\n"
"     */\n"
"    virtual SLANG_NO_THROW char const* SLANG_MCALL getDependencyFilePath(int index) = 0;\n"
"\n"
"    /** Get the number of translation units associated with the compilation request\n"
"     */\n"
"    virtual SLANG_NO_THROW int SLANG_MCALL getTranslationUnitCount() = 0;\n"
"\n"
"    /** Get the output source code associated with a specific entry point.\n"
"\n"
"    The lifetime of the output pointer is the same as `request`.\n"
"    */\n"
"    virtual SLANG_NO_THROW char const* SLANG_MCALL getEntryPointSource(int entryPointIndex) = 0;\n"
"\n"
"    /** Get the output bytecode associated with a specific entry point.\n"
"\n"
"    The lifetime of the output pointer is the same as `request`.\n"
"    */\n"
"    virtual SLANG_NO_THROW void const* SLANG_MCALL\n"
"    getEntryPointCode(int entryPointIndex, size_t* outSize) = 0;\n"
"\n"
"    /** Get the output code associated with a specific entry point.\n"
"\n"
"    @param entryPointIndex The index of the entry point to get code for.\n"
"    @param targetIndex The index of the target to get code for (default: zero).\n"
"    @param outBlob A pointer that will receive the blob of code\n"
"    @returns A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getEntryPointCodeBlob(int entryPointIndex, int targetIndex, ISlangBlob** outBlob) = 0;\n"
"\n"
"    /** Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.\n"
"\n"
"    That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"    NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"\n"
"    @param entryPointIndex  The index of the entry point to get code for.\n"
"    @param targetIndex      The index of the target to get code for (default: zero).\n"
"    @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried\n"
"    on.\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n"
"        int entryPointIndex,\n"
"        int targetIndex,\n"
"        ISlangSharedLibrary** outSharedLibrary) = 0;\n"
"\n"
"    /** Get the output code associated with a specific target.\n"
"\n"
"    @param targetIndex The index of the target to get code for (default: zero).\n"
"    @param outBlob A pointer that will receive the blob of code\n"
"    @returns A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getTargetCodeBlob(int targetIndex, ISlangBlob** outBlob) = 0;\n"
"\n"
"    /** Get 'callable' functions for a target accessible through the ISlangSharedLibrary interface.\n"
"\n"
"    That the functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"    NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"\n"
"    @param targetIndex      The index of the target to get code for (default: zero).\n"
"    @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried\n"
"    on.\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getTargetHostCallable(int targetIndex, ISlangSharedLibrary** outSharedLibrary) = 0;\n"
"\n"
"    /** Get the output bytecode associated with an entire compile request.\n"
"\n"
"    The lifetime of the output pointer is the same as `request` and the last spCompile.\n"
"\n"
"    @param outSize          The size of the containers contents in bytes. Will be zero if there is\n"
"    no code available.\n"
"    @returns                Pointer to start of the contained data, or nullptr if there is no code\n"
"    available.\n"
"    */\n"
"    virtual SLANG_NO_THROW void const* SLANG_MCALL getCompileRequestCode(size_t* outSize) = 0;\n"
"\n"
"    /** Get the compilation result as a file system.\n"
"    The result is not written to the actual OS file system, but is made available as an\n"
"    in memory representation.\n"
"    */\n"
"    virtual SLANG_NO_THROW ISlangMutableFileSystem* SLANG_MCALL\n"
"    getCompileRequestResultAsFileSystem() = 0;\n"
"\n"
"    /** Return the container code as a blob. The container blob is created as part of a compilation\n"
"    (with spCompile), and a container is produced with a suitable ContainerFormat.\n"
"\n"
"    @param outSize          The blob containing the container data.\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getContainerCode(ISlangBlob** outBlob) = 0;\n"
"\n"
"    /** Load repro from memory specified.\n"
"\n"
"    Should only be performed on a newly created request.\n"
"\n"
"    NOTE! When using the fileSystem, files will be loaded via their `unique names` as if they are\n"
"    part of the flat file system. This mechanism is described more fully in docs/repro.md.\n"
"\n"
"    @param fileSystem       An (optional) filesystem. Pass nullptr to just use contents of repro\n"
"    held in data.\n"
"    @param data             The data to load from.\n"
"    @param size             The size of the data to load from.\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    loadRepro(ISlangFileSystem* fileSystem, const void* data, size_t size) = 0;\n"
"\n"
"    /** Save repro state. Should *typically* be performed after spCompile, so that everything\n"
"    that is needed for a compilation is available.\n"
"\n"
"    @param outBlob          Blob that will hold the serialized state\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveRepro(ISlangBlob** outBlob) = 0;\n"
"\n"
"    /** Enable repro capture.\n"
"\n"
"    Should be set after any ISlangFileSystem has been set, but before any compilation. It ensures\n"
"    that everything that the ISlangFileSystem accesses will be correctly recorded. Note that if a\n"
"    ISlangFileSystem/ISlangFileSystemExt isn't explicitly set (ie the default is used), then the\n"
"    request will automatically be set up to record everything appropriate.\n"
"\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL enableReproCapture() = 0;\n"
"\n"
"    /** Get the (linked) program for a compile request.\n"
"\n"
"    The linked program will include all of the global-scope modules for the\n"
"    translation units in the program, plus any modules that they `import`\n"
"    (transitively), specialized to any global specialization arguments that\n"
"    were provided via the API.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getProgram(slang::IComponentType** outProgram) = 0;\n"
"\n"
"    /** Get the (partially linked) component type for an entry point.\n"
"\n"
"    The returned component type will include the entry point at the\n"
"    given index, and will be specialized using any specialization arguments\n"
"    that were provided for it via the API.\n"
"\n"
"    The returned component will *not* include the modules representing\n"
"    the global scope and its dependencies/specialization, so a client\n"
"    program will typically want to compose this component type with\n"
"    the one returned by `spCompileRequest_getProgram` to get a complete\n"
"    and usable component type from which kernel code can be requested.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getEntryPoint(SlangInt entryPointIndex, slang::IComponentType** outEntryPoint) = 0;\n"
"\n"
"    /** Get the (un-linked) module for a translation unit.\n"
"\n"
"    The returned module will not be linked against any dependencies,\n"
"    nor against any entry points (even entry points declared inside\n"
"    the module). Similarly, the module will not be specialized\n"
"    to the arguments that might have been provided via the API.\n"
"\n"
"    This function provides an atomic unit of loaded code that\n"
"    is suitable for looking up types and entry points in the\n"
"    given module, and for linking together to produce a composite\n"
"    program that matches the needs of an application.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getModule(SlangInt translationUnitIndex, slang::IModule** outModule) = 0;\n"
"\n"
"    /** Get the `ISession` handle behind the `SlangCompileRequest`.\n"
"    TODO(JS): Arguably this should just return the session pointer.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getSession(slang::ISession** outSession) = 0;\n"
"\n"
"    /** get reflection data from a compilation request */\n"
"    virtual SLANG_NO_THROW SlangReflection* SLANG_MCALL getReflection() = 0;\n"
"\n"
"    /** Make output specially handled for command line output */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setCommandLineCompilerMode() = 0;\n"
"\n"
"    /** Add a defined capability that should be assumed available on the target */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    addTargetCapability(SlangInt targetIndex, SlangCapabilityID capability) = 0;\n"
"\n"
"    /** Get the (linked) program for a compile request, including all entry points.\n"
"\n"
"    The resulting program will include all of the global-scope modules for the\n"
"    translation units in the program, plus any modules that they `import`\n"
"    (transitively), specialized to any global specialization arguments that\n"
"    were provided via the API, as well as all entry points specified for compilation,\n"
"    specialized to their entry-point specialization arguments.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getProgramWithEntryPoints(slang::IComponentType** outProgram) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL isParameterLocationUsed(\n"
"        SlangInt entryPointIndex,\n"
"        SlangInt targetIndex,\n"
"        SlangParameterCategory category,\n"
"        SlangUInt spaceIndex,\n"
"        SlangUInt registerIndex,\n"
"        bool& outUsed) = 0;\n"
"\n"
"    /** Set the line directive mode for a target.\n"
"     */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetLineDirectiveMode(SlangInt targetIndex, SlangLineDirectiveMode mode) = 0;\n"
"\n"
"    /** Set whether to use scalar buffer layouts for GLSL/Vulkan targets.\n"
"        If true, the generated GLSL/Vulkan code will use `scalar` layout for storage buffers.\n"
"        If false, the resulting code will std430 for storage buffers.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetForceGLSLScalarBufferLayout(int targetIndex, bool forceScalarLayout) = 0;\n"
"\n"
"    /** Overrides the severity of a specific diagnostic message.\n"
"\n"
"    @param messageID            Numeric identifier of the message to override,\n"
"                                as defined in the 1st parameter of the DIAGNOSTIC macro.\n"
"    @param overrideSeverity     New severity of the message. If the message is originally Error or\n"
"    Fatal, the new severity cannot be lower than that.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    overrideDiagnosticSeverity(SlangInt messageID, SlangSeverity overrideSeverity) = 0;\n"
"\n"
"    /** Returns the currently active flags of the request's diagnostic sink. */\n"
"    virtual SLANG_NO_THROW SlangDiagnosticFlags SLANG_MCALL getDiagnosticFlags() = 0;\n"
"\n"
"    /** Sets the flags of the request's diagnostic sink.\n"
"        The previously specified flags are discarded. */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setDiagnosticFlags(SlangDiagnosticFlags flags) = 0;\n"
"\n"
"    /** Set the debug format to be used for debugging information */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setDebugInfoFormat(SlangDebugInfoFormat debugFormat) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setEnableEffectAnnotations(bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setReportDownstreamTime(bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setReportPerfBenchmark(bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setSkipSPIRVValidation(bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetUseMinimumSlangOptimization(int targetIndex, bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setIgnoreCapabilityCheck(bool value) = 0;\n"
"\n"
"    // return a copy of internal profiling results, and if `shouldClear` is true, clear the internal\n"
"    // profiling results before returning.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getCompileTimeProfile(ISlangProfiler** compileTimeProfile, bool shouldClear) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetGenerateWholeProgram(int targetIndex, bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setTargetForceDXLayout(int targetIndex, bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setTargetEmbedDownstreamIR(int targetIndex, bool value) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setTargetForceCLayout(int targetIndex, bool value) = 0;\n"
"};\n"
"\n"
"    #define SLANG_UUID_ICompileRequest ICompileRequest::getTypeGuid()\n"
"\n"
"} // namespace slang\n"
"#endif\n"
"\n"
"\n"
"#ifdef __cplusplus\n"
"\n"
"/* Helper interfaces for C++ users */\n"
"namespace slang\n"
"{\n"
"struct BufferReflection;\n"
"struct DeclReflection;\n"
"struct TypeLayoutReflection;\n"
"struct TypeReflection;\n"
"struct VariableLayoutReflection;\n"
"struct VariableReflection;\n"
"struct FunctionReflection;\n"
"struct GenericReflection;\n"
"\n"
"union GenericArgReflection\n"
"{\n"
"    TypeReflection* typeVal;\n"
"    int64_t intVal;\n"
"    bool boolVal;\n"
"};\n"
"\n"
"struct Attribute\n"
"{\n"
"    char const* getName()\n"
"    {\n"
"        return spReflectionUserAttribute_GetName((SlangReflectionAttribute*)this);\n"
"    }\n"
"    uint32_t getArgumentCount()\n"
"    {\n"
"        return (uint32_t)spReflectionUserAttribute_GetArgumentCount(\n"
"            (SlangReflectionAttribute*)this);\n"
"    }\n"
"    TypeReflection* getArgumentType(uint32_t index)\n"
"    {\n"
"        return (TypeReflection*)spReflectionUserAttribute_GetArgumentType(\n"
"            (SlangReflectionAttribute*)this,\n"
"            index);\n"
"    }\n"
"    SlangResult getArgumentValueInt(uint32_t index, int* value)\n"
"    {\n"
"        return spReflectionUserAttribute_GetArgumentValueInt(\n"
"            (SlangReflectionAttribute*)this,\n"
"            index,\n"
"            value);\n"
"    }\n"
"    SlangResult getArgumentValueFloat(uint32_t index, float* value)\n"
"    {\n"
"        return spReflectionUserAttribute_GetArgumentValueFloat(\n"
"            (SlangReflectionAttribute*)this,\n"
"            index,\n"
"            value);\n"
"    }\n"
"    const char* getArgumentValueString(uint32_t index, size_t* outSize)\n"
"    {\n"
"        return spReflectionUserAttribute_GetArgumentValueString(\n"
"            (SlangReflectionAttribute*)this,\n"
"            index,\n"
"            outSize);\n"
"    }\n"
"};\n"
"\n"
"typedef Attribute UserAttribute;\n"
"\n"
"struct TypeReflection\n"
"{\n"
"    enum class Kind\n"
"    {\n"
"        None = SLANG_TYPE_KIND_NONE,\n"
"        Struct = SLANG_TYPE_KIND_STRUCT,\n"
"        Array = SLANG_TYPE_KIND_ARRAY,\n"
"        Matrix = SLANG_TYPE_KIND_MATRIX,\n"
"        Vector = SLANG_TYPE_KIND_VECTOR,\n"
;
sb << 
"        Scalar = SLANG_TYPE_KIND_SCALAR,\n"
"        ConstantBuffer = SLANG_TYPE_KIND_CONSTANT_BUFFER,\n"
"        Resource = SLANG_TYPE_KIND_RESOURCE,\n"
"        SamplerState = SLANG_TYPE_KIND_SAMPLER_STATE,\n"
"        TextureBuffer = SLANG_TYPE_KIND_TEXTURE_BUFFER,\n"
"        ShaderStorageBuffer = SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER,\n"
"        ParameterBlock = SLANG_TYPE_KIND_PARAMETER_BLOCK,\n"
"        GenericTypeParameter = SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER,\n"
"        Interface = SLANG_TYPE_KIND_INTERFACE,\n"
"        OutputStream = SLANG_TYPE_KIND_OUTPUT_STREAM,\n"
"        Specialized = SLANG_TYPE_KIND_SPECIALIZED,\n"
"        Feedback = SLANG_TYPE_KIND_FEEDBACK,\n"
"        Pointer = SLANG_TYPE_KIND_POINTER,\n"
"        DynamicResource = SLANG_TYPE_KIND_DYNAMIC_RESOURCE,\n"
"        MeshOutput = SLANG_TYPE_KIND_MESH_OUTPUT,\n"
"    };\n"
"\n"
"    enum ScalarType : SlangScalarTypeIntegral\n"
"    {\n"
"        None = SLANG_SCALAR_TYPE_NONE,\n"
"        Void = SLANG_SCALAR_TYPE_VOID,\n"
"        Bool = SLANG_SCALAR_TYPE_BOOL,\n"
"        Int32 = SLANG_SCALAR_TYPE_INT32,\n"
"        UInt32 = SLANG_SCALAR_TYPE_UINT32,\n"
"        Int64 = SLANG_SCALAR_TYPE_INT64,\n"
"        UInt64 = SLANG_SCALAR_TYPE_UINT64,\n"
"        Float16 = SLANG_SCALAR_TYPE_FLOAT16,\n"
"        Float32 = SLANG_SCALAR_TYPE_FLOAT32,\n"
"        Float64 = SLANG_SCALAR_TYPE_FLOAT64,\n"
"        Int8 = SLANG_SCALAR_TYPE_INT8,\n"
"        UInt8 = SLANG_SCALAR_TYPE_UINT8,\n"
"        Int16 = SLANG_SCALAR_TYPE_INT16,\n"
"        UInt16 = SLANG_SCALAR_TYPE_UINT16,\n"
"    };\n"
"\n"
"    Kind getKind() { return (Kind)spReflectionType_GetKind((SlangReflectionType*)this); }\n"
"\n"
"    // only useful if `getKind() == Kind::Struct`\n"
"    unsigned int getFieldCount()\n"
"    {\n"
"        return spReflectionType_GetFieldCount((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    VariableReflection* getFieldByIndex(unsigned int index)\n"
"    {\n"
"        return (\n"
"            VariableReflection*)spReflectionType_GetFieldByIndex((SlangReflectionType*)this, index);\n"
"    }\n"
"\n"
"    bool isArray() { return getKind() == TypeReflection::Kind::Array; }\n"
"\n"
"    TypeReflection* unwrapArray()\n"
"    {\n"
"        TypeReflection* type = this;\n"
"        while (type->isArray())\n"
"        {\n"
"            type = type->getElementType();\n"
"        }\n"
"        return type;\n"
"    }\n"
"\n"
"    // only useful if `getKind() == Kind::Array`\n"
"    size_t getElementCount(SlangReflection* reflection = nullptr)\n"
"    {\n"
"        return spReflectionType_GetSpecializedElementCount((SlangReflectionType*)this, reflection);\n"
"    }\n"
"\n"
"    size_t getTotalArrayElementCount()\n"
"    {\n"
"        if (!isArray())\n"
"            return 0;\n"
"        size_t result = 1;\n"
"        TypeReflection* type = this;\n"
"        for (;;)\n"
"        {\n"
"            if (!type->isArray())\n"
"                return result;\n"
"\n"
"            result *= type->getElementCount();\n"
"            type = type->getElementType();\n"
"        }\n"
"    }\n"
"\n"
"    TypeReflection* getElementType()\n"
"    {\n"
"        return (TypeReflection*)spReflectionType_GetElementType((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    unsigned getRowCount() { return spReflectionType_GetRowCount((SlangReflectionType*)this); }\n"
"\n"
"    unsigned getColumnCount()\n"
"    {\n"
"        return spReflectionType_GetColumnCount((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    ScalarType getScalarType()\n"
"    {\n"
"        return (ScalarType)spReflectionType_GetScalarType((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    TypeReflection* getResourceResultType()\n"
"    {\n"
"        return (TypeReflection*)spReflectionType_GetResourceResultType((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    SlangResourceShape getResourceShape()\n"
"    {\n"
"        return spReflectionType_GetResourceShape((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    SlangResourceAccess getResourceAccess()\n"
"    {\n"
"        return spReflectionType_GetResourceAccess((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    char const* getName() { return spReflectionType_GetName((SlangReflectionType*)this); }\n"
"\n"
"    SlangResult getFullName(ISlangBlob** outNameBlob)\n"
"    {\n"
"        return spReflectionType_GetFullName((SlangReflectionType*)this, outNameBlob);\n"
"    }\n"
"\n"
"    unsigned int getUserAttributeCount()\n"
"    {\n"
"        return spReflectionType_GetUserAttributeCount((SlangReflectionType*)this);\n"
"    }\n"
"\n"
"    UserAttribute* getUserAttributeByIndex(unsigned int index)\n"
"    {\n"
"        return (UserAttribute*)spReflectionType_GetUserAttribute((SlangReflectionType*)this, index);\n"
"    }\n"
"\n"
"    UserAttribute* findAttributeByName(char const* name)\n"
"    {\n"
"        return (UserAttribute*)spReflectionType_FindUserAttributeByName(\n"
"            (SlangReflectionType*)this,\n"
"            name);\n"
"    }\n"
"\n"
"    UserAttribute* findUserAttributeByName(char const* name) { return findAttributeByName(name); }\n"
"\n"
"    TypeReflection* applySpecializations(GenericReflection* generic)\n"
"    {\n"
"        return (TypeReflection*)spReflectionType_applySpecializations(\n"
"            (SlangReflectionType*)this,\n"
"            (SlangReflectionGeneric*)generic);\n"
"    }\n"
"\n"
"    GenericReflection* getGenericContainer()\n"
"    {\n"
"        return (GenericReflection*)spReflectionType_GetGenericContainer((SlangReflectionType*)this);\n"
"    }\n"
"};\n"
"\n"
"enum ParameterCategory : SlangParameterCategoryIntegral\n"
"{\n"
"    // TODO: these aren't scoped...\n"
"    None = SLANG_PARAMETER_CATEGORY_NONE,\n"
"    Mixed = SLANG_PARAMETER_CATEGORY_MIXED,\n"
"    ConstantBuffer = SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"    ShaderResource = SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE,\n"
"    UnorderedAccess = SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS,\n"
"    VaryingInput = SLANG_PARAMETER_CATEGORY_VARYING_INPUT,\n"
"    VaryingOutput = SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT,\n"
"    SamplerState = SLANG_PARAMETER_CATEGORY_SAMPLER_STATE,\n"
"    Uniform = SLANG_PARAMETER_CATEGORY_UNIFORM,\n"
"    DescriptorTableSlot = SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT,\n"
"    SpecializationConstant = SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT,\n"
"    PushConstantBuffer = SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER,\n"
"    RegisterSpace = SLANG_PARAMETER_CATEGORY_REGISTER_SPACE,\n"
"    GenericResource = SLANG_PARAMETER_CATEGORY_GENERIC,\n"
"\n"
"    RayPayload = SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD,\n"
"    HitAttributes = SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES,\n"
"    CallablePayload = SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD,\n"
"\n"
"    ShaderRecord = SLANG_PARAMETER_CATEGORY_SHADER_RECORD,\n"
"\n"
"    ExistentialTypeParam = SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM,\n"
"    ExistentialObjectParam = SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM,\n"
"\n"
"    SubElementRegisterSpace = SLANG_PARAMETER_CATEGORY_SUB_ELEMENT_REGISTER_SPACE,\n"
"\n"
"    InputAttachmentIndex = SLANG_PARAMETER_CATEGORY_SUBPASS,\n"
"\n"
"    MetalBuffer = SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER,\n"
"    MetalTexture = SLANG_PARAMETER_CATEGORY_METAL_TEXTURE,\n"
"    MetalArgumentBufferElement = SLANG_PARAMETER_CATEGORY_METAL_ARGUMENT_BUFFER_ELEMENT,\n"
"    MetalAttribute = SLANG_PARAMETER_CATEGORY_METAL_ATTRIBUTE,\n"
"    MetalPayload = SLANG_PARAMETER_CATEGORY_METAL_PAYLOAD,\n"
"\n"
"    // DEPRECATED:\n"
"    VertexInput = SLANG_PARAMETER_CATEGORY_VERTEX_INPUT,\n"
"    FragmentOutput = SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT,\n"
"};\n"
"\n"
"enum class BindingType : SlangBindingTypeIntegral\n"
"{\n"
"    Unknown = SLANG_BINDING_TYPE_UNKNOWN,\n"
"\n"
"    Sampler = SLANG_BINDING_TYPE_SAMPLER,\n"
"    Texture = SLANG_BINDING_TYPE_TEXTURE,\n"
"    ConstantBuffer = SLANG_BINDING_TYPE_CONSTANT_BUFFER,\n"
"    ParameterBlock = SLANG_BINDING_TYPE_PARAMETER_BLOCK,\n"
"    TypedBuffer = SLANG_BINDING_TYPE_TYPED_BUFFER,\n"
"    RawBuffer = SLANG_BINDING_TYPE_RAW_BUFFER,\n"
"    CombinedTextureSampler = SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER,\n"
"    InputRenderTarget = SLANG_BINDING_TYPE_INPUT_RENDER_TARGET,\n"
"    InlineUniformData = SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA,\n"
"    RayTracingAccelerationStructure = SLANG_BINDING_TYPE_RAY_TRACING_ACCELERATION_STRUCTURE,\n"
"    VaryingInput = SLANG_BINDING_TYPE_VARYING_INPUT,\n"
"    VaryingOutput = SLANG_BINDING_TYPE_VARYING_OUTPUT,\n"
"    ExistentialValue = SLANG_BINDING_TYPE_EXISTENTIAL_VALUE,\n"
"    PushConstant = SLANG_BINDING_TYPE_PUSH_CONSTANT,\n"
"\n"
"    MutableFlag = SLANG_BINDING_TYPE_MUTABLE_FLAG,\n"
"\n"
"    MutableTexture = SLANG_BINDING_TYPE_MUTABLE_TETURE,\n"
"    MutableTypedBuffer = SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER,\n"
"    MutableRawBuffer = SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER,\n"
"\n"
"    BaseMask = SLANG_BINDING_TYPE_BASE_MASK,\n"
"    ExtMask = SLANG_BINDING_TYPE_EXT_MASK,\n"
"};\n"
"\n"
"struct ShaderReflection;\n"
"\n"
"struct TypeLayoutReflection\n"
"{\n"
"    TypeReflection* getType()\n"
"    {\n"
"        return (TypeReflection*)spReflectionTypeLayout_GetType((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    TypeReflection::Kind getKind()\n"
"    {\n"
"        return (TypeReflection::Kind)spReflectionTypeLayout_getKind(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    size_t getSize(SlangParameterCategory category)\n"
"    {\n"
"        return spReflectionTypeLayout_GetSize((SlangReflectionTypeLayout*)this, category);\n"
"    }\n"
"\n"
"    size_t getStride(SlangParameterCategory category)\n"
"    {\n"
"        return spReflectionTypeLayout_GetStride((SlangReflectionTypeLayout*)this, category);\n"
"    }\n"
"\n"
"    int32_t getAlignment(SlangParameterCategory category)\n"
"    {\n"
"        return spReflectionTypeLayout_getAlignment((SlangReflectionTypeLayout*)this, category);\n"
"    }\n"
"\n"
"    size_t getSize(slang::ParameterCategory category = slang::ParameterCategory::Uniform)\n"
"    {\n"
"        return spReflectionTypeLayout_GetSize(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            (SlangParameterCategory)category);\n"
"    }\n"
"\n"
"    size_t getStride(slang::ParameterCategory category = slang::ParameterCategory::Uniform)\n"
"    {\n"
"        return spReflectionTypeLayout_GetStride(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            (SlangParameterCategory)category);\n"
"    }\n"
"\n"
"    int32_t getAlignment(slang::ParameterCategory category = slang::ParameterCategory::Uniform)\n"
"    {\n"
"        return spReflectionTypeLayout_getAlignment(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            (SlangParameterCategory)category);\n"
"    }\n"
"\n"
"\n"
"    unsigned int getFieldCount()\n"
"    {\n"
"        return spReflectionTypeLayout_GetFieldCount((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getFieldByIndex(unsigned int index)\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionTypeLayout_GetFieldByIndex(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangInt findFieldIndexByName(char const* nameBegin, char const* nameEnd = nullptr)\n"
"    {\n"
"        return spReflectionTypeLayout_findFieldIndexByName(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            nameBegin,\n"
"            nameEnd);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getExplicitCounter()\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionTypeLayout_GetExplicitCounter(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    bool isArray() { return getType()->isArray(); }\n"
"\n"
"    TypeLayoutReflection* unwrapArray()\n"
"    {\n"
"        TypeLayoutReflection* typeLayout = this;\n"
"        while (typeLayout->isArray())\n"
"        {\n"
"            typeLayout = typeLayout->getElementTypeLayout();\n"
"        }\n"
"        return typeLayout;\n"
"    }\n"
"\n"
"    // only useful if `getKind() == Kind::Array`\n"
"    size_t getElementCount(ShaderReflection* reflection = nullptr)\n"
"    {\n"
"        return getType()->getElementCount((SlangReflection*)reflection);\n"
"    }\n"
"\n"
"    size_t getTotalArrayElementCount() { return getType()->getTotalArrayElementCount(); }\n"
"\n"
"    size_t getElementStride(SlangParameterCategory category)\n"
"    {\n"
"        return spReflectionTypeLayout_GetElementStride((SlangReflectionTypeLayout*)this, category);\n"
"    }\n"
"\n"
"    TypeLayoutReflection* getElementTypeLayout()\n"
"    {\n"
"        return (TypeLayoutReflection*)spReflectionTypeLayout_GetElementTypeLayout(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getElementVarLayout()\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionTypeLayout_GetElementVarLayout(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getContainerVarLayout()\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionTypeLayout_getContainerVarLayout(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    // How is this type supposed to be bound?\n"
"    ParameterCategory getParameterCategory()\n"
"    {\n"
"        return (ParameterCategory)spReflectionTypeLayout_GetParameterCategory(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    unsigned int getCategoryCount()\n"
"    {\n"
"        return spReflectionTypeLayout_GetCategoryCount((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    ParameterCategory getCategoryByIndex(unsigned int index)\n"
"    {\n"
"        return (ParameterCategory)spReflectionTypeLayout_GetCategoryByIndex(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    unsigned getRowCount() { return getType()->getRowCount(); }\n"
"\n"
"    unsigned getColumnCount() { return getType()->getColumnCount(); }\n"
"\n"
"    TypeReflection::ScalarType getScalarType() { return getType()->getScalarType(); }\n"
"\n"
"    TypeReflection* getResourceResultType() { return getType()->getResourceResultType(); }\n"
"\n"
"    SlangResourceShape getResourceShape() { return getType()->getResourceShape(); }\n"
"\n"
"    SlangResourceAccess getResourceAccess() { return getType()->getResourceAccess(); }\n"
"\n"
"    char const* getName() { return getType()->getName(); }\n"
"\n"
"    SlangMatrixLayoutMode getMatrixLayoutMode()\n"
"    {\n"
"        return spReflectionTypeLayout_GetMatrixLayoutMode((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    int getGenericParamIndex()\n"
"    {\n"
"        return spReflectionTypeLayout_getGenericParamIndex((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    TypeLayoutReflection* getPendingDataTypeLayout()\n"
"    {\n"
"        return (TypeLayoutReflection*)spReflectionTypeLayout_getPendingDataTypeLayout(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getSpecializedTypePendingDataVarLayout()\n"
"    {\n"
"        return (VariableLayoutReflection*)\n"
"            spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout(\n"
"                (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    SlangInt getBindingRangeCount()\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeCount((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    BindingType getBindingRangeType(SlangInt index)\n"
"    {\n"
"        return (BindingType)spReflectionTypeLayout_getBindingRangeType(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    bool isBindingRangeSpecializable(SlangInt index)\n"
"    {\n"
"        return (bool)spReflectionTypeLayout_isBindingRangeSpecializable(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangInt getBindingRangeBindingCount(SlangInt index)\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeBindingCount(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    /*\n"
"    SlangInt getBindingRangeIndexOffset(SlangInt index)\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeIndexOffset(\n"
"            (SlangReflectionTypeLayout*) this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangInt getBindingRangeSpaceOffset(SlangInt index)\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeSpaceOffset(\n"
"            (SlangReflectionTypeLayout*) this,\n"
"            index);\n"
"    }\n"
"    */\n"
"\n"
"    SlangInt getFieldBindingRangeOffset(SlangInt fieldIndex)\n"
"    {\n"
"        return spReflectionTypeLayout_getFieldBindingRangeOffset(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            fieldIndex);\n"
"    }\n"
"\n"
"    SlangInt getExplicitCounterBindingRangeOffset()\n"
"    {\n"
"        return spReflectionTypeLayout_getExplicitCounterBindingRangeOffset(\n"
"            (SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    TypeLayoutReflection* getBindingRangeLeafTypeLayout(SlangInt index)\n"
"    {\n"
"        return (TypeLayoutReflection*)spReflectionTypeLayout_getBindingRangeLeafTypeLayout(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    VariableReflection* getBindingRangeLeafVariable(SlangInt index)\n"
"    {\n"
"        return (VariableReflection*)spReflectionTypeLayout_getBindingRangeLeafVariable(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangImageFormat getBindingRangeImageFormat(SlangInt index)\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeImageFormat(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangInt getBindingRangeDescriptorSetIndex(SlangInt index)\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeDescriptorSetIndex(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangInt getBindingRangeFirstDescriptorRangeIndex(SlangInt index)\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangInt getBindingRangeDescriptorRangeCount(SlangInt index)\n"
"    {\n"
"        return spReflectionTypeLayout_getBindingRangeDescriptorRangeCount(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangInt getDescriptorSetCount()\n"
"    {\n"
"        return spReflectionTypeLayout_getDescriptorSetCount((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
;
sb << 
"    SlangInt getDescriptorSetSpaceOffset(SlangInt setIndex)\n"
"    {\n"
"        return spReflectionTypeLayout_getDescriptorSetSpaceOffset(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            setIndex);\n"
"    }\n"
"\n"
"    SlangInt getDescriptorSetDescriptorRangeCount(SlangInt setIndex)\n"
"    {\n"
"        return spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            setIndex);\n"
"    }\n"
"\n"
"    SlangInt getDescriptorSetDescriptorRangeIndexOffset(SlangInt setIndex, SlangInt rangeIndex)\n"
"    {\n"
"        return spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            setIndex,\n"
"            rangeIndex);\n"
"    }\n"
"\n"
"    SlangInt getDescriptorSetDescriptorRangeDescriptorCount(SlangInt setIndex, SlangInt rangeIndex)\n"
"    {\n"
"        return spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            setIndex,\n"
"            rangeIndex);\n"
"    }\n"
"\n"
"    BindingType getDescriptorSetDescriptorRangeType(SlangInt setIndex, SlangInt rangeIndex)\n"
"    {\n"
"        return (BindingType)spReflectionTypeLayout_getDescriptorSetDescriptorRangeType(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            setIndex,\n"
"            rangeIndex);\n"
"    }\n"
"\n"
"    ParameterCategory getDescriptorSetDescriptorRangeCategory(\n"
"        SlangInt setIndex,\n"
"        SlangInt rangeIndex)\n"
"    {\n"
"        return (ParameterCategory)spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            setIndex,\n"
"            rangeIndex);\n"
"    }\n"
"\n"
"    SlangInt getSubObjectRangeCount()\n"
"    {\n"
"        return spReflectionTypeLayout_getSubObjectRangeCount((SlangReflectionTypeLayout*)this);\n"
"    }\n"
"\n"
"    SlangInt getSubObjectRangeBindingRangeIndex(SlangInt subObjectRangeIndex)\n"
"    {\n"
"        return spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            subObjectRangeIndex);\n"
"    }\n"
"\n"
"    SlangInt getSubObjectRangeSpaceOffset(SlangInt subObjectRangeIndex)\n"
"    {\n"
"        return spReflectionTypeLayout_getSubObjectRangeSpaceOffset(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            subObjectRangeIndex);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getSubObjectRangeOffset(SlangInt subObjectRangeIndex)\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionTypeLayout_getSubObjectRangeOffset(\n"
"            (SlangReflectionTypeLayout*)this,\n"
"            subObjectRangeIndex);\n"
"    }\n"
"};\n"
"\n"
"struct Modifier\n"
"{\n"
"    enum ID : SlangModifierIDIntegral\n"
"    {\n"
"        Shared = SLANG_MODIFIER_SHARED,\n"
"        NoDiff = SLANG_MODIFIER_NO_DIFF,\n"
"        Static = SLANG_MODIFIER_STATIC,\n"
"        Const = SLANG_MODIFIER_CONST,\n"
"        Export = SLANG_MODIFIER_EXPORT,\n"
"        Extern = SLANG_MODIFIER_EXTERN,\n"
"        Differentiable = SLANG_MODIFIER_DIFFERENTIABLE,\n"
"        Mutating = SLANG_MODIFIER_MUTATING,\n"
"        In = SLANG_MODIFIER_IN,\n"
"        Out = SLANG_MODIFIER_OUT,\n"
"        InOut = SLANG_MODIFIER_INOUT\n"
"    };\n"
"};\n"
"\n"
"struct VariableReflection\n"
"{\n"
"    char const* getName() { return spReflectionVariable_GetName((SlangReflectionVariable*)this); }\n"
"\n"
"    TypeReflection* getType()\n"
"    {\n"
"        return (TypeReflection*)spReflectionVariable_GetType((SlangReflectionVariable*)this);\n"
"    }\n"
"\n"
"    Modifier* findModifier(Modifier::ID id)\n"
"    {\n"
"        return (Modifier*)spReflectionVariable_FindModifier(\n"
"            (SlangReflectionVariable*)this,\n"
"            (SlangModifierID)id);\n"
"    }\n"
"\n"
"    unsigned int getUserAttributeCount()\n"
"    {\n"
"        return spReflectionVariable_GetUserAttributeCount((SlangReflectionVariable*)this);\n"
"    }\n"
"\n"
"    Attribute* getUserAttributeByIndex(unsigned int index)\n"
"    {\n"
"        return (UserAttribute*)spReflectionVariable_GetUserAttribute(\n"
"            (SlangReflectionVariable*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    Attribute* findAttributeByName(SlangSession* globalSession, char const* name)\n"
"    {\n"
"        return (UserAttribute*)spReflectionVariable_FindUserAttributeByName(\n"
"            (SlangReflectionVariable*)this,\n"
"            globalSession,\n"
"            name);\n"
"    }\n"
"\n"
"    Attribute* findUserAttributeByName(SlangSession* globalSession, char const* name)\n"
"    {\n"
"        return findAttributeByName(globalSession, name);\n"
"    }\n"
"\n"
"    bool hasDefaultValue()\n"
"    {\n"
"        return spReflectionVariable_HasDefaultValue((SlangReflectionVariable*)this);\n"
"    }\n"
"\n"
"    SlangResult getDefaultValueInt(int64_t* value)\n"
"    {\n"
"        return spReflectionVariable_GetDefaultValueInt((SlangReflectionVariable*)this, value);\n"
"    }\n"
"\n"
"    GenericReflection* getGenericContainer()\n"
"    {\n"
"        return (GenericReflection*)spReflectionVariable_GetGenericContainer(\n"
"            (SlangReflectionVariable*)this);\n"
"    }\n"
"\n"
"    VariableReflection* applySpecializations(GenericReflection* generic)\n"
"    {\n"
"        return (VariableReflection*)spReflectionVariable_applySpecializations(\n"
"            (SlangReflectionVariable*)this,\n"
"            (SlangReflectionGeneric*)generic);\n"
"    }\n"
"};\n"
"\n"
"struct VariableLayoutReflection\n"
"{\n"
"    VariableReflection* getVariable()\n"
"    {\n"
"        return (VariableReflection*)spReflectionVariableLayout_GetVariable(\n"
"            (SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    char const* getName() { return getVariable()->getName(); }\n"
"\n"
"    Modifier* findModifier(Modifier::ID id) { return getVariable()->findModifier(id); }\n"
"\n"
"    TypeLayoutReflection* getTypeLayout()\n"
"    {\n"
"        return (TypeLayoutReflection*)spReflectionVariableLayout_GetTypeLayout(\n"
"            (SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    ParameterCategory getCategory() { return getTypeLayout()->getParameterCategory(); }\n"
"\n"
"    unsigned int getCategoryCount() { return getTypeLayout()->getCategoryCount(); }\n"
"\n"
"    ParameterCategory getCategoryByIndex(unsigned int index)\n"
"    {\n"
"        return getTypeLayout()->getCategoryByIndex(index);\n"
"    }\n"
"\n"
"\n"
"    size_t getOffset(SlangParameterCategory category)\n"
"    {\n"
"        return spReflectionVariableLayout_GetOffset((SlangReflectionVariableLayout*)this, category);\n"
"    }\n"
"    size_t getOffset(slang::ParameterCategory category = slang::ParameterCategory::Uniform)\n"
"    {\n"
"        return spReflectionVariableLayout_GetOffset(\n"
"            (SlangReflectionVariableLayout*)this,\n"
"            (SlangParameterCategory)category);\n"
"    }\n"
"\n"
"\n"
"    TypeReflection* getType() { return getVariable()->getType(); }\n"
"\n"
"    unsigned getBindingIndex()\n"
"    {\n"
"        return spReflectionParameter_GetBindingIndex((SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    unsigned getBindingSpace()\n"
"    {\n"
"        return spReflectionParameter_GetBindingSpace((SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    size_t getBindingSpace(SlangParameterCategory category)\n"
"    {\n"
"        return spReflectionVariableLayout_GetSpace((SlangReflectionVariableLayout*)this, category);\n"
"    }\n"
"    size_t getBindingSpace(slang::ParameterCategory category)\n"
"    {\n"
"        return spReflectionVariableLayout_GetSpace(\n"
"            (SlangReflectionVariableLayout*)this,\n"
"            (SlangParameterCategory)category);\n"
"    }\n"
"\n"
"    SlangImageFormat getImageFormat()\n"
"    {\n"
"        return spReflectionVariableLayout_GetImageFormat((SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    char const* getSemanticName()\n"
"    {\n"
"        return spReflectionVariableLayout_GetSemanticName((SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    size_t getSemanticIndex()\n"
"    {\n"
"        return spReflectionVariableLayout_GetSemanticIndex((SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    SlangStage getStage()\n"
"    {\n"
"        return spReflectionVariableLayout_getStage((SlangReflectionVariableLayout*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getPendingDataLayout()\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionVariableLayout_getPendingDataLayout(\n"
"            (SlangReflectionVariableLayout*)this);\n"
"    }\n"
"};\n"
"\n"
"struct FunctionReflection\n"
"{\n"
"    char const* getName() { return spReflectionFunction_GetName((SlangReflectionFunction*)this); }\n"
"\n"
"    TypeReflection* getReturnType()\n"
"    {\n"
"        return (TypeReflection*)spReflectionFunction_GetResultType((SlangReflectionFunction*)this);\n"
"    }\n"
"\n"
"    unsigned int getParameterCount()\n"
"    {\n"
"        return spReflectionFunction_GetParameterCount((SlangReflectionFunction*)this);\n"
"    }\n"
"\n"
"    VariableReflection* getParameterByIndex(unsigned int index)\n"
"    {\n"
"        return (VariableReflection*)spReflectionFunction_GetParameter(\n"
"            (SlangReflectionFunction*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    unsigned int getUserAttributeCount()\n"
"    {\n"
"        return spReflectionFunction_GetUserAttributeCount((SlangReflectionFunction*)this);\n"
"    }\n"
"    Attribute* getUserAttributeByIndex(unsigned int index)\n"
"    {\n"
"        return (\n"
"            Attribute*)spReflectionFunction_GetUserAttribute((SlangReflectionFunction*)this, index);\n"
"    }\n"
"    Attribute* findAttributeByName(SlangSession* globalSession, char const* name)\n"
"    {\n"
"        return (Attribute*)spReflectionFunction_FindUserAttributeByName(\n"
"            (SlangReflectionFunction*)this,\n"
"            globalSession,\n"
"            name);\n"
"    }\n"
"    Attribute* findUserAttributeByName(SlangSession* globalSession, char const* name)\n"
"    {\n"
"        return findAttributeByName(globalSession, name);\n"
"    }\n"
"    Modifier* findModifier(Modifier::ID id)\n"
"    {\n"
"        return (Modifier*)spReflectionFunction_FindModifier(\n"
"            (SlangReflectionFunction*)this,\n"
"            (SlangModifierID)id);\n"
"    }\n"
"\n"
"    GenericReflection* getGenericContainer()\n"
"    {\n"
"        return (GenericReflection*)spReflectionFunction_GetGenericContainer(\n"
"            (SlangReflectionFunction*)this);\n"
"    }\n"
"\n"
"    FunctionReflection* applySpecializations(GenericReflection* generic)\n"
"    {\n"
"        return (FunctionReflection*)spReflectionFunction_applySpecializations(\n"
"            (SlangReflectionFunction*)this,\n"
"            (SlangReflectionGeneric*)generic);\n"
"    }\n"
"\n"
"    FunctionReflection* specializeWithArgTypes(unsigned int argCount, TypeReflection* const* types)\n"
"    {\n"
"        return (FunctionReflection*)spReflectionFunction_specializeWithArgTypes(\n"
"            (SlangReflectionFunction*)this,\n"
"            argCount,\n"
"            (SlangReflectionType* const*)types);\n"
"    }\n"
"\n"
"    bool isOverloaded()\n"
"    {\n"
"        return spReflectionFunction_isOverloaded((SlangReflectionFunction*)this);\n"
"    }\n"
"\n"
"    unsigned int getOverloadCount()\n"
"    {\n"
"        return spReflectionFunction_getOverloadCount((SlangReflectionFunction*)this);\n"
"    }\n"
"\n"
"    FunctionReflection* getOverload(unsigned int index)\n"
"    {\n"
"        return (FunctionReflection*)spReflectionFunction_getOverload(\n"
"            (SlangReflectionFunction*)this,\n"
"            index);\n"
"    }\n"
"};\n"
"\n"
"struct GenericReflection\n"
"{\n"
"\n"
"    DeclReflection* asDecl()\n"
"    {\n"
"        return (DeclReflection*)spReflectionGeneric_asDecl((SlangReflectionGeneric*)this);\n"
"    }\n"
"\n"
"    char const* getName() { return spReflectionGeneric_GetName((SlangReflectionGeneric*)this); }\n"
"\n"
"    unsigned int getTypeParameterCount()\n"
"    {\n"
"        return spReflectionGeneric_GetTypeParameterCount((SlangReflectionGeneric*)this);\n"
"    }\n"
"\n"
"    VariableReflection* getTypeParameter(unsigned index)\n"
"    {\n"
"        return (VariableReflection*)spReflectionGeneric_GetTypeParameter(\n"
"            (SlangReflectionGeneric*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    unsigned int getValueParameterCount()\n"
"    {\n"
"        return spReflectionGeneric_GetValueParameterCount((SlangReflectionGeneric*)this);\n"
"    }\n"
"\n"
"    VariableReflection* getValueParameter(unsigned index)\n"
"    {\n"
"        return (VariableReflection*)spReflectionGeneric_GetValueParameter(\n"
"            (SlangReflectionGeneric*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    unsigned int getTypeParameterConstraintCount(VariableReflection* typeParam)\n"
"    {\n"
"        return spReflectionGeneric_GetTypeParameterConstraintCount(\n"
"            (SlangReflectionGeneric*)this,\n"
"            (SlangReflectionVariable*)typeParam);\n"
"    }\n"
"\n"
"    TypeReflection* getTypeParameterConstraintType(VariableReflection* typeParam, unsigned index)\n"
"    {\n"
"        return (TypeReflection*)spReflectionGeneric_GetTypeParameterConstraintType(\n"
"            (SlangReflectionGeneric*)this,\n"
"            (SlangReflectionVariable*)typeParam,\n"
"            index);\n"
"    }\n"
"\n"
"    DeclReflection* getInnerDecl()\n"
"    {\n"
"        return (DeclReflection*)spReflectionGeneric_GetInnerDecl((SlangReflectionGeneric*)this);\n"
"    }\n"
"\n"
"    SlangDeclKind getInnerKind()\n"
"    {\n"
"        return spReflectionGeneric_GetInnerKind((SlangReflectionGeneric*)this);\n"
"    }\n"
"\n"
"    GenericReflection* getOuterGenericContainer()\n"
"    {\n"
"        return (GenericReflection*)spReflectionGeneric_GetOuterGenericContainer(\n"
"            (SlangReflectionGeneric*)this);\n"
"    }\n"
"\n"
"    TypeReflection* getConcreteType(VariableReflection* typeParam)\n"
"    {\n"
"        return (TypeReflection*)spReflectionGeneric_GetConcreteType(\n"
"            (SlangReflectionGeneric*)this,\n"
"            (SlangReflectionVariable*)typeParam);\n"
"    }\n"
"\n"
"    int64_t getConcreteIntVal(VariableReflection* valueParam)\n"
"    {\n"
"        return spReflectionGeneric_GetConcreteIntVal(\n"
"            (SlangReflectionGeneric*)this,\n"
"            (SlangReflectionVariable*)valueParam);\n"
"    }\n"
"\n"
"    GenericReflection* applySpecializations(GenericReflection* generic)\n"
"    {\n"
"        return (GenericReflection*)spReflectionGeneric_applySpecializations(\n"
"            (SlangReflectionGeneric*)this,\n"
"            (SlangReflectionGeneric*)generic);\n"
"    }\n"
"};\n"
"\n"
"struct EntryPointReflection\n"
"{\n"
"    char const* getName()\n"
"    {\n"
"        return spReflectionEntryPoint_getName((SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    char const* getNameOverride()\n"
"    {\n"
"        return spReflectionEntryPoint_getNameOverride((SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    unsigned getParameterCount()\n"
"    {\n"
"        return spReflectionEntryPoint_getParameterCount((SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    FunctionReflection* getFunction()\n"
"    {\n"
"        return (FunctionReflection*)spReflectionEntryPoint_getFunction(\n"
"            (SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getParameterByIndex(unsigned index)\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionEntryPoint_getParameterByIndex(\n"
"            (SlangReflectionEntryPoint*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    SlangStage getStage()\n"
"    {\n"
"        return spReflectionEntryPoint_getStage((SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    void getComputeThreadGroupSize(SlangUInt axisCount, SlangUInt* outSizeAlongAxis)\n"
"    {\n"
"        return spReflectionEntryPoint_getComputeThreadGroupSize(\n"
"            (SlangReflectionEntryPoint*)this,\n"
"            axisCount,\n"
"            outSizeAlongAxis);\n"
"    }\n"
"\n"
"    void getComputeWaveSize(SlangUInt* outWaveSize)\n"
"    {\n"
"        return spReflectionEntryPoint_getComputeWaveSize(\n"
"            (SlangReflectionEntryPoint*)this,\n"
"            outWaveSize);\n"
"    }\n"
"\n"
"    bool usesAnySampleRateInput()\n"
"    {\n"
"        return 0 != spReflectionEntryPoint_usesAnySampleRateInput((SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getVarLayout()\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionEntryPoint_getVarLayout(\n"
"            (SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    TypeLayoutReflection* getTypeLayout() { return getVarLayout()->getTypeLayout(); }\n"
"\n"
"    VariableLayoutReflection* getResultVarLayout()\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflectionEntryPoint_getResultVarLayout(\n"
"            (SlangReflectionEntryPoint*)this);\n"
"    }\n"
"\n"
"    bool hasDefaultConstantBuffer()\n"
"    {\n"
"        return spReflectionEntryPoint_hasDefaultConstantBuffer((SlangReflectionEntryPoint*)this) !=\n"
"               0;\n"
"    }\n"
"};\n"
"\n"
"typedef EntryPointReflection EntryPointLayout;\n"
"\n"
"struct TypeParameterReflection\n"
"{\n"
"    char const* getName()\n"
"    {\n"
"        return spReflectionTypeParameter_GetName((SlangReflectionTypeParameter*)this);\n"
"    }\n"
"    unsigned getIndex()\n"
"    {\n"
"        return spReflectionTypeParameter_GetIndex((SlangReflectionTypeParameter*)this);\n"
"    }\n"
"    unsigned getConstraintCount()\n"
"    {\n"
"        return spReflectionTypeParameter_GetConstraintCount((SlangReflectionTypeParameter*)this);\n"
"    }\n"
"    TypeReflection* getConstraintByIndex(int index)\n"
"    {\n"
"        return (TypeReflection*)spReflectionTypeParameter_GetConstraintByIndex(\n"
"            (SlangReflectionTypeParameter*)this,\n"
"            index);\n"
"    }\n"
"};\n"
"\n"
"enum class LayoutRules : SlangLayoutRulesIntegral\n"
"{\n"
"    Default = SLANG_LAYOUT_RULES_DEFAULT,\n"
"    MetalArgumentBufferTier2 = SLANG_LAYOUT_RULES_METAL_ARGUMENT_BUFFER_TIER_2,\n"
"};\n"
"\n"
"typedef struct ShaderReflection ProgramLayout;\n"
"typedef enum SlangReflectionGenericArgType GenericArgType;\n"
"\n"
"struct ShaderReflection\n"
"{\n"
"    unsigned getParameterCount() { return spReflection_GetParameterCount((SlangReflection*)this); }\n"
"\n"
"    unsigned getTypeParameterCount()\n"
"    {\n"
"        return spReflection_GetTypeParameterCount((SlangReflection*)this);\n"
"    }\n"
"\n"
"    slang::ISession* getSession() { return spReflection_GetSession((SlangReflection*)this); }\n"
"\n"
"    TypeParameterReflection* getTypeParameterByIndex(unsigned index)\n"
"    {\n"
"        return (TypeParameterReflection*)spReflection_GetTypeParameterByIndex(\n"
;
sb << 
"            (SlangReflection*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    TypeParameterReflection* findTypeParameter(char const* name)\n"
"    {\n"
"        return (\n"
"            TypeParameterReflection*)spReflection_FindTypeParameter((SlangReflection*)this, name);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getParameterByIndex(unsigned index)\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflection_GetParameterByIndex(\n"
"            (SlangReflection*)this,\n"
"            index);\n"
"    }\n"
"\n"
"    static ProgramLayout* get(SlangCompileRequest* request)\n"
"    {\n"
"        return (ProgramLayout*)spGetReflection(request);\n"
"    }\n"
"\n"
"    SlangUInt getEntryPointCount()\n"
"    {\n"
"        return spReflection_getEntryPointCount((SlangReflection*)this);\n"
"    }\n"
"\n"
"    EntryPointReflection* getEntryPointByIndex(SlangUInt index)\n"
"    {\n"
"        return (\n"
"            EntryPointReflection*)spReflection_getEntryPointByIndex((SlangReflection*)this, index);\n"
"    }\n"
"\n"
"    SlangUInt getGlobalConstantBufferBinding()\n"
"    {\n"
"        return spReflection_getGlobalConstantBufferBinding((SlangReflection*)this);\n"
"    }\n"
"\n"
"    size_t getGlobalConstantBufferSize()\n"
"    {\n"
"        return spReflection_getGlobalConstantBufferSize((SlangReflection*)this);\n"
"    }\n"
"\n"
"    TypeReflection* findTypeByName(const char* name)\n"
"    {\n"
"        return (TypeReflection*)spReflection_FindTypeByName((SlangReflection*)this, name);\n"
"    }\n"
"\n"
"    FunctionReflection* findFunctionByName(const char* name)\n"
"    {\n"
"        return (FunctionReflection*)spReflection_FindFunctionByName((SlangReflection*)this, name);\n"
"    }\n"
"\n"
"    FunctionReflection* findFunctionByNameInType(TypeReflection* type, const char* name)\n"
"    {\n"
"        return (FunctionReflection*)spReflection_FindFunctionByNameInType(\n"
"            (SlangReflection*)this,\n"
"            (SlangReflectionType*)type,\n"
"            name);\n"
"    }\n"
"\n"
"    SLANG_DEPRECATED FunctionReflection* tryResolveOverloadedFunction(\n"
"        uint32_t candidateCount,\n"
"        FunctionReflection** candidates)\n"
"    {\n"
"        return (FunctionReflection*)spReflection_TryResolveOverloadedFunction(\n"
"            (SlangReflection*)this,\n"
"            candidateCount,\n"
"            (SlangReflectionFunction**)candidates);\n"
"    }\n"
"\n"
"    VariableReflection* findVarByNameInType(TypeReflection* type, const char* name)\n"
"    {\n"
"        return (VariableReflection*)spReflection_FindVarByNameInType(\n"
"            (SlangReflection*)this,\n"
"            (SlangReflectionType*)type,\n"
"            name);\n"
"    }\n"
"\n"
"    TypeLayoutReflection* getTypeLayout(\n"
"        TypeReflection* type,\n"
"        LayoutRules rules = LayoutRules::Default)\n"
"    {\n"
"        return (TypeLayoutReflection*)spReflection_GetTypeLayout(\n"
"            (SlangReflection*)this,\n"
"            (SlangReflectionType*)type,\n"
"            SlangLayoutRules(rules));\n"
"    }\n"
"\n"
"    EntryPointReflection* findEntryPointByName(const char* name)\n"
"    {\n"
"        return (\n"
"            EntryPointReflection*)spReflection_findEntryPointByName((SlangReflection*)this, name);\n"
"    }\n"
"\n"
"    TypeReflection* specializeType(\n"
"        TypeReflection* type,\n"
"        SlangInt specializationArgCount,\n"
"        TypeReflection* const* specializationArgs,\n"
"        ISlangBlob** outDiagnostics)\n"
"    {\n"
"        return (TypeReflection*)spReflection_specializeType(\n"
"            (SlangReflection*)this,\n"
"            (SlangReflectionType*)type,\n"
"            specializationArgCount,\n"
"            (SlangReflectionType* const*)specializationArgs,\n"
"            outDiagnostics);\n"
"    }\n"
"\n"
"    GenericReflection* specializeGeneric(\n"
"        GenericReflection* generic,\n"
"        SlangInt specializationArgCount,\n"
"        GenericArgType const* specializationArgTypes,\n"
"        GenericArgReflection const* specializationArgVals,\n"
"        ISlangBlob** outDiagnostics)\n"
"    {\n"
"        return (GenericReflection*)spReflection_specializeGeneric(\n"
"            (SlangReflection*)this,\n"
"            (SlangReflectionGeneric*)generic,\n"
"            specializationArgCount,\n"
"            (SlangReflectionGenericArgType const*)specializationArgTypes,\n"
"            (SlangReflectionGenericArg const*)specializationArgVals,\n"
"            outDiagnostics);\n"
"    }\n"
"\n"
"    bool isSubType(TypeReflection* subType, TypeReflection* superType)\n"
"    {\n"
"        return spReflection_isSubType(\n"
"            (SlangReflection*)this,\n"
"            (SlangReflectionType*)subType,\n"
"            (SlangReflectionType*)superType);\n"
"    }\n"
"\n"
"    SlangUInt getHashedStringCount() const\n"
"    {\n"
"        return spReflection_getHashedStringCount((SlangReflection*)this);\n"
"    }\n"
"\n"
"    const char* getHashedString(SlangUInt index, size_t* outCount) const\n"
"    {\n"
"        return spReflection_getHashedString((SlangReflection*)this, index, outCount);\n"
"    }\n"
"\n"
"    TypeLayoutReflection* getGlobalParamsTypeLayout()\n"
"    {\n"
"        return (TypeLayoutReflection*)spReflection_getGlobalParamsTypeLayout(\n"
"            (SlangReflection*)this);\n"
"    }\n"
"\n"
"    VariableLayoutReflection* getGlobalParamsVarLayout()\n"
"    {\n"
"        return (VariableLayoutReflection*)spReflection_getGlobalParamsVarLayout(\n"
"            (SlangReflection*)this);\n"
"    }\n"
"\n"
"    SlangResult toJson(ISlangBlob** outBlob)\n"
"    {\n"
"        return spReflection_ToJson((SlangReflection*)this, nullptr, outBlob);\n"
"    }\n"
"};\n"
"\n"
"\n"
"struct DeclReflection\n"
"{\n"
"    enum class Kind\n"
"    {\n"
"        Unsupported = SLANG_DECL_KIND_UNSUPPORTED_FOR_REFLECTION,\n"
"        Struct = SLANG_DECL_KIND_STRUCT,\n"
"        Func = SLANG_DECL_KIND_FUNC,\n"
"        Module = SLANG_DECL_KIND_MODULE,\n"
"        Generic = SLANG_DECL_KIND_GENERIC,\n"
"        Variable = SLANG_DECL_KIND_VARIABLE,\n"
"        Namespace = SLANG_DECL_KIND_NAMESPACE,\n"
"    };\n"
"\n"
"    char const* getName() { return spReflectionDecl_getName((SlangReflectionDecl*)this); }\n"
"\n"
"    Kind getKind() { return (Kind)spReflectionDecl_getKind((SlangReflectionDecl*)this); }\n"
"\n"
"    unsigned int getChildrenCount()\n"
"    {\n"
"        return spReflectionDecl_getChildrenCount((SlangReflectionDecl*)this);\n"
"    }\n"
"\n"
"    DeclReflection* getChild(unsigned int index)\n"
"    {\n"
"        return (DeclReflection*)spReflectionDecl_getChild((SlangReflectionDecl*)this, index);\n"
"    }\n"
"\n"
"    TypeReflection* getType()\n"
"    {\n"
"        return (TypeReflection*)spReflection_getTypeFromDecl((SlangReflectionDecl*)this);\n"
"    }\n"
"\n"
"    VariableReflection* asVariable()\n"
"    {\n"
"        return (VariableReflection*)spReflectionDecl_castToVariable((SlangReflectionDecl*)this);\n"
"    }\n"
"\n"
"    FunctionReflection* asFunction()\n"
"    {\n"
"        return (FunctionReflection*)spReflectionDecl_castToFunction((SlangReflectionDecl*)this);\n"
"    }\n"
"\n"
"    GenericReflection* asGeneric()\n"
"    {\n"
"        return (GenericReflection*)spReflectionDecl_castToGeneric((SlangReflectionDecl*)this);\n"
"    }\n"
"\n"
"    DeclReflection* getParent()\n"
"    {\n"
"        return (DeclReflection*)spReflectionDecl_getParent((SlangReflectionDecl*)this);\n"
"    }\n"
"\n"
"    Modifier* findModifier(Modifier::ID id)\n"
"    {\n"
"        return (Modifier*)spReflectionDecl_findModifier(\n"
"            (SlangReflectionDecl*)this,\n"
"            (SlangModifierID)id);\n"
"    }\n"
"\n"
"    template<Kind K>\n"
"    struct FilteredList\n"
"    {\n"
"        unsigned int count;\n"
"        DeclReflection* parent;\n"
"\n"
"        struct FilteredIterator\n"
"        {\n"
"            DeclReflection* parent;\n"
"            unsigned int count;\n"
"            unsigned int index;\n"
"\n"
"            DeclReflection* operator*() { return parent->getChild(index); }\n"
"            void operator++()\n"
"            {\n"
"                index++;\n"
"                while (index < count && !(parent->getChild(index)->getKind() == K))\n"
"                {\n"
"                    index++;\n"
"                }\n"
"            }\n"
"            bool operator!=(FilteredIterator const& other) { return index != other.index; }\n"
"        };\n"
"\n"
"        // begin/end for range-based for that checks the kind\n"
"        FilteredIterator begin()\n"
"        {\n"
"            // Find the first child of the right kind\n"
"            unsigned int index = 0;\n"
"            while (index < count && !(parent->getChild(index)->getKind() == K))\n"
"            {\n"
"                index++;\n"
"            }\n"
"            return FilteredIterator{parent, count, index};\n"
"        }\n"
"\n"
"        FilteredIterator end() { return FilteredIterator{parent, count, count}; }\n"
"    };\n"
"\n"
"    template<Kind K>\n"
"    FilteredList<K> getChildrenOfKind()\n"
"    {\n"
"        return FilteredList<K>{getChildrenCount(), (DeclReflection*)this};\n"
"    }\n"
"\n"
"    struct IteratedList\n"
"    {\n"
"        unsigned int count;\n"
"        DeclReflection* parent;\n"
"\n"
"        struct Iterator\n"
"        {\n"
"            DeclReflection* parent;\n"
"            unsigned int count;\n"
"            unsigned int index;\n"
"\n"
"            DeclReflection* operator*() { return parent->getChild(index); }\n"
"            void operator++() { index++; }\n"
"            bool operator!=(Iterator const& other) { return index != other.index; }\n"
"        };\n"
"\n"
"        // begin/end for range-based for that checks the kind\n"
"        IteratedList::Iterator begin() { return IteratedList::Iterator{parent, count, 0}; }\n"
"        IteratedList::Iterator end() { return IteratedList::Iterator{parent, count, count}; }\n"
"    };\n"
"\n"
"    IteratedList getChildren() { return IteratedList{getChildrenCount(), (DeclReflection*)this}; }\n"
"};\n"
"\n"
"typedef uint32_t CompileCoreModuleFlags;\n"
"struct CompileCoreModuleFlag\n"
"{\n"
"    enum Enum : CompileCoreModuleFlags\n"
"    {\n"
"        WriteDocumentation = 0x1,\n"
"    };\n"
"};\n"
"\n"
"typedef ISlangBlob IBlob;\n"
"\n"
"struct IComponentType;\n"
"struct ITypeConformance;\n"
"struct IGlobalSession;\n"
"struct IModule;\n"
"\n"
"struct SessionDesc;\n"
"struct SpecializationArg;\n"
"struct TargetDesc;\n"
"\n"
"enum class BuiltinModuleName\n"
"{\n"
"    Core,\n"
"    GLSL\n"
"};\n"
"\n"
"/** A global session for interaction with the Slang library.\n"
"\n"
"An application may create and re-use a single global session across\n"
"multiple sessions, in order to amortize startups costs (in current\n"
"Slang this is mostly the cost of loading the Slang standard library).\n"
"\n"
"The global session is currently *not* thread-safe and objects created from\n"
"a single global session should only be used from a single thread at\n"
"a time.\n"
"*/\n"
"struct IGlobalSession : public ISlangUnknown\n"
"{\n"
"    SLANG_COM_INTERFACE(0xc140b5fd, 0xc78, 0x452e, {0xba, 0x7c, 0x1a, 0x1e, 0x70, 0xc7, 0xf7, 0x1c})\n"
"\n"
"    /** Create a new session for loading and compiling code.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    createSession(SessionDesc const& desc, ISession** outSession) = 0;\n"
"\n"
"    /** Look up the internal ID of a profile by its `name`.\n"
"\n"
"    Profile IDs are *not* guaranteed to be stable across versions\n"
"    of the Slang library, so clients are expected to look up\n"
"    profiles by name at runtime.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangProfileID SLANG_MCALL findProfile(char const* name) = 0;\n"
"\n"
"    /** Set the path that downstream compilers (aka back end compilers) will\n"
"    be looked from.\n"
"    @param passThrough Identifies the downstream compiler\n"
"    @param path The path to find the downstream compiler (shared library/dll/executable)\n"
"\n"
"    For back ends that are dlls/shared libraries, it will mean the path will\n"
"    be prefixed with the path when calls are made out to ISlangSharedLibraryLoader.\n"
"    For executables - it will look for executables along the path */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setDownstreamCompilerPath(SlangPassThrough passThrough, char const* path) = 0;\n"
"\n"
"    /** DEPRECATED: Use setLanguagePrelude\n"
"\n"
"    Set the 'prelude' for generated code for a 'downstream compiler'.\n"
"    @param passThrough The downstream compiler for generated code that will have the prelude applied\n"
"    to it.\n"
"    @param preludeText The text added pre-pended verbatim before the generated source\n"
"\n"
"    That for pass-through usage, prelude is not pre-pended, preludes are for code generation only.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setDownstreamCompilerPrelude(SlangPassThrough passThrough, const char* preludeText) = 0;\n"
"\n"
"    /** DEPRECATED: Use getLanguagePrelude\n"
"\n"
"    Get the 'prelude' for generated code for a 'downstream compiler'.\n"
"    @param passThrough The downstream compiler for generated code that will have the prelude applied\n"
"    to it.\n"
"    @param outPrelude  On exit holds a blob that holds the string of the prelude.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    getDownstreamCompilerPrelude(SlangPassThrough passThrough, ISlangBlob** outPrelude) = 0;\n"
"\n"
"    /** Get the build version 'tag' string. The string is the same as produced via `git describe\n"
"    --tags` for the project. If Slang is built separately from the automated build scripts the\n"
"    contents will by default be 'unknown'. Any string can be set by changing the contents of\n"
"    'slang-tag-version.h' file and recompiling the project.\n"
"\n"
"    This method will return exactly the same result as the free function spGetBuildTagString.\n"
"\n"
"    @return The build tag string\n"
"    */\n"
"    virtual SLANG_NO_THROW const char* SLANG_MCALL getBuildTagString() = 0;\n"
"\n"
"    /* For a given source language set the default compiler.\n"
"    If a default cannot be chosen (for example the target cannot be achieved by the default),\n"
"    the default will not be used.\n"
"\n"
"    @param sourceLanguage the source language\n"
"    @param defaultCompiler the default compiler for that language\n"
"    @return\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL setDefaultDownstreamCompiler(\n"
"        SlangSourceLanguage sourceLanguage,\n"
"        SlangPassThrough defaultCompiler) = 0;\n"
"\n"
"    /* For a source type get the default compiler\n"
"\n"
"    @param sourceLanguage the source language\n"
"    @return The downstream compiler for that source language */\n"
"    virtual SlangPassThrough SLANG_MCALL\n"
"    getDefaultDownstreamCompiler(SlangSourceLanguage sourceLanguage) = 0;\n"
"\n"
"    /* Set the 'prelude' placed before generated code for a specific language type.\n"
"\n"
"    @param sourceLanguage The language the prelude should be inserted on.\n"
"    @param preludeText The text added pre-pended verbatim before the generated source\n"
"\n"
"    Note! That for pass-through usage, prelude is not pre-pended, preludes are for code generation\n"
"    only.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setLanguagePrelude(SlangSourceLanguage sourceLanguage, const char* preludeText) = 0;\n"
"\n"
"    /** Get the 'prelude' associated with a specific source language.\n"
"    @param sourceLanguage The language the prelude should be inserted on.\n"
"    @param outPrelude  On exit holds a blob that holds the string of the prelude.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    getLanguagePrelude(SlangSourceLanguage sourceLanguage, ISlangBlob** outPrelude) = 0;\n"
"\n"
"    /** Create a compile request.\n"
"     */\n"
"    [[deprecated]] virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    createCompileRequest(slang::ICompileRequest** outCompileRequest) = 0;\n"
"\n"
"    /** Add new builtin declarations to be used in subsequent compiles.\n"
"     */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    addBuiltins(char const* sourcePath, char const* sourceString) = 0;\n"
"\n"
"    /** Set the session shared library loader. If this changes the loader, it may cause shared\n"
"    libraries to be unloaded\n"
"    @param loader The loader to set. Setting nullptr sets the default loader.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    setSharedLibraryLoader(ISlangSharedLibraryLoader* loader) = 0;\n"
"\n"
"    /** Gets the currently set shared library loader\n"
"    @return Gets the currently set loader. If returns nullptr, it's the default loader\n"
"    */\n"
"    virtual SLANG_NO_THROW ISlangSharedLibraryLoader* SLANG_MCALL getSharedLibraryLoader() = 0;\n"
"\n"
"    /** Returns SLANG_OK if the compilation target is supported for this session\n"
"\n"
"    @param target The compilation target to test\n"
"    @return SLANG_OK if the target is available\n"
"    SLANG_E_NOT_IMPLEMENTED if not implemented in this build\n"
"    SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work\n"
"    could not be found SLANG_FAIL other kinds of failures */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    checkCompileTargetSupport(SlangCompileTarget target) = 0;\n"
"\n"
"    /** Returns SLANG_OK if the pass through support is supported for this session\n"
"    @param session Session\n"
"    @param target The compilation target to test\n"
"    @return SLANG_OK if the target is available\n"
"    SLANG_E_NOT_IMPLEMENTED if not implemented in this build\n"
"    SLANG_E_NOT_FOUND if other resources (such as shared libraries) required to make target work\n"
"    could not be found SLANG_FAIL other kinds of failures */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    checkPassThroughSupport(SlangPassThrough passThrough) = 0;\n"
"\n"
"    /** Compile from (embedded source) the core module on the session.\n"
"    Will return a failure if there is already a core module available\n"
"    NOTE! API is experimental and not ready for production code\n"
"    @param flags to control compilation\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    compileCoreModule(CompileCoreModuleFlags flags) = 0;\n"
"\n"
"    /** Load the core module. Currently loads modules from the file system.\n"
"    @param coreModule Start address of the serialized core module\n"
"    @param coreModuleSizeInBytes The size in bytes of the serialized core module\n"
"\n"
"    NOTE! API is experimental and not ready for production code\n"
"    */\n"
;
sb << 
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    loadCoreModule(const void* coreModule, size_t coreModuleSizeInBytes) = 0;\n"
"\n"
"    /** Save the core module to the file system\n"
"    @param archiveType The type of archive used to hold the core module\n"
"    @param outBlob The serialized blob containing the core module\n"
"\n"
"    NOTE! API is experimental and not ready for production code  */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    saveCoreModule(SlangArchiveType archiveType, ISlangBlob** outBlob) = 0;\n"
"\n"
"    /** Look up the internal ID of a capability by its `name`.\n"
"\n"
"    Capability IDs are *not* guaranteed to be stable across versions\n"
"    of the Slang library, so clients are expected to look up\n"
"    capabilities by name at runtime.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangCapabilityID SLANG_MCALL findCapability(char const* name) = 0;\n"
"\n"
"    /** Set the downstream/pass through compiler to be used for a transition from the source type to\n"
"    the target type\n"
"    @param source The source 'code gen target'\n"
"    @param target The target 'code gen target'\n"
"    @param compiler The compiler/pass through to use for the transition from source to target\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setDownstreamCompilerForTransition(\n"
"        SlangCompileTarget source,\n"
"        SlangCompileTarget target,\n"
"        SlangPassThrough compiler) = 0;\n"
"\n"
"    /** Get the downstream/pass through compiler for a transition specified by source and target\n"
"    @param source The source 'code gen target'\n"
"    @param target The target 'code gen target'\n"
"    @return The compiler that is used for the transition. Returns SLANG_PASS_THROUGH_NONE it is not\n"
"    defined\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangPassThrough SLANG_MCALL\n"
"    getDownstreamCompilerForTransition(SlangCompileTarget source, SlangCompileTarget target) = 0;\n"
"\n"
"    /** Get the time in seconds spent in the slang and downstream compiler.\n"
"     */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    getCompilerElapsedTime(double* outTotalTime, double* outDownstreamTime) = 0;\n"
"\n"
"    /** Specify a spirv.core.grammar.json file to load and use when\n"
"     * parsing and checking any SPIR-V code\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL setSPIRVCoreGrammar(char const* jsonPath) = 0;\n"
"\n"
"    /** Parse slangc command line options into a SessionDesc that can be used to create a session\n"
"     *   with all the compiler options specified in the command line.\n"
"     *   @param argc The number of command line arguments.\n"
"     *   @param argv An input array of command line arguments to parse.\n"
"     *   @param outSessionDesc A pointer to a SessionDesc struct to receive parsed session desc.\n"
"     *   @param outAuxAllocation Auxiliary memory allocated to hold data used in the session desc.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL parseCommandLineArguments(\n"
"        int argc,\n"
"        const char* const* argv,\n"
"        SessionDesc* outSessionDesc,\n"
"        ISlangUnknown** outAuxAllocation) = 0;\n"
"\n"
"    /** Computes a digest that uniquely identifies the session description.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getSessionDescDigest(SessionDesc* sessionDesc, ISlangBlob** outBlob) = 0;\n"
"\n"
"    /** Compile from (embedded source) the builtin module on the session.\n"
"    Will return a failure if there is already a builtin module available.\n"
"    NOTE! API is experimental and not ready for production code.\n"
"    @param module The builtin module name.\n"
"    @param flags to control compilation\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    compileBuiltinModule(BuiltinModuleName module, CompileCoreModuleFlags flags) = 0;\n"
"\n"
"    /** Load a builtin module. Currently loads modules from the file system.\n"
"    @param module The builtin module name\n"
"    @param moduleData Start address of the serialized core module\n"
"    @param sizeInBytes The size in bytes of the serialized builtin module\n"
"\n"
"    NOTE! API is experimental and not ready for production code\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    loadBuiltinModule(BuiltinModuleName module, const void* moduleData, size_t sizeInBytes) = 0;\n"
"\n"
"    /** Save the builtin module to the file system\n"
"    @param module The builtin module name\n"
"    @param archiveType The type of archive used to hold the builtin module\n"
"    @param outBlob The serialized blob containing the builtin module\n"
"\n"
"    NOTE! API is experimental and not ready for production code  */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL saveBuiltinModule(\n"
"        BuiltinModuleName module,\n"
"        SlangArchiveType archiveType,\n"
"        ISlangBlob** outBlob) = 0;\n"
"};\n"
"\n"
"    #define SLANG_UUID_IGlobalSession IGlobalSession::getTypeGuid()\n"
"\n"
"/** Description of a code generation target.\n"
" */\n"
"struct TargetDesc\n"
"{\n"
"    /** The size of this structure, in bytes.\n"
"     */\n"
"    size_t structureSize = sizeof(TargetDesc);\n"
"\n"
"    /** The target format to generate code for (e.g., SPIR-V, DXIL, etc.)\n"
"     */\n"
"    SlangCompileTarget format = SLANG_TARGET_UNKNOWN;\n"
"\n"
"    /** The compilation profile supported by the target (e.g., \"Shader Model 5.1\")\n"
"     */\n"
"    SlangProfileID profile = SLANG_PROFILE_UNKNOWN;\n"
"\n"
"    /** Flags for the code generation target. Currently unused. */\n"
"    SlangTargetFlags flags = kDefaultTargetFlags;\n"
"\n"
"    /** Default mode to use for floating-point operations on the target.\n"
"     */\n"
"    SlangFloatingPointMode floatingPointMode = SLANG_FLOATING_POINT_MODE_DEFAULT;\n"
"\n"
"    /** The line directive mode for output source code.\n"
"     */\n"
"    SlangLineDirectiveMode lineDirectiveMode = SLANG_LINE_DIRECTIVE_MODE_DEFAULT;\n"
"\n"
"    /** Whether to force `scalar` layout for glsl shader storage buffers.\n"
"     */\n"
"    bool forceGLSLScalarBufferLayout = false;\n"
"\n"
"    /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.\n"
"     */\n"
"    const CompilerOptionEntry* compilerOptionEntries = nullptr;\n"
"\n"
"    /** Number of additional compiler option entries.\n"
"     */\n"
"    uint32_t compilerOptionEntryCount = 0;\n"
"};\n"
"\n"
"typedef uint32_t SessionFlags;\n"
"enum\n"
"{\n"
"    kSessionFlags_None = 0\n"
"};\n"
"\n"
"struct PreprocessorMacroDesc\n"
"{\n"
"    const char* name;\n"
"    const char* value;\n"
"};\n"
"\n"
"struct SessionDesc\n"
"{\n"
"    /** The size of this structure, in bytes.\n"
"     */\n"
"    size_t structureSize = sizeof(SessionDesc);\n"
"\n"
"    /** Code generation targets to include in the session.\n"
"     */\n"
"    TargetDesc const* targets = nullptr;\n"
"    SlangInt targetCount = 0;\n"
"\n"
"    /** Flags to configure the session.\n"
"     */\n"
"    SessionFlags flags = kSessionFlags_None;\n"
"\n"
"    /** Default layout to assume for variables with matrix types.\n"
"     */\n"
"    SlangMatrixLayoutMode defaultMatrixLayoutMode = SLANG_MATRIX_LAYOUT_ROW_MAJOR;\n"
"\n"
"    /** Paths to use when searching for `#include`d or `import`ed files.\n"
"     */\n"
"    char const* const* searchPaths = nullptr;\n"
"    SlangInt searchPathCount = 0;\n"
"\n"
"    PreprocessorMacroDesc const* preprocessorMacros = nullptr;\n"
"    SlangInt preprocessorMacroCount = 0;\n"
"\n"
"    ISlangFileSystem* fileSystem = nullptr;\n"
"\n"
"    bool enableEffectAnnotations = false;\n"
"    bool allowGLSLSyntax = false;\n"
"\n"
"    /** Pointer to an array of compiler option entries, whose size is compilerOptionEntryCount.\n"
"     */\n"
"    CompilerOptionEntry* compilerOptionEntries = nullptr;\n"
"\n"
"    /** Number of additional compiler option entries.\n"
"     */\n"
"    uint32_t compilerOptionEntryCount = 0;\n"
"\n"
"    /** Whether to skip SPIRV validation.\n"
"     */\n"
"    bool skipSPIRVValidation = false;\n"
"};\n"
"\n"
"enum class ContainerType\n"
"{\n"
"    None,\n"
"    UnsizedArray,\n"
"    StructuredBuffer,\n"
"    ConstantBuffer,\n"
"    ParameterBlock\n"
"};\n"
"\n"
"/** A session provides a scope for code that is loaded.\n"
"\n"
"A session can be used to load modules of Slang source code,\n"
"and to request target-specific compiled binaries and layout\n"
"information.\n"
"\n"
"In order to be able to load code, the session owns a set\n"
"of active \"search paths\" for resolving `#include` directives\n"
"and `import` declarations, as well as a set of global\n"
"preprocessor definitions that will be used for all code\n"
"that gets `import`ed in the session.\n"
"\n"
"If multiple user shaders are loaded in the same session,\n"
"and import the same module (e.g., two source files do `import X`)\n"
"then there will only be one copy of `X` loaded within the session.\n"
"\n"
"In order to be able to generate target code, the session\n"
"owns a list of available compilation targets, which specify\n"
"code generation options.\n"
"\n"
"Code loaded and compiled within a session is owned by the session\n"
"and will remain resident in memory until the session is released.\n"
"Applications wishing to control the memory usage for compiled\n"
"and loaded code should use multiple sessions.\n"
"*/\n"
"struct ISession : public ISlangUnknown\n"
"{\n"
"    SLANG_COM_INTERFACE(0x67618701, 0xd116, 0x468f, {0xab, 0x3b, 0x47, 0x4b, 0xed, 0xce, 0xe, 0x3d})\n"
"\n"
"    /** Get the global session thas was used to create this session.\n"
"     */\n"
"    virtual SLANG_NO_THROW IGlobalSession* SLANG_MCALL getGlobalSession() = 0;\n"
"\n"
"    /** Load a module as it would be by code using `import`.\n"
"     */\n"
"    virtual SLANG_NO_THROW IModule* SLANG_MCALL\n"
"    loadModule(const char* moduleName, IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Load a module from Slang source code.\n"
"     */\n"
"    virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModuleFromSource(\n"
"        const char* moduleName,\n"
"        const char* path,\n"
"        slang::IBlob* source,\n"
"        slang::IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Combine multiple component types to create a composite component type.\n"
"\n"
"    The `componentTypes` array must contain `componentTypeCount` pointers\n"
"    to component types that were loaded or created using the same session.\n"
"\n"
"    The shader parameters and specialization parameters of the composite will\n"
"    be the union of those in `componentTypes`. The relative order of child\n"
"    component types is significant, and will affect the order in which\n"
"    parameters are reflected and laid out.\n"
"\n"
"    The entry-point functions of the composite will be the union of those in\n"
"    `componentTypes`, and will follow the ordering of `componentTypes`.\n"
"\n"
"    The requirements of the composite component type will be a subset of\n"
"    those in `componentTypes`. If an entry in `componentTypes` has a requirement\n"
"    that can be satisfied by another entry, then the composition will\n"
"    satisfy the requirement and it will not appear as a requirement of\n"
"    the composite. If multiple entries in `componentTypes` have a requirement\n"
"    for the same type, then only the first such requirement will be retained\n"
"    on the composite. The relative ordering of requirements on the composite\n"
"    will otherwise match that of `componentTypes`.\n"
"\n"
"    If any diagnostics are generated during creation of the composite, they\n"
"    will be written to `outDiagnostics`. If an error is encountered, the\n"
"    function will return null.\n"
"\n"
"    It is an error to create a composite component type that recursively\n"
"    aggregates a single module more than once.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL createCompositeComponentType(\n"
"        IComponentType* const* componentTypes,\n"
"        SlangInt componentTypeCount,\n"
"        IComponentType** outCompositeComponentType,\n"
"        ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Specialize a type based on type arguments.\n"
"     */\n"
"    virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL specializeType(\n"
"        TypeReflection* type,\n"
"        SpecializationArg const* specializationArgs,\n"
"        SlangInt specializationArgCount,\n"
"        ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"\n"
"    /** Get the layout `type` on the chosen `target`.\n"
"     */\n"
"    virtual SLANG_NO_THROW TypeLayoutReflection* SLANG_MCALL getTypeLayout(\n"
"        TypeReflection* type,\n"
"        SlangInt targetIndex = 0,\n"
"        LayoutRules rules = LayoutRules::Default,\n"
"        ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Get a container type from `elementType`. For example, given type `T`, returns\n"
"        a type that represents `StructuredBuffer<T>`.\n"
"\n"
"        @param `elementType`: the element type to wrap around.\n"
"        @param `containerType`: the type of the container to wrap `elementType` in.\n"
"        @param `outDiagnostics`: a blob to receive diagnostic messages.\n"
"    */\n"
"    virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL getContainerType(\n"
"        TypeReflection* elementType,\n"
"        ContainerType containerType,\n"
"        ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Return a `TypeReflection` that represents the `__Dynamic` type.\n"
"        This type can be used as a specialization argument to indicate using\n"
"        dynamic dispatch.\n"
"    */\n"
"    virtual SLANG_NO_THROW TypeReflection* SLANG_MCALL getDynamicType() = 0;\n"
"\n"
"    /** Get the mangled name for a type RTTI object.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getTypeRTTIMangledName(TypeReflection* type, ISlangBlob** outNameBlob) = 0;\n"
"\n"
"    /** Get the mangled name for a type witness.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessMangledName(\n"
"        TypeReflection* type,\n"
"        TypeReflection* interfaceType,\n"
"        ISlangBlob** outNameBlob) = 0;\n"
"\n"
"    /** Get the sequential ID used to identify a type witness in a dynamic object.\n"
"        The sequential ID is part of the RTTI bytes returned by `getDynamicObjectRTTIBytes`.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTypeConformanceWitnessSequentialID(\n"
"        slang::TypeReflection* type,\n"
"        slang::TypeReflection* interfaceType,\n"
"        uint32_t* outId) = 0;\n"
"\n"
"    /** Create a request to load/compile front-end code.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    createCompileRequest(SlangCompileRequest** outCompileRequest) = 0;\n"
"\n"
"\n"
"    /** Creates a `IComponentType` that represents a type's conformance to an interface.\n"
"        The retrieved `ITypeConformance` objects can be included in a composite `IComponentType`\n"
"        to explicitly specify which implementation types should be included in the final compiled\n"
"        code. For example, if an module defines `IMaterial` interface and `AMaterial`,\n"
"        `BMaterial`, `CMaterial` types that implements the interface, the user can exclude\n"
"        `CMaterial` implementation from the resulting shader code by explicitly adding\n"
"        `AMaterial:IMaterial` and `BMaterial:IMaterial` conformances to a composite\n"
"        `IComponentType` and get entry point code from it. The resulting code will not have\n"
"        anything related to `CMaterial` in the dynamic dispatch logic. If the user does not\n"
"        explicitly include any `TypeConformances` to an interface type, all implementations to\n"
"        that interface will be included by default. By linking a `ITypeConformance`, the user is\n"
"        also given the opportunity to specify the dispatch ID of the implementation type. If\n"
"        `conformanceIdOverride` is -1, there will be no override behavior and Slang will\n"
"        automatically assign IDs to implementation types. The automatically assigned IDs can be\n"
"        queried via `ISession::getTypeConformanceWitnessSequentialID`.\n"
"\n"
"        Returns SLANG_OK if succeeds, or SLANG_FAIL if `type` does not conform to `interfaceType`.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL createTypeConformanceComponentType(\n"
"        slang::TypeReflection* type,\n"
"        slang::TypeReflection* interfaceType,\n"
"        ITypeConformance** outConformance,\n"
"        SlangInt conformanceIdOverride,\n"
"        ISlangBlob** outDiagnostics) = 0;\n"
"\n"
"    /** Load a module from a Slang module blob.\n"
"     */\n"
"    virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModuleFromIRBlob(\n"
"        const char* moduleName,\n"
"        const char* path,\n"
"        slang::IBlob* source,\n"
"        slang::IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangInt SLANG_MCALL getLoadedModuleCount() = 0;\n"
"    virtual SLANG_NO_THROW IModule* SLANG_MCALL getLoadedModule(SlangInt index) = 0;\n"
"\n"
"    /** Checks if a precompiled binary module is up-to-date with the current compiler\n"
"     *   option settings and the source file contents.\n"
"     */\n"
"    virtual SLANG_NO_THROW bool SLANG_MCALL\n"
"    isBinaryModuleUpToDate(const char* modulePath, slang::IBlob* binaryModuleBlob) = 0;\n"
"\n"
"    /** Load a module from a string.\n"
"     */\n"
"    virtual SLANG_NO_THROW IModule* SLANG_MCALL loadModuleFromSourceString(\n"
"        const char* moduleName,\n"
"        const char* path,\n"
"        const char* string,\n"
"        slang::IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"\n"
"    /** Get the 16-byte RTTI header to fill into a dynamic object.\n"
"        This header is used to identify the type of the object for dynamic dispatch purpose.\n"
"        For example, given the following shader:\n"
"\n"
"        ```slang\n"
"        [anyValueSize(32)] dyn interface IFoo { int eval(); }\n"
"        struct Impl : IFoo { int eval() { return 1; } }\n"
"\n"
"        ConstantBuffer<dyn IFoo> cb0;\n"
"\n"
"        [numthreads(1,1,1)\n"
"        void main()\n"
"        {\n"
"            cb0.eval();\n"
"        }\n"
"        ```\n"
"\n"
;
sb << 
"        The constant buffer `cb0` should be filled with 16+32=48 bytes of data, where the first\n"
"        16 bytes should be the RTTI bytes returned by calling `getDynamicObjectRTTIBytes(type_Impl,\n"
"        type_IFoo)`, and the rest 32 bytes should hold the actual data of the dynamic object (in\n"
"        this case, fields in the `Impl` type).\n"
"\n"
"        `bufferSizeInBytes` must be greater than 16.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getDynamicObjectRTTIBytes(\n"
"        slang::TypeReflection* type,\n"
"        slang::TypeReflection* interfaceType,\n"
"        uint32_t* outRTTIDataBuffer,\n"
"        uint32_t bufferSizeInBytes) = 0;\n"
"\n"
"    /** Read module info (name and version) from a module blob\n"
"     *\n"
"     * The returned pointers are valid for as long as the session.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadModuleInfoFromIRBlob(\n"
"        slang::IBlob* source,\n"
"        SlangInt& outModuleVersion,\n"
"        const char*& outModuleCompilerVersion,\n"
"        const char*& outModuleName) = 0;\n"
"};\n"
"\n"
"    #define SLANG_UUID_ISession ISession::getTypeGuid()\n"
"\n"
"struct IMetadata : public ISlangCastable\n"
"{\n"
"    SLANG_COM_INTERFACE(0x8044a8a3, 0xddc0, 0x4b7f, {0xaf, 0x8e, 0x2, 0x6e, 0x90, 0x5d, 0x73, 0x32})\n"
"\n"
"    /*\n"
"    Returns whether a resource parameter at the specified binding location is actually being used\n"
"    in the compiled shader.\n"
"    */\n"
"    virtual SlangResult isParameterLocationUsed(\n"
"        SlangParameterCategory category, // is this a `t` register? `s` register?\n"
"        SlangUInt spaceIndex,            // `space` for D3D12, `set` for Vulkan\n"
"        SlangUInt registerIndex,         // `register` for D3D12, `binding` for Vulkan\n"
"        bool& outUsed) = 0;\n"
"\n"
"    /*\n"
"    Returns the debug build identifier for a base and debug spirv pair.\n"
"    */\n"
"    virtual const char* SLANG_MCALL getDebugBuildIdentifier() = 0;\n"
"};\n"
"    #define SLANG_UUID_IMetadata IMetadata::getTypeGuid()\n"
"\n"
"/** Compile result for storing and retrieving multiple output blobs.\n"
"    This is needed for features such as separate debug compilation which\n"
"    output both base and debug spirv.\n"
" */\n"
"struct ICompileResult : public ISlangCastable\n"
"{\n"
"    SLANG_COM_INTERFACE(\n"
"        0x5fa9380e,\n"
"        0xb62f,\n"
"        0x41e5,\n"
"        {0x9f, 0x12, 0x4b, 0xad, 0x4d, 0x9e, 0xaa, 0xe4})\n"
"\n"
"    virtual uint32_t SLANG_MCALL getItemCount() = 0;\n"
"    virtual SlangResult SLANG_MCALL getItemData(uint32_t index, IBlob** outblob) = 0;\n"
"    virtual SlangResult SLANG_MCALL getMetadata(IMetadata** outMetadata) = 0;\n"
"};\n"
"    #define SLANG_UUID_ICompileResult ICompileResult::getTypeGuid()\n"
"\n"
"/** A component type is a unit of shader code layout, reflection, and linking.\n"
"\n"
"A component type is a unit of shader code that can be included into\n"
"a linked and compiled shader program. Each component type may have:\n"
"\n"
"* Zero or more uniform shader parameters, representing textures,\n"
"  buffers, etc. that the code in the component depends on.\n"
"\n"
"* Zero or more *specialization* parameters, which are type or\n"
"  value parameters that can be used to synthesize specialized\n"
"  versions of the component type.\n"
"\n"
"* Zero or more entry points, which are the individually invocable\n"
"  kernels that can have final code generated.\n"
"\n"
"* Zero or more *requirements*, which are other component\n"
"  types on which the component type depends.\n"
"\n"
"One example of a component type is a module of Slang code:\n"
"\n"
"* The global-scope shader parameters declared in the module are\n"
"  the parameters when considered as a component type.\n"
"\n"
"* Any global-scope generic or interface type parameters introduce\n"
"  specialization parameters for the module.\n"
"\n"
"* A module does not by default include any entry points when\n"
"  considered as a component type (although the code of the\n"
"  module might *declare* some entry points).\n"
"\n"
"* Any other modules that are `import`ed in the source code\n"
"  become requirements of the module, when considered as a\n"
"  component type.\n"
"\n"
"An entry point is another example of a component type:\n"
"\n"
"* The `uniform` parameters of the entry point function are\n"
"  its shader parameters when considered as a component type.\n"
"\n"
"* Any generic or interface-type parameters of the entry point\n"
"  introduce specialization parameters.\n"
"\n"
"* An entry point component type exposes a single entry point (itself).\n"
"\n"
"* An entry point has one requirement for the module in which\n"
"  it was defined.\n"
"\n"
"Component types can be manipulated in a few ways:\n"
"\n"
"* Multiple component types can be combined into a composite, which\n"
"  combines all of their code, parameters, etc.\n"
"\n"
"* A component type can be specialized, by \"plugging in\" types and\n"
"  values for its specialization parameters.\n"
"\n"
"* A component type can be laid out for a particular target, giving\n"
"  offsets/bindings to the shader parameters it contains.\n"
"\n"
"* Generated kernel code can be requested for entry points.\n"
"\n"
"*/\n"
"struct IComponentType : public ISlangUnknown\n"
"{\n"
"    SLANG_COM_INTERFACE(0x5bc42be8, 0x5c50, 0x4929, {0x9e, 0x5e, 0xd1, 0x5e, 0x7c, 0x24, 0x1, 0x5f})\n"
"\n"
"    /** Get the runtime session that this component type belongs to.\n"
"     */\n"
"    virtual SLANG_NO_THROW ISession* SLANG_MCALL getSession() = 0;\n"
"\n"
"    /** Get the layout for this program for the chosen `targetIndex`.\n"
"\n"
"    The resulting layout will establish offsets/bindings for all\n"
"    of the global and entry-point shader parameters in the\n"
"    component type.\n"
"\n"
"    If this component type has specialization parameters (that is,\n"
"    it is not fully specialized), then the resulting layout may\n"
"    be incomplete, and plugging in arguments for generic specialization\n"
"    parameters may result in a component type that doesn't have\n"
"    a compatible layout. If the component type only uses\n"
"    interface-type specialization parameters, then the layout\n"
"    for a specialization should be compatible with an unspecialized\n"
"    layout (all parameters in the unspecialized layout will have\n"
"    the same offset/binding in the specialized layout).\n"
"\n"
"    If this component type is combined into a composite, then\n"
"    the absolute offsets/bindings of parameters may not stay the same.\n"
"    If the shader parameters in a component type don't make\n"
"    use of explicit binding annotations (e.g., `register(...)`),\n"
"    then the *relative* offset of shader parameters will stay\n"
"    the same when it is used in a composition.\n"
"    */\n"
"    virtual SLANG_NO_THROW ProgramLayout* SLANG_MCALL\n"
"    getLayout(SlangInt targetIndex = 0, IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Get the number of (unspecialized) specialization parameters for the component type.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangInt SLANG_MCALL getSpecializationParamCount() = 0;\n"
"\n"
"    /** Get the compiled code for the entry point at `entryPointIndex` for the chosen `targetIndex`\n"
"\n"
"    Entry point code can only be computed for a component type that\n"
"    has no specialization parameters (it must be fully specialized)\n"
"    and that has no requirements (it must be fully linked).\n"
"\n"
"    If code has not already been generated for the given entry point and target,\n"
"    then a compilation error may be detected, in which case `outDiagnostics`\n"
"    (if non-null) will be filled in with a blob of messages diagnosing the error.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCode(\n"
"        SlangInt entryPointIndex,\n"
"        SlangInt targetIndex,\n"
"        IBlob** outCode,\n"
"        IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Get the compilation result as a file system.\n"
"\n"
"    Has the same requirements as getEntryPointCode.\n"
"\n"
"    The result is not written to the actual OS file system, but is made available as an\n"
"    in memory representation.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getResultAsFileSystem(\n"
"        SlangInt entryPointIndex,\n"
"        SlangInt targetIndex,\n"
"        ISlangMutableFileSystem** outFileSystem) = 0;\n"
"\n"
"    /** Compute a hash for the entry point at `entryPointIndex` for the chosen `targetIndex`.\n"
"\n"
"    This computes a hash based on all the dependencies for this component type as well as the\n"
"    target settings affecting the compiler backend. The computed hash is used as a key for caching\n"
"    the output of the compiler backend to implement shader caching.\n"
"    */\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL\n"
"    getEntryPointHash(SlangInt entryPointIndex, SlangInt targetIndex, IBlob** outHash) = 0;\n"
"\n"
"    /** Specialize the component by binding its specialization parameters to concrete arguments.\n"
"\n"
"    The `specializationArgs` array must have `specializationArgCount` entries, and\n"
"    this must match the number of specialization parameters on this component type.\n"
"\n"
"    If any diagnostics (error or warnings) are produced, they will be written to `outDiagnostics`.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL specialize(\n"
"        SpecializationArg const* specializationArgs,\n"
"        SlangInt specializationArgCount,\n"
"        IComponentType** outSpecializedComponentType,\n"
"        ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Link this component type against all of its unsatisfied dependencies.\n"
"\n"
"    A component type may have unsatisfied dependencies. For example, a module\n"
"    depends on any other modules it `import`s, and an entry point depends\n"
"    on the module that defined it.\n"
"\n"
"    A user can manually satisfy dependencies by creating a composite\n"
"    component type, and when doing so they retain full control over\n"
"    the relative ordering of shader parameters in the resulting layout.\n"
"\n"
"    It is an error to try to generate/access compiled kernel code for\n"
"    a component type with unresolved dependencies, so if dependencies\n"
"    remain after whatever manual composition steps an application\n"
"    cares to perform, the `link()` function can be used to automatically\n"
"    compose in any remaining dependencies. The order of parameters\n"
"    (and hence the global layout) that results will be deterministic,\n"
"    but is not currently documented.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    link(IComponentType** outLinkedComponentType, ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    /** Get entry point 'callable' functions accessible through the ISlangSharedLibrary interface.\n"
"\n"
"    The functions remain in scope as long as the ISlangSharedLibrary interface is in scope.\n"
"\n"
"    NOTE! Requires a compilation target of SLANG_HOST_CALLABLE.\n"
"\n"
"    @param entryPointIndex  The index of the entry point to get code for.\n"
"    @param targetIndex      The index of the target to get code for (default: zero).\n"
"    @param outSharedLibrary A pointer to a ISharedLibrary interface which functions can be queried\n"
"    on.\n"
"    @returns                A `SlangResult` to indicate success or failure.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointHostCallable(\n"
"        int entryPointIndex,\n"
"        int targetIndex,\n"
"        ISlangSharedLibrary** outSharedLibrary,\n"
"        slang::IBlob** outDiagnostics = 0) = 0;\n"
"\n"
"    /** Get a new ComponentType object that represents a renamed entry point.\n"
"\n"
"    The current object must be a single EntryPoint, or a CompositeComponentType or\n"
"    SpecializedComponentType that contains one EntryPoint component.\n"
"    */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    renameEntryPoint(const char* newName, IComponentType** outEntryPoint) = 0;\n"
"\n"
"    /** Link and specify additional compiler options when generating code\n"
"     *   from the linked program.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL linkWithOptions(\n"
"        IComponentType** outLinkedComponentType,\n"
"        uint32_t compilerOptionEntryCount,\n"
"        CompilerOptionEntry* compilerOptionEntries,\n"
"        ISlangBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getTargetCode(SlangInt targetIndex, IBlob** outCode, IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTargetMetadata(\n"
"        SlangInt targetIndex,\n"
"        IMetadata** outMetadata,\n"
"        IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointMetadata(\n"
"        SlangInt entryPointIndex,\n"
"        SlangInt targetIndex,\n"
"        IMetadata** outMetadata,\n"
"        IBlob** outDiagnostics = nullptr) = 0;\n"
"};\n"
"    #define SLANG_UUID_IComponentType IComponentType::getTypeGuid()\n"
"\n"
"struct IEntryPoint : public IComponentType\n"
"{\n"
"    SLANG_COM_INTERFACE(0x8f241361, 0xf5bd, 0x4ca0, {0xa3, 0xac, 0x2, 0xf7, 0xfa, 0x24, 0x2, 0xb8})\n"
"\n"
"    virtual SLANG_NO_THROW FunctionReflection* SLANG_MCALL getFunctionReflection() = 0;\n"
"};\n"
"\n"
"    #define SLANG_UUID_IEntryPoint IEntryPoint::getTypeGuid()\n"
"\n"
"struct ITypeConformance : public IComponentType\n"
"{\n"
"    SLANG_COM_INTERFACE(0x73eb3147, 0xe544, 0x41b5, {0xb8, 0xf0, 0xa2, 0x44, 0xdf, 0x21, 0x94, 0xb})\n"
"};\n"
"    #define SLANG_UUID_ITypeConformance ITypeConformance::getTypeGuid()\n"
"\n"
"/** IComponentType2 is a component type used for getting separate debug data.\n"
"\n"
"This interface is used for getting separate debug data, introduced here to\n"
"avoid breaking backwards compatibility of the IComponentType interface.\n"
"\n"
"The `getTargetCompileResult` and `getEntryPointCompileResult` functions\n"
"are used to get the base and debug spirv, and metadata containing the\n"
"debug build identifier.\n"
"*/\n"
"struct IComponentType2 : public ISlangUnknown\n"
"{\n"
"    SLANG_COM_INTERFACE(\n"
"        0x9c2a4b3d,\n"
"        0x7f68,\n"
"        0x4e91,\n"
"        {0xa5, 0x2c, 0x8b, 0x19, 0x3e, 0x45, 0x7a, 0x9f})\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getTargetCompileResult(\n"
"        SlangInt targetIndex,\n"
"        ICompileResult** outCompileResult,\n"
"        IBlob** outDiagnostics = nullptr) = 0;\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getEntryPointCompileResult(\n"
"        SlangInt entryPointIndex,\n"
"        SlangInt targetIndex,\n"
"        ICompileResult** outCompileResult,\n"
"        IBlob** outDiagnostics = nullptr) = 0;\n"
"};\n"
"    #define SLANG_UUID_IComponentType2 IComponentType2::getTypeGuid()\n"
"\n"
"/** A module is the granularity of shader code compilation and loading.\n"
"\n"
"In most cases a module corresponds to a single compile \"translation unit.\"\n"
"This will often be a single `.slang` or `.hlsl` file and everything it\n"
"`#include`s.\n"
"\n"
"Notably, a module `M` does *not* include the things it `import`s, as these\n"
"as distinct modules that `M` depends on. There is a directed graph of\n"
"module dependencies, and all modules in the graph must belong to the\n"
"same session (`ISession`).\n"
"\n"
"A module establishes a namespace for looking up types, functions, etc.\n"
"*/\n"
"struct IModule : public IComponentType\n"
"{\n"
"    SLANG_COM_INTERFACE(0xc720e64, 0x8722, 0x4d31, {0x89, 0x90, 0x63, 0x8a, 0x98, 0xb1, 0xc2, 0x79})\n"
"\n"
"    /// Find and an entry point by name.\n"
"    /// Note that this does not work in case the function is not explicitly designated as an entry\n"
"    /// point, e.g. using a `[shader(\"...\")]` attribute. In such cases, consider using\n"
"    /// `IModule::findAndCheckEntryPoint` instead.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    findEntryPointByName(char const* name, IEntryPoint** outEntryPoint) = 0;\n"
"\n"
"    /// Get number of entry points defined in the module. An entry point defined in a module\n"
"    /// is by default not included in the linkage, so calls to `IComponentType::getEntryPointCount`\n"
"    /// on an `IModule` instance will always return 0. However `IModule::getDefinedEntryPointCount`\n"
"    /// will return the number of defined entry points.\n"
"    virtual SLANG_NO_THROW SlangInt32 SLANG_MCALL getDefinedEntryPointCount() = 0;\n"
"    /// Get the name of an entry point defined in the module.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getDefinedEntryPoint(SlangInt32 index, IEntryPoint** outEntryPoint) = 0;\n"
"\n"
"    /// Get a serialized representation of the checked module.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL serialize(ISlangBlob** outSerializedBlob) = 0;\n"
"\n"
"    /// Write the serialized representation of this module to a file.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL writeToFile(char const* fileName) = 0;\n"
"\n"
"    /// Get the name of the module.\n"
"    virtual SLANG_NO_THROW const char* SLANG_MCALL getName() = 0;\n"
"\n"
"    /// Get the path of the module.\n"
"    virtual SLANG_NO_THROW const char* SLANG_MCALL getFilePath() = 0;\n"
"\n"
"    /// Get the unique identity of the module.\n"
"    virtual SLANG_NO_THROW const char* SLANG_MCALL getUniqueIdentity() = 0;\n"
"\n"
"    /// Find and validate an entry point by name, even if the function is\n"
"    /// not marked with the `[shader(\"...\")]` attribute.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL findAndCheckEntryPoint(\n"
"        char const* name,\n"
"        SlangStage stage,\n"
"        IEntryPoint** outEntryPoint,\n"
"        ISlangBlob** outDiagnostics) = 0;\n"
"\n"
"    /// Get the number of dependency files that this module depends on.\n"
"    /// This includes both the explicit source files, as well as any\n"
"    /// additional files that were transitively referenced (e.g., via\n"
"    /// a `#include` directive).\n"
;
sb << 
"    virtual SLANG_NO_THROW SlangInt32 SLANG_MCALL getDependencyFileCount() = 0;\n"
"\n"
"    /// Get the path to a file this module depends on.\n"
"    virtual SLANG_NO_THROW char const* SLANG_MCALL getDependencyFilePath(SlangInt32 index) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW DeclReflection* SLANG_MCALL getModuleReflection() = 0;\n"
"\n"
"    /** Disassemble a module.\n"
"     */\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    disassemble(slang::IBlob** outDisassembledBlob) = 0;\n"
"};\n"
"\n"
"    #define SLANG_UUID_IModule IModule::getTypeGuid()\n"
"\n"
"/* Experimental interface for doing target precompilation of slang modules */\n"
"struct IModulePrecompileService_Experimental : public ISlangUnknown\n"
"{\n"
"    // uuidgen output:     8e12e8e3 -  5fcd -  433e -    afcb -      13a088bc5ee5\n"
"    SLANG_COM_INTERFACE(\n"
"        0x8e12e8e3,\n"
"        0x5fcd,\n"
"        0x433e,\n"
"        {0xaf, 0xcb, 0x13, 0xa0, 0x88, 0xbc, 0x5e, 0xe5})\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    precompileForTarget(SlangCompileTarget target, ISlangBlob** outDiagnostics) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getPrecompiledTargetCode(\n"
"        SlangCompileTarget target,\n"
"        IBlob** outCode,\n"
"        IBlob** outDiagnostics = nullptr) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangInt SLANG_MCALL getModuleDependencyCount() = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL getModuleDependency(\n"
"        SlangInt dependencyIndex,\n"
"        IModule** outModule,\n"
"        IBlob** outDiagnostics = nullptr) = 0;\n"
"};\n"
"\n"
"    #define SLANG_UUID_IModulePrecompileService_Experimental \\\n"
"        IModulePrecompileService_Experimental::getTypeGuid()\n"
"\n"
"/** Argument used for specialization to types/values.\n"
" */\n"
"struct SpecializationArg\n"
"{\n"
"    enum class Kind : int32_t\n"
"    {\n"
"        Unknown, /**< An invalid specialization argument. */\n"
"        Type,    /**< Specialize to a type. */\n"
"        Expr,    /**< An expression representing a type or value */\n"
"    };\n"
"\n"
"    /** The kind of specialization argument. */\n"
"    Kind kind;\n"
"    union\n"
"    {\n"
"        /** A type specialization argument, used for `Kind::Type`. */\n"
"        TypeReflection* type;\n"
"        /** An expression in Slang syntax, used for `Kind::Expr`. */\n"
"        const char* expr;\n"
"    };\n"
"\n"
"    static SpecializationArg fromType(TypeReflection* inType)\n"
"    {\n"
"        SpecializationArg rs;\n"
"        rs.kind = Kind::Type;\n"
"        rs.type = inType;\n"
"        return rs;\n"
"    }\n"
"\n"
"    static SpecializationArg fromExpr(const char* inExpr)\n"
"    {\n"
"        SpecializationArg rs;\n"
"        rs.kind = Kind::Expr;\n"
"        rs.expr = inExpr;\n"
"        return rs;\n"
"    }\n"
"};\n"
"} // namespace slang\n"
"\n"
"    // Passed into functions to create globalSession to identify the API version client code is\n"
"    // using.\n"
"    #define SLANG_API_VERSION 0\n"
"\n"
"enum SlangLanguageVersion\n"
"{\n"
"    SLANG_LANGUAGE_VERSION_UNKNOWN = 0,\n"
"    SLANG_LANGUAGE_VERSION_LEGACY = 2018,\n"
"    SLANG_LANGUAGE_VERSION_2025 = 2025,\n"
"    SLANG_LANGUAGE_VERSION_2026 = 2026,\n"
"    SLANG_LANGAUGE_VERSION_DEFAULT = SLANG_LANGUAGE_VERSION_LEGACY,\n"
"    SLANG_LANGUAGE_VERSION_LATEST = SLANG_LANGUAGE_VERSION_2026,\n"
"};\n"
"\n"
"\n"
"/* Description of a Slang global session.\n"
" */\n"
"struct SlangGlobalSessionDesc\n"
"{\n"
"    /// Size of this struct.\n"
"    uint32_t structureSize = sizeof(SlangGlobalSessionDesc);\n"
"\n"
"    /// Slang API version.\n"
"    uint32_t apiVersion = SLANG_API_VERSION;\n"
"\n"
"    /// Specify the oldest Slang language version that any sessions will use.\n"
"    uint32_t minLanguageVersion = SLANG_LANGUAGE_VERSION_2025;\n"
"\n"
"    /// Whether to enable GLSL support.\n"
"    bool enableGLSL = false;\n"
"\n"
"    /// Reserved for future use.\n"
"    uint32_t reserved[16] = {};\n"
"};\n"
"\n"
"/* Create a blob from binary data.\n"
" *\n"
" * @param data Pointer to the binary data to store in the blob. Must not be null.\n"
" * @param size Size of the data in bytes. Must be greater than 0.\n"
" * @return The created blob on success, or nullptr on failure.\n"
" */\n"
"SLANG_EXTERN_C SLANG_API ISlangBlob* slang_createBlob(const void* data, size_t size);\n"
"\n"
"/* Load a module from source code with size specification.\n"
" *\n"
" * @param session The session to load the module into.\n"
" * @param moduleName The name of the module.\n"
" * @param path The path for the module.\n"
" * @param source Pointer to the source code data.\n"
" * @param sourceSize Size of the source code data in bytes.\n"
" * @param outDiagnostics (out, optional) Diagnostics output.\n"
" * @return The loaded module on success, or nullptr on failure.\n"
" */\n"
"SLANG_EXTERN_C SLANG_API slang::IModule* slang_loadModuleFromSource(\n"
"    slang::ISession* session,\n"
"    const char* moduleName,\n"
"    const char* path,\n"
"    const char* source,\n"
"    size_t sourceSize,\n"
"    ISlangBlob** outDiagnostics = nullptr);\n"
"\n"
"/** Load a module from IR data.\n"
" * @param session The session to load the module into.\n"
" * @param moduleName Name of the module to load.\n"
" * @param path Path for the module (used for diagnostics).\n"
" * @param source IR data containing the module.\n"
" * @param sourceSize Size of the IR data in bytes.\n"
" * @param outDiagnostics (out, optional) Diagnostics output.\n"
" * @return The loaded module on success, or nullptr on failure.\n"
" */\n"
"SLANG_EXTERN_C SLANG_API slang::IModule* slang_loadModuleFromIRBlob(\n"
"    slang::ISession* session,\n"
"    const char* moduleName,\n"
"    const char* path,\n"
"    const void* source,\n"
"    size_t sourceSize,\n"
"    ISlangBlob** outDiagnostics = nullptr);\n"
"\n"
"/** Read module info (name and version) from IR data.\n"
" * @param session The session to use for loading module info.\n"
" * @param source IR data containing the module.\n"
" * @param sourceSize Size of the IR data in bytes.\n"
" * @param outModuleVersion (out) Module version number.\n"
" * @param outModuleCompilerVersion (out) Compiler version that created the module.\n"
" * @param outModuleName (out) Name of the module.\n"
" * @return SLANG_OK on success, or an error code on failure.\n"
" */\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_loadModuleInfoFromIRBlob(\n"
"    slang::ISession* session,\n"
"    const void* source,\n"
"    size_t sourceSize,\n"
"    SlangInt& outModuleVersion,\n"
"    const char*& outModuleCompilerVersion,\n"
"    const char*& outModuleName);\n"
"\n"
"/* Create a global session, with the built-in core module.\n"
"\n"
"@param apiVersion Pass in SLANG_API_VERSION\n"
"@param outGlobalSession (out)The created global session.\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult\n"
"slang_createGlobalSession(SlangInt apiVersion, slang::IGlobalSession** outGlobalSession);\n"
"\n"
"\n"
"/* Create a global session, with the built-in core module.\n"
"\n"
"@param desc Description of the global session.\n"
"@param outGlobalSession (out)The created global session.\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_createGlobalSession2(\n"
"    const SlangGlobalSessionDesc* desc,\n"
"    slang::IGlobalSession** outGlobalSession);\n"
"\n"
"/* Create a global session, but do not set up the core module. The core module can\n"
"then be loaded via loadCoreModule or compileCoreModule\n"
"\n"
"@param apiVersion Pass in SLANG_API_VERSION\n"
"@param outGlobalSession (out)The created global session that doesn't have a core module setup.\n"
"\n"
"NOTE! API is experimental and not ready for production code\n"
"*/\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_createGlobalSessionWithoutCoreModule(\n"
"    SlangInt apiVersion,\n"
"    slang::IGlobalSession** outGlobalSession);\n"
"\n"
"/* Returns a blob that contains the serialized core module.\n"
"Returns nullptr if there isn't an embedded core module.\n"
"\n"
"NOTE! API is experimental and not ready for production code\n"
"*/\n"
"SLANG_API ISlangBlob* slang_getEmbeddedCoreModule();\n"
"\n"
"\n"
"/* Cleanup all global allocations used by Slang, to prevent memory leak detectors from\n"
" reporting them as leaks. This function should only be called after all Slang objects\n"
" have been released. No other Slang functions such as `createGlobalSession`\n"
" should be called after this function.\n"
" */\n"
"SLANG_EXTERN_C SLANG_API void slang_shutdown();\n"
"\n"
"/* Return the last signaled internal error message.\n"
" */\n"
"SLANG_EXTERN_C SLANG_API const char* slang_getLastInternalErrorMessage();\n"
"\n"
"// Slang VM\n"
"namespace slang\n"
"{\n"
"\n"
"enum class OperandDataType\n"
"{\n"
"    General = 0, // General data type, can be any type.\n"
"    Int32 = 1,   // 32-bit integer.\n"
"    Int64 = 2,   // 64-bit integer.\n"
"    Float32 = 3, // 32-bit floating-point number.\n"
"    Float64 = 4, // 64-bit floating-point number.\n"
"    String = 5,  // String data type, represented as a pointer to a null-terminated string.\n"
"};\n"
"\n"
"struct VMExecOperand\n"
"{\n"
"    uint8_t** section; // Pointer to the section start pointer.\n"
"    #if SLANG_PTR_IS_32\n"
"    uint32_t padding;\n"
"    #endif\n"
"    uint32_t type : 8; // type of the operand data.\n"
"    uint32_t size : 24;\n"
"    uint32_t offset;\n"
"    void* getPtr() const { return *section + offset; }\n"
"    OperandDataType getType() const { return (OperandDataType)type; }\n"
"};\n"
"\n"
"struct VMExecInstHeader;\n"
"class IByteCodeRunner;\n"
"\n"
"typedef void (*VMExtFunction)(IByteCodeRunner* context, VMExecInstHeader* inst, void* userData);\n"
"typedef void (*VMPrintFunc)(const char* message, void* userData);\n"
"\n"
"struct VMExecInstHeader\n"
"{\n"
"    VMExtFunction functionPtr; // Pointer to the function that executes this instruction.\n"
"    #if SLANG_PTR_IS_32\n"
"    uint32_t padding;\n"
"    #endif\n"
"    uint32_t opcodeExtension;\n"
"    uint32_t operandCount;\n"
"    VMExecInstHeader* getNextInst()\n"
"    {\n"
"        return (VMExecInstHeader*)((VMExecOperand*)(this + 1) + operandCount);\n"
"    }\n"
"    VMExecOperand& getOperand(SlangInt index) const\n"
"    {\n"
"        return *((VMExecOperand*)(this + 1) + index);\n"
"    }\n"
"};\n"
"\n"
"struct ByteCodeFuncInfo\n"
"{\n"
"    uint32_t parameterCount;\n"
"    uint32_t returnValueSize;\n"
"};\n"
"\n"
"struct ByteCodeRunnerDesc\n"
"{\n"
"    /** The size of this structure, in bytes.\n"
"     */\n"
"    size_t structSize = sizeof(ByteCodeRunnerDesc);\n"
"};\n"
"\n"
"/// Represents a byte code runner that can execute Slang byte code.\n"
"class IByteCodeRunner : public ISlangUnknown\n"
"{\n"
"public:\n"
"    // {AFDAB195-361F-42CB-9513-9006261DD8CD}\n"
"    SLANG_COM_INTERFACE(0xafdab195, 0x361f, 0x42cb, {0x95, 0x13, 0x90, 0x6, 0x26, 0x1d, 0xd8, 0xcd})\n"
"\n"
"    /// Load a byte code module into the execution context.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL loadModule(IBlob* moduleBlob) = 0;\n"
"\n"
"    /// Select a function for execution.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    selectFunctionByIndex(uint32_t functionIndex) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW int SLANG_MCALL findFunctionByName(const char* name) = 0;\n"
"\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    getFunctionInfo(uint32_t index, ByteCodeFuncInfo* outInfo) = 0;\n"
"\n"
"    /// Obtain the current working set memory for the selected function.\n"
"    virtual SLANG_NO_THROW void* SLANG_MCALL getCurrentWorkingSet() = 0;\n"
"\n"
"    /// Execute the selected function.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    execute(void* argumentData, size_t argumentSize) = 0;\n"
"\n"
"    /// Query the error string.\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL getErrorString(IBlob** outBlob) = 0;\n"
"\n"
"    /// Retrieve the return value of the last executed function.\n"
"    virtual SLANG_NO_THROW void* SLANG_MCALL getReturnValue(size_t* outValueSize) = 0;\n"
"\n"
"    /// Set the user data for the external instruction handler.\n"
"    virtual SLANG_NO_THROW void SLANG_MCALL setExtInstHandlerUserData(void* userData) = 0;\n"
"\n"
"    /// Register an external function that can be called from the byte code.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    registerExtCall(const char* name, VMExtFunction functionPtr) = 0;\n"
"\n"
"    /// Set a callback function to print messages from the byte code runner.\n"
"    virtual SLANG_NO_THROW SlangResult SLANG_MCALL\n"
"    setPrintCallback(VMPrintFunc callback, void* userData) = 0;\n"
"};\n"
"\n"
"} // namespace slang\n"
"\n"
"/// Create a byte code runner that can execute Slang byte code.\n"
"SLANG_EXTERN_C SLANG_API SlangResult slang_createByteCodeRunner(\n"
"    const slang::ByteCodeRunnerDesc* desc,\n"
"    slang::IByteCodeRunner** outByteCodeRunner);\n"
"\n"
"/// Disassemble a Slang byte code blob into human-readable text.\n"
"SLANG_EXTERN_C SLANG_API SlangResult\n"
"slang_disassembleByteCode(slang::IBlob* moduleBlob, slang::IBlob** outDisassemblyBlob);\n"
"\n"
"namespace slang\n"
"{\n"
"inline SlangResult createGlobalSession(slang::IGlobalSession** outGlobalSession)\n"
"{\n"
"    SlangGlobalSessionDesc defaultDesc = {};\n"
"    return slang_createGlobalSession2(&defaultDesc, outGlobalSession);\n"
"}\n"
"inline SlangResult createGlobalSession(\n"
"    const SlangGlobalSessionDesc* desc,\n"
"    slang::IGlobalSession** outGlobalSession)\n"
"{\n"
"    return slang_createGlobalSession2(desc, outGlobalSession);\n"
"}\n"
"inline void shutdown()\n"
"{\n"
"    slang_shutdown();\n"
"}\n"
"inline const char* getLastInternalErrorMessage()\n"
"{\n"
"    return slang_getLastInternalErrorMessage();\n"
"}\n"
"} // namespace slang\n"
"\n"
"#endif // C++ helpers\n"
"\n"
"#define SLANG_ERROR_INSUFFICIENT_BUFFER SLANG_E_BUFFER_TOO_SMALL\n"
"#define SLANG_ERROR_INVALID_PARAMETER SLANG_E_INVALID_ARG\n"
"\n"
"#endif\n"
"\n"
"\n"
"#include <assert.h>\n"
"#include <cstddef>\n"
"#include <cstring>\n"
"#include <stdint.h>\n"
"#include <type_traits>\n"
"\n"
"#define VARIADIC_TEMPLATE\n"
"\n"
"namespace Slang\n"
"{\n"
"\n"
"/// Signed 32-bit integer.\n"
"///\n"
"/// This type should be used when the exact size\n"
"/// in bits is important (e.g., when dealing with\n"
"/// explicit binary file formats, etc.). Otherwise\n"
"/// prefer the plain `Int` type or a semantically\n"
"/// richer type like `Count` or `Index`.\n"
"///\n"
"typedef int32_t Int32;\n"
"\n"
"/// Unsigned 32-bit integer.\n"
"///\n"
"/// This type should be used when the exact size\n"
"/// in bits is important (e.g., when dealing with\n"
"/// explicit binary file formats, etc.). Otherwise\n"
"/// prefer the plain `Int` type or a semantically\n"
"/// richer type like `Count` or `Index`.\n"
"///\n"
"typedef uint32_t UInt32;\n"
"\n"
"/// Signed 64-bit integer.\n"
"///\n"
"/// This type should be used when the exact size\n"
"/// in bits is important (e.g., when dealing with\n"
"/// explicit binary file formats, etc.). Otherwise\n"
"/// prefer the plain `Int` type or a semantically\n"
"/// richer type like `Count` or `Index`.\n"
"///\n"
"typedef int64_t Int64;\n"
"\n"
"/// Unsigned 64-bit integer.\n"
"///\n"
"/// This type should be used when the exact size\n"
"/// in bits is important (e.g., when dealing with\n"
"/// explicit binary file formats, etc.). Otherwise\n"
"/// prefer the plain `Int` type or a semantically\n"
"/// richer type like `Count` or `Index`.\n"
"///\n"
"typedef uint64_t UInt64;\n"
"\n"
"/// \"Default\" integer type for the Slang codebase.\n"
"///\n"
"/// When there is not a clear reason to another\n"
"/// integer type, use this one.\n"
"///\n"
"/// Note that this type is currently defined to be\n"
"/// the same as the `SlangInt` type exposed through\n"
"/// the public Slang API, but this may not be the\n"
"/// case forever.\n"
"///\n"
"typedef SlangInt Int;\n"
"\n"
"/// \"Default\" unsigned integer type for the Slang codebase.\n"
"///\n"
"/// Only use this type when you explicitly need\n"
"/// an unsigned type that's the same size as `Int`.\n"
"/// Otherwise you should probably just be using `Int`.\n"
"///\n"
"/// Note that this type is currently defined to be\n"
"/// the same as the `SlangUInt` type exposed through\n"
"/// the public Slang API, but this may not be the\n"
"/// case forever.\n"
"///\n"
"typedef SlangUInt UInt;\n"
"\n"
"static const UInt kMaxUInt = ~UInt(0);\n"
"static const Int kMaxInt = Int(kMaxUInt >> 1);\n"
"\n"
"typedef intptr_t PtrInt;\n"
"\n"
"/// Default type for indices.\n"
"///\n"
"/// This is (and should always be) an alias for `Int`.\n"
"///\n"
"/// Use this type to document the intention that an\n"
"/// integer parameter/variable/etc. represents an\n"
"/// index into some kind of sequence, or any other\n"
"/// kind of ordinal number.\n"
"///\n"
"typedef Int Index;\n"
"\n"
"static const Index kMaxIndex = kMaxInt;\n"
"\n"
"/// Unsigned equivalent of `Index`.\n"
"///\n"
"/// Please don't use this unless you have a good reason.\n"
"///\n"
"typedef UInt UIndex;\n"
"\n"
"/// Default type for counts.\n"
"///\n"
"/// This is (and should always be) an alias for `Int`.\n"
"///\n"
"/// Use this type to document the intention that an\n"
"/// integer parameter/variable/etc. represents a\n"
"/// count of the number of elements in some container,\n"
"/// or any other kind of cardinal number.\n"
"///\n"
"typedef Int Count;\n"
"\n"
"/// Unsigned equivalent of `Count`.\n"
"///\n"
"/// Please don't use this unless you have a good reason.\n"
"///\n"
"typedef UInt UCount;\n"
"\n"
"\n"
"/// Explicit type for when manipulating bytes.\n"
"///\n"
"/// Use this type to document the intention that a\n"
"/// parameter/variable/etc. represents an 8-bit byte, with\n"
"/// no particular interpretation of that byte as\n"
"/// any higher-level type.\n"
"///\n"
"/// Note that the `char` types have special semantics\n"
"/// when it comes to \"type punning\" that are not shared\n"
"/// with other types like `uint8_t`. Using a variation\n"
"/// of `char` here helps avoid the possibility of undefined\n"
"/// behavior when code reads other types to/from arrays\n"
"/// of `Byte`s.\n"
"///\n"
"/// We are not using `std::byte` here because that is\n"
"/// defined as an `enum class` and does not support\n"
"/// mathematical or bitwise operations, which a lot\n"
"/// of the Slang codebase does on `Byte`s.\n"
"///\n"
"typedef unsigned char Byte;\n"
"\n"
"/// Preferred integer type for sizes measured in bytes.\n"
"///\n"
"/// Use this type to document the intention that an\n"
"/// integer parameter/variable/etc. represents the\n"
"/// size of something, in bytes, rather than being\n"
"/// some other kind of integer.\n"
"///\n"
"/// Note that this type is unsigned, despite the stated\n"
"/// default in the Slang codebase being signed integer\n"
"/// types. The reason for this is that variables\n"
"/// holding sizes are often compared against the\n"
;
sb << 
"/// result of the `sizeof` operator, which yields\n"
"/// a `size_t`. Our hands are, to some extent, tied\n"
"/// on this matter.\n"
"///\n"
"using Size = size_t;\n"
"\n"
"// TODO(JS):\n"
"// Perhaps these should be named Utf8, Utf16 and UnicodePoint/Rune/etc? For now, just keep it simple\n"
"//\n"
"typedef char Char8;\n"
"// 16 bit character. Note much like in utf8, a character may or may not represent a code point (it\n"
"// can be part of a code point).\n"
"typedef uint16_t Char16;\n"
"\n"
"// Can always hold a unicode code point.\n"
"typedef uint32_t Char32;\n"
"\n"
"template<typename T>\n"
"inline T&& _Move(T& obj)\n"
"{\n"
"    return static_cast<T&&>(obj);\n"
"}\n"
"\n"
"template<typename T>\n"
"inline void Swap(T& v0, T& v1)\n"
"{\n"
"    T tmp = _Move(v0);\n"
"    v0 = _Move(v1);\n"
"    v1 = _Move(tmp);\n"
"}\n"
"\n"
"// Make these interfaces have more convenient names\n"
"typedef ISlangCastable ICastable;\n"
"typedef ISlangClonable IClonable;\n"
"\n"
"// Convenience function for using clonable\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE T* clone(IClonable* clonable)\n"
"{\n"
"    return (T*)clonable->clone(T::getTypeGuid());\n"
"}\n"
"\n"
"template<typename T>\n"
"inline bool isBitSet(T value, T bitToTest)\n"
"{\n"
"    static_assert(sizeof(T) <= sizeof(uint32_t), \"Only support up to 32 bit enums\");\n"
"    return (T)((uint32_t)value & (uint32_t)bitToTest) == bitToTest;\n"
"}\n"
"\n"
"template<typename To, typename From>\n"
"typename std::enable_if_t<\n"
"    sizeof(To) == sizeof(From) && std::is_trivially_copyable_v<From> &&\n"
"        std::is_trivially_copyable_v<To> && std::is_trivially_constructible_v<To>,\n"
"    To>\n"
"bitCast(const From& src)\n"
"{\n"
"    To dst;\n"
"    std::memcpy(&dst, &src, sizeof(To));\n"
"    return dst;\n"
"}\n"
"\n"
"} // namespace Slang\n"
"\n"
"// SLANG_DEFER\n"
"template<typename F>\n"
"class SlangDeferImpl\n"
"{\n"
"    F f;\n"
"\n"
"public:\n"
"    SlangDeferImpl(F&& f)\n"
"        : f(Slang::_Move(f))\n"
"    {\n"
"    }\n"
"    ~SlangDeferImpl() { f(); }\n"
"};\n"
"\n"
"#ifndef SLANG_DEFER_LAMBDA\n"
"#define SLANG_DEFER_LAMBDA(x) auto SLANG_CONCAT(slang_defer_, __LINE__) = SlangDeferImpl(x)\n"
"#define SLANG_DEFER(x) auto SLANG_CONCAT(slang_defer_, __LINE__) = SlangDeferImpl([&]() { x; })\n"
"#endif\n"
"\n"
"//\n"
"// Some macros for avoiding boilerplate\n"
"// TODO: could probably deduce the size with templates, and move the whole\n"
"// thing into a template\n"
"//\n"
"#if __cplusplus >= 202002L\n"
"#define SLANG_COMPONENTWISE_EQUALITY_1(type) bool operator==(const type& other) const = default;\n"
"#define SLANG_COMPONENTWISE_EQUALITY_2(type) bool operator==(const type& other) const = default;\n"
"#define SLANG_COMPONENTWISE_EQUALITY_3(type) bool operator==(const type& other) const = default;\n"
"#else\n"
"#define SLANG_COMPONENTWISE_EQUALITY_1(type) \\\n"
"    bool operator==(const type& other) const \\\n"
"    {                                        \\\n"
"        const auto& [m1] = *this;            \\\n"
"        const auto& [o1] = other;            \\\n"
"        return m1 == o1;                     \\\n"
"    }                                        \\\n"
"    bool operator!=(const type& other) const \\\n"
"    {                                        \\\n"
"        return !(*this == other);            \\\n"
"    }\n"
"\n"
"#define SLANG_COMPONENTWISE_EQUALITY_2(type) \\\n"
"    bool operator==(const type& other) const \\\n"
"    {                                        \\\n"
"        const auto& [m1, m2] = *this;        \\\n"
"        const auto& [o1, o2] = other;        \\\n"
"        return m1 == o1 && m2 == o2;         \\\n"
"    }                                        \\\n"
"    bool operator!=(const type& other) const \\\n"
"    {                                        \\\n"
"        return !(*this == other);            \\\n"
"    }\n"
"\n"
"#define SLANG_COMPONENTWISE_EQUALITY_3(type)     \\\n"
"    bool operator==(const type& other) const     \\\n"
"    {                                            \\\n"
"        const auto& [m1, m2, m3] = *this;        \\\n"
"        const auto& [o1, o2, o3] = other;        \\\n"
"        return m1 == o1 && m2 == o2 && m3 == o3; \\\n"
"    }                                            \\\n"
"    bool operator!=(const type& other) const     \\\n"
"    {                                            \\\n"
"        return !(*this == other);                \\\n"
"    }\n"
"#endif\n"
"\n"
"// TODO: Shouldn't these be SLANG_ prefixed?\n"
"#ifdef _MSC_VER\n"
"#define UNREACHABLE_RETURN(x)\n"
"#else\n"
"#define UNREACHABLE_RETURN(x) return x;\n"
"#endif\n"
"\n"
"#if SLANG_GCC\n"
"#define SLANG_EXHAUSTIVE_SWITCH_BEGIN \\\n"
"    _Pragma(\"GCC diagnostic push\");   \\\n"
"    _Pragma(\"GCC diagnostic error \\\"-Wswitch-enum\\\"\");\n"
"#define SLANG_EXHAUSTIVE_SWITCH_END _Pragma(\"GCC diagnostic pop\");\n"
"#elif SLANG_CLANG\n"
"#define SLANG_EXHAUSTIVE_SWITCH_BEGIN \\\n"
"    _Pragma(\"clang diagnostic push\"); \\\n"
"    _Pragma(\"clang diagnostic error \\\"-Wswitch-enum\\\"\");\n"
"#define SLANG_EXHAUSTIVE_SWITCH_END _Pragma(\"clang diagnostic pop\");\n"
"#elif SLANG_VC\n"
"#define SLANG_EXHAUSTIVE_SWITCH_BEGIN \\\n"
"    _Pragma(\"warning(push)\");         \\\n"
"    _Pragma(\"warning(error : 4062)\");\n"
"#define SLANG_EXHAUSTIVE_SWITCH_END _Pragma(\"warning(pop)\");\n"
"#else\n"
"#define SLANG_EXHAUSTIVE_SWITCH_BEGIN\n"
"#define SLANG_EXHAUSTIVE_SWITCH_END\n"
"#endif\n"
"\n"
"#if SLANG_GCC\n"
"#define SLANG_ALLOW_DEPRECATED_BEGIN \\\n"
"    _Pragma(\"GCC diagnostic push\");  \\\n"
"    _Pragma(\"GCC diagnostic ignored \\\"-Wdeprecated-declarations\\\"\");\n"
"#define SLANG_ALLOW_DEPRECATED_END _Pragma(\"GCC diagnostic pop\");\n"
"#elif SLANG_CLANG\n"
"#define SLANG_ALLOW_DEPRECATED_BEGIN  \\\n"
"    _Pragma(\"clang diagnostic push\"); \\\n"
"    _Pragma(\"clang diagnostic ignored \\\"-Wdeprecated-declarations\\\"\");\n"
"#define SLANG_ALLOW_DEPRECATED_END _Pragma(\"clang diagnostic pop\");\n"
"#elif SLANG_VC\n"
"#define SLANG_ALLOW_DEPRECATED_BEGIN \\\n"
"    _Pragma(\"warning(push)\");        \\\n"
"    _Pragma(\"warning(disable : 4996)\");\n"
"#define SLANG_ALLOW_DEPRECATED_END _Pragma(\"warning(pop)\");\n"
"#else\n"
"#define SLANG_ALLOW_DEPRECATED_BEGIN\n"
"#define SLANG_ALLOW_DEPRECATED_END\n"
"#endif\n"
"\n"
"//\n"
"// Use `SLANG_ASSUME(myBoolExpression);` to inform the compiler that the condition is true.\n"
"// Do not rely on side effects of the condition being performed.\n"
"//\n"
"#if defined(__cpp_assume)\n"
"#define SLANG_ASSUME(X) [[assume(X)]]\n"
"#elif SLANG_GCC\n"
"#define SLANG_ASSUME(X)              \\\n"
"    do                               \\\n"
"    {                                \\\n"
"        if (!(X))                    \\\n"
"            __builtin_unreachable(); \\\n"
"    } while (0)\n"
"#elif SLANG_CLANG\n"
"#define SLANG_ASSUME(X) __builtin_assume(X)\n"
"#elif SLANG_VC\n"
"#define SLANG_ASSUME(X) __assume(X)\n"
"#else\n"
"[[noreturn]] inline void invokeUndefinedBehaviour() {}\n"
"#define SLANG_ASSUME(X)                 \\\n"
"    do                                  \\\n"
"    {                                   \\\n"
"        if (!(X))                       \\\n"
"            invokeUndefinedBehaviour(); \\\n"
"    } while (0)\n"
"#endif\n"
"\n"
"//\n"
"// Assertions abort in debug builds, but inform the compiler of true\n"
"// assumptions in release builds\n"
"//\n"
"#ifdef _DEBUG\n"
"#define SLANG_ASSERT(VALUE)               \\\n"
"    do                                    \\\n"
"    {                                     \\\n"
"        if (!(VALUE)) [[unlikely]]        \\\n"
"            SLANG_ASSERT_FAILURE(#VALUE); \\\n"
"    } while (0)\n"
"#else\n"
"#define SLANG_ASSERT(VALUE) SLANG_ASSUME(VALUE)\n"
"#endif\n"
"\n"
"#define SLANG_RELEASE_ASSERT(VALUE) \\\n"
"    if (VALUE) [[likely]]           \\\n"
"    {                               \\\n"
"    }                               \\\n"
"    else                            \\\n"
"        SLANG_ASSERT_FAILURE(#VALUE)\n"
"\n"
"template<typename T>\n"
"void slang_use_obj(T&)\n"
"{\n"
"}\n"
"\n"
"#define SLANG_UNREFERENCED_PARAMETER(P) slang_use_obj(P)\n"
"#define SLANG_UNREFERENCED_VARIABLE(P) slang_use_obj(P)\n"
"\n"
"#if defined(SLANG_RT_DYNAMIC)\n"
"#if defined(_MSC_VER)\n"
"#ifdef SLANG_RT_DYNAMIC_EXPORT\n"
"#define SLANG_RT_API SLANG_DLL_EXPORT\n"
"#else\n"
"#define SLANG_RT_API __declspec(dllimport)\n"
"#endif\n"
"#else\n"
"// TODO: need to consider compiler capabilities\n"
"// #     ifdef SLANG_RT_DYNAMIC_EXPORT\n"
"#define SLANG_RT_API SLANG_DLL_EXPORT\n"
"// #     endif\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(_MSC_VER)\n"
"#define SLANG_ATTR_PRINTF(string_index, varargs_index)\n"
"#else\n"
"#define SLANG_ATTR_PRINTF(string_index, varargs_index) \\\n"
"    __attribute__((format(printf, string_index, varargs_index)))\n"
"#endif\n"
"\n"
"#ifndef SLANG_RT_API\n"
"#define SLANG_RT_API\n"
"#endif\n"
"\n"
"#ifndef SLANG_CORE_HASH_H\n"
"#define SLANG_CORE_HASH_H\n"
"\n"
"#ifndef SLANG_CORE_MATH_H\n"
"#define SLANG_CORE_MATH_H\n"
"\n"
"\n"
"#include <cmath>\n"
"\n"
"namespace Slang\n"
"{\n"
"// Some handy constants\n"
"\n"
"// The largest positive (or negative) number\n"
"#define SLANG_HALF_MAX 65504.0f\n"
"// Smallest (denormalized) value. 1 / 2^24\n"
"#define SLANG_HALF_SUB_NORMAL_MIN (1.0f / 16777216.0f)\n"
"\n"
"class Math\n"
"{\n"
"public:\n"
"    // Use to fix type punning issues with strict aliasing\n"
"    union FloatIntUnion\n"
"    {\n"
"        float fvalue;\n"
"        int ivalue;\n"
"\n"
"        SLANG_FORCE_INLINE static FloatIntUnion makeFromInt(int i)\n"
"        {\n"
"            FloatIntUnion cast;\n"
"            cast.ivalue = i;\n"
"            return cast;\n"
"        }\n"
"        SLANG_FORCE_INLINE static FloatIntUnion makeFromFloat(float f)\n"
"        {\n"
"            FloatIntUnion cast;\n"
"            cast.fvalue = f;\n"
"            return cast;\n"
"        }\n"
"    };\n"
"    union DoubleInt64Union\n"
"    {\n"
"        double dvalue;\n"
"        int64_t ivalue;\n"
"        SLANG_FORCE_INLINE static DoubleInt64Union makeFromInt64(int64_t i)\n"
"        {\n"
"            DoubleInt64Union cast;\n"
"            cast.ivalue = i;\n"
"            return cast;\n"
"        }\n"
"        SLANG_FORCE_INLINE static DoubleInt64Union makeFromDouble(double d)\n"
"        {\n"
"            DoubleInt64Union cast;\n"
"            cast.dvalue = d;\n"
"            return cast;\n"
"        }\n"
"    };\n"
"\n"
"    static const float Pi;\n"
"\n"
"    template<typename T>\n"
"    static T Abs(T a)\n"
"    {\n"
"        return (a < 0) ? -a : a;\n"
"    }\n"
"\n"
"    template<typename T>\n"
"    static T Min(const T& v1, const T& v2)\n"
"    {\n"
"        return v1 < v2 ? v1 : v2;\n"
"    }\n"
"    template<typename T>\n"
"    static T Max(const T& v1, const T& v2)\n"
"    {\n"
"        return v1 > v2 ? v1 : v2;\n"
"    }\n"
"    template<typename T>\n"
"    static T Min(const T& v1, const T& v2, const T& v3)\n"
"    {\n"
"        return Min(v1, Min(v2, v3));\n"
"    }\n"
"    template<typename T>\n"
"    static T Max(const T& v1, const T& v2, const T& v3)\n"
"    {\n"
"        return Max(v1, Max(v2, v3));\n"
"    }\n"
"    template<typename T>\n"
"    static T Clamp(const T& val, const T& vmin, const T& vmax)\n"
"    {\n"
"        if (val < vmin)\n"
"            return vmin;\n"
"        else if (val > vmax)\n"
"            return vmax;\n"
"        else\n"
"            return val;\n"
"    }\n"
"\n"
"    static inline int FastFloor(float x)\n"
"    {\n"
"        int i = (int)x;\n"
"        return i - (i > x);\n"
"    }\n"
"\n"
"    static inline int FastFloor(double x)\n"
"    {\n"
"        int i = (int)x;\n"
"        return i - (i > x);\n"
"    }\n"
"\n"
"    static inline int IsNaN(float x) { return std::isnan(x); }\n"
"    static inline int IsNaN(double x) { return std::isnan(x); }\n"
"\n"
"    static inline int IsInf(float x) { return std::isinf(x); }\n"
"    static inline int IsInf(double x) { return std::isinf(x); }\n"
"\n"
"    static inline unsigned int Ones32(unsigned int x)\n"
"    {\n"
"        /* 32-bit recursive reduction using SWAR...\n"
"            but first step is mapping 2-bit values\n"
"            into sum of 2 1-bit values in sneaky way\n"
"        */\n"
"        x -= ((x >> 1) & 0x55555555);\n"
"        x = (((x >> 2) & 0x33333333) + (x & 0x33333333));\n"
"        x = (((x >> 4) + x) & 0x0f0f0f0f);\n"
"        x += (x >> 8);\n"
"        x += (x >> 16);\n"
"        return (x & 0x0000003f);\n"
"    }\n"
"\n"
"    static inline unsigned int Log2Floor(unsigned int x)\n"
"    {\n"
"        x |= (x >> 1);\n"
"        x |= (x >> 2);\n"
"        x |= (x >> 4);\n"
"        x |= (x >> 8);\n"
"        x |= (x >> 16);\n"
"        return (Ones32(x >> 1));\n"
"    }\n"
"\n"
"    static inline unsigned int Log2Ceil(unsigned int x)\n"
"    {\n"
"        int y = (x & (x - 1));\n"
"        y |= -y;\n"
"        y >>= (32 - 1);\n"
"        x |= (x >> 1);\n"
"        x |= (x >> 2);\n"
"        x |= (x >> 4);\n"
"        x |= (x >> 8);\n"
"        x |= (x >> 16);\n"
"        return (Ones32(x >> 1) - y);\n"
"    }\n"
"    /*\n"
"    static inline int Log2(float x)\n"
"    {\n"
"        unsigned int ix = (unsigned int&)x;\n"
"        unsigned int exp = (ix >> 23) & 0xFF;\n"
"        int log2 = (unsigned int)(exp) - 127;\n"
"\n"
"        return log2;\n"
"    }\n"
"    */\n"
"\n"
"    static bool AreNearlyEqual(double a, double b, double epsilon)\n"
"    {\n"
"        // If they are equal then we are done\n"
"        if (a == b)\n"
"        {\n"
"            return true;\n"
"        }\n"
"\n"
"        const double absA = Abs(a);\n"
"        const double absB = Abs(b);\n"
"        const double diff = Abs(a - b);\n"
"\n"
"        // https://en.wikipedia.org/wiki/Double_precision_floating-point_format\n"
"        const double minNormal = 2.2250738585072014e-308;\n"
"        // Either a or b are very close to being zero, so doing relative comparison isn't really\n"
"        // appropriate\n"
"        if (a == 0.0 || b == 0.0 || (absA + absB < minNormal))\n"
"        {\n"
"            return diff < (epsilon * minNormal);\n"
"        }\n"
"        else\n"
"        {\n"
"            // Calculate a relative relative error\n"
"            return diff < epsilon * (absA + absB);\n"
"        }\n"
"    }\n"
"\n"
"    template<typename T>\n"
"    static T getLowestBit(T val)\n"
"    {\n"
"        return val & (-val);\n"
"    }\n"
"};\n"
"inline int FloatAsInt(float val)\n"
"{\n"
"    return Math::FloatIntUnion::makeFromFloat(val).ivalue;\n"
"}\n"
"inline float IntAsFloat(int val)\n"
"{\n"
"    return Math::FloatIntUnion::makeFromInt(val).fvalue;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE int64_t DoubleAsInt64(double val)\n"
"{\n"
"    return Math::DoubleInt64Union::makeFromDouble(val).ivalue;\n"
"}\n"
"SLANG_FORCE_INLINE double Int64AsDouble(int64_t value)\n"
"{\n"
"    return Math::DoubleInt64Union::makeFromInt64(value).dvalue;\n"
"}\n"
"\n"
"inline unsigned short FloatToHalf(float val)\n"
"{\n"
"    const auto x = FloatAsInt(val);\n"
"\n"
"    unsigned short bits = (x >> 16) & 0x8000;\n"
"    unsigned short m = (x >> 12) & 0x07ff;\n"
"    unsigned int e = (x >> 23) & 0xff;\n"
"    if (e < 103)\n"
"        return bits;\n"
"    if (e > 142)\n"
"    {\n"
"        bits |= 0x7c00u;\n"
"        bits |= e == 255 && (x & 0x007fffffu);\n"
"        return bits;\n"
"    }\n"
"    if (e < 113)\n"
"    {\n"
"        m |= 0x0800u;\n"
"        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n"
"        return bits;\n"
"    }\n"
"    bits |= ((e - 112) << 10) | (m >> 1);\n"
"    bits += m & 1;\n"
"    return bits;\n"
"}\n"
"\n"
"inline float HalfToFloat(unsigned short input)\n"
"{\n"
"    static const auto magic = Math::FloatIntUnion::makeFromInt((127 + (127 - 15)) << 23);\n"
"    static const auto was_infnan = Math::FloatIntUnion::makeFromInt((127 + 16) << 23);\n"
"    Math::FloatIntUnion o;\n"
"    o.ivalue = (input & 0x7fff) << 13; // exponent/mantissa bits\n"
"    o.fvalue *= magic.fvalue;          // exponent adjust\n"
"    if (o.fvalue >= was_infnan.fvalue) // make sure Inf/NaN survive\n"
"        o.ivalue |= 255 << 23;\n"
"    o.ivalue |= (input & 0x8000) << 16; // sign bit\n"
"    return o.fvalue;\n"
"}\n"
"\n"
"class Random\n"
"{\n"
"private:\n"
"    unsigned int seed;\n"
"\n"
"public:\n"
"    Random(int seed) { this->seed = seed; }\n"
"    int Next() // random between 0 and RandMax (currently 0x7fff)\n"
"    {\n"
"        return ((seed = ((seed << 12) + 150889L) % 714025) & 0x7fff);\n"
"    }\n"
"    int Next(int min, int max) // inclusive min, exclusive max\n"
"    {\n"
"        unsigned int a = ((seed = ((seed << 12) + 150889L) % 714025) & 0xFFFF);\n"
"        unsigned int b = ((seed = ((seed << 12) + 150889L) % 714025) & 0xFFFF);\n"
"        unsigned int r = (a << 16) + b;\n"
"        return min + r % (max - min);\n"
"    }\n"
"    float NextFloat() { return ((Next() << 15) + Next()) / ((float)(1 << 30)); }\n"
"    float NextFloat(float valMin, float valMax) { return valMin + (valMax - valMin) * NextFloat(); }\n"
"    static int RandMax() { return 0x7fff; }\n"
"};\n"
"} // namespace Slang\n"
"\n"
"#endif\n"
"\n"
"\n"
"///////////////////////// ankerl::unordered_dense::{map, set} /////////////////////////\n"
"\n"
"// A fast & densely stored hashmap and hashset based on robin-hood backward shift deletion.\n"
"// Version 4.5.0\n"
"// https://github.com/martinus/unordered_dense\n"
"//\n"
"// Licensed under the MIT License <http://opensource.org/licenses/MIT>.\n"
"// SPDX-License-Identifier: MIT\n"
"// Copyright (c) 2022-2024 Martin Leitner-Ankerl <martin.ankerl@gmail.com>\n"
"//\n"
"// Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"// of this software and associated documentation files (the \"Software\"), to deal\n"
"// in the Software without restriction, including without limitation the rights\n"
"// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"// copies of the Software, and to permit persons to whom the Software is\n"
"// furnished to do so, subject to the following conditions:\n"
"//\n"
"// The above copyright notice and this permission notice shall be included in all\n"
"// copies or substantial portions of the Software.\n"
"//\n"
"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
"// SOFTWARE.\n"
"\n"
"#ifndef ANKERL_UNORDERED_DENSE_H\n"
"#define ANKERL_UNORDERED_DENSE_H\n"
"\n"
"// see https://semver.org/spec/v2.0.0.html\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_MAJOR 4 // NOLINT(cppcoreguidelines-macro-usage) incompatible API changes\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_MINOR 5 // NOLINT(cppcoreguidelines-macro-usage) backwards compatible functionality\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_PATCH 0 // NOLINT(cppcoreguidelines-macro-usage) backwards compatible bug fixes\n"
"\n"
;
sb << 
"// API versioning with inline namespace, see https://www.foonathan.net/2018/11/inline-namespaces/\n"
"\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_CONCAT1(major, minor, patch) v##major##_##minor##_##patch\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#define ANKERL_UNORDERED_DENSE_VERSION_CONCAT(major, minor, patch) ANKERL_UNORDERED_DENSE_VERSION_CONCAT1(major, minor, patch)\n"
"#define ANKERL_UNORDERED_DENSE_NAMESPACE   \\\n"
"    ANKERL_UNORDERED_DENSE_VERSION_CONCAT( \\\n"
"        ANKERL_UNORDERED_DENSE_VERSION_MAJOR, ANKERL_UNORDERED_DENSE_VERSION_MINOR, ANKERL_UNORDERED_DENSE_VERSION_PATCH)\n"
"\n"
"#if defined(_MSVC_LANG)\n"
"#    define ANKERL_UNORDERED_DENSE_CPP_VERSION _MSVC_LANG\n"
"#else\n"
"#    define ANKERL_UNORDERED_DENSE_CPP_VERSION __cplusplus\n"
"#endif\n"
"\n"
"#if defined(__GNUC__)\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#    define ANKERL_UNORDERED_DENSE_PACK(decl) decl __attribute__((__packed__))\n"
"#elif defined(_MSC_VER)\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#    define ANKERL_UNORDERED_DENSE_PACK(decl) __pragma(pack(push, 1)) decl __pragma(pack(pop))\n"
"#endif\n"
"\n"
"// exceptions\n"
"#if defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)\n"
"#    define ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS() 1 // NOLINT(cppcoreguidelines-macro-usage)\n"
"#else\n"
"#    define ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS() 0 // NOLINT(cppcoreguidelines-macro-usage)\n"
"#endif\n"
"#ifdef _MSC_VER\n"
"#    define ANKERL_UNORDERED_DENSE_NOINLINE __declspec(noinline)\n"
"#else\n"
"#    define ANKERL_UNORDERED_DENSE_NOINLINE __attribute__((noinline))\n"
"#endif\n"
"\n"
"// defined in unordered_dense.cpp\n"
"#if !defined(ANKERL_UNORDERED_DENSE_EXPORT)\n"
"#    define ANKERL_UNORDERED_DENSE_EXPORT\n"
"#endif\n"
"\n"
"#if ANKERL_UNORDERED_DENSE_CPP_VERSION < 201703L\n"
"#    error ankerl::unordered_dense requires C++17 or higher\n"
"#else\n"
"#    include <array>            // for array\n"
"#    include <cstdint>          // for uint64_t, uint32_t, uint8_t, UINT64_C\n"
"#    include <cstring>          // for size_t, memcpy, memset\n"
"#    include <functional>       // for equal_to, hash\n"
"#    include <initializer_list> // for initializer_list\n"
"#    include <iterator>         // for pair, distance\n"
"#    include <limits>           // for numeric_limits\n"
"#    include <memory>           // for allocator, allocator_traits, shared_ptr\n"
"#    include <optional>         // for optional\n"
"#    include <stdexcept>        // for out_of_range\n"
"#    include <string>           // for basic_string\n"
"#    include <string_view>      // for basic_string_view, hash\n"
"#    include <tuple>            // for forward_as_tuple\n"
"#    include <type_traits>      // for enable_if_t, declval, conditional_t, ena...\n"
"#    include <utility>          // for forward, exchange, pair, as_const, piece...\n"
"#    include <vector>           // for vector\n"
"#    if ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS() == 0\n"
"#        include <cstdlib> // for abort\n"
"#    endif\n"
"\n"
"#    if defined(__has_include) && !defined(ANKERL_UNORDERED_DENSE_DISABLE_PMR)\n"
"#        if __has_include(<memory_resource>)\n"
"#            define ANKERL_UNORDERED_DENSE_PMR std::pmr // NOLINT(cppcoreguidelines-macro-usage)\n"
"#            include <memory_resource>                  // for polymorphic_allocator\n"
"#        elif __has_include(<experimental/memory_resource>)\n"
"#            define ANKERL_UNORDERED_DENSE_PMR std::experimental::pmr // NOLINT(cppcoreguidelines-macro-usage)\n"
"#            include <experimental/memory_resource>                   // for polymorphic_allocator\n"
"#        endif\n"
"#    endif\n"
"\n"
"#    if defined(_MSC_VER) && defined(_M_X64)\n"
"#        include <intrin.h>\n"
"#        pragma intrinsic(_umul128)\n"
"#    endif\n"
"\n"
"#    if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)\n"
"#        define ANKERL_UNORDERED_DENSE_LIKELY(x) __builtin_expect(x, 1)   // NOLINT(cppcoreguidelines-macro-usage)\n"
"#        define ANKERL_UNORDERED_DENSE_UNLIKELY(x) __builtin_expect(x, 0) // NOLINT(cppcoreguidelines-macro-usage)\n"
"#    else\n"
"#        define ANKERL_UNORDERED_DENSE_LIKELY(x) (x)   // NOLINT(cppcoreguidelines-macro-usage)\n"
"#        define ANKERL_UNORDERED_DENSE_UNLIKELY(x) (x) // NOLINT(cppcoreguidelines-macro-usage)\n"
"#    endif\n"
"\n"
"namespace ankerl::unordered_dense {\n"
"inline namespace ANKERL_UNORDERED_DENSE_NAMESPACE {\n"
"\n"
"namespace detail {\n"
"\n"
"#    if ANKERL_UNORDERED_DENSE_HAS_EXCEPTIONS()\n"
"\n"
"// make sure this is not inlined as it is slow and dramatically enlarges code, thus making other\n"
"// inlinings more difficult. Throws are also generally the slow path.\n"
"[[noreturn]] inline ANKERL_UNORDERED_DENSE_NOINLINE void on_error_key_not_found() {\n"
"    throw std::out_of_range(\"ankerl::unordered_dense::map::at(): key not found\");\n"
"}\n"
"[[noreturn]] inline ANKERL_UNORDERED_DENSE_NOINLINE void on_error_bucket_overflow() {\n"
"    throw std::overflow_error(\"ankerl::unordered_dense: reached max bucket size, cannot increase size\");\n"
"}\n"
"[[noreturn]] inline ANKERL_UNORDERED_DENSE_NOINLINE void on_error_too_many_elements() {\n"
"    throw std::out_of_range(\"ankerl::unordered_dense::map::replace(): too many elements\");\n"
"}\n"
"\n"
"#    else\n"
"\n"
"[[noreturn]] inline void on_error_key_not_found() {\n"
"    abort();\n"
"}\n"
"[[noreturn]] inline void on_error_bucket_overflow() {\n"
"    abort();\n"
"}\n"
"[[noreturn]] inline void on_error_too_many_elements() {\n"
"    abort();\n"
"}\n"
"\n"
"#    endif\n"
"\n"
"} // namespace detail\n"
"\n"
"// hash ///////////////////////////////////////////////////////////////////////\n"
"\n"
"// This is a stripped-down implementation of wyhash: https://github.com/wangyi-fudan/wyhash\n"
"// No big-endian support (because different values on different machines don't matter),\n"
"// hardcodes seed and the secret, reformats the code, and clang-tidy fixes.\n"
"namespace detail::wyhash {\n"
"\n"
"inline void mum(uint64_t* a, uint64_t* b) {\n"
"#    if defined(__SIZEOF_INT128__)\n"
"    __uint128_t r = *a;\n"
"    r *= *b;\n"
"    *a = static_cast<uint64_t>(r);\n"
"    *b = static_cast<uint64_t>(r >> 64U);\n"
"#    elif defined(_MSC_VER) && defined(_M_X64)\n"
"    *a = _umul128(*a, *b, b);\n"
"#    else\n"
"    uint64_t ha = *a >> 32U;\n"
"    uint64_t hb = *b >> 32U;\n"
"    uint64_t la = static_cast<uint32_t>(*a);\n"
"    uint64_t lb = static_cast<uint32_t>(*b);\n"
"    uint64_t hi{};\n"
"    uint64_t lo{};\n"
"    uint64_t rh = ha * hb;\n"
"    uint64_t rm0 = ha * lb;\n"
"    uint64_t rm1 = hb * la;\n"
"    uint64_t rl = la * lb;\n"
"    uint64_t t = rl + (rm0 << 32U);\n"
"    auto c = static_cast<uint64_t>(t < rl);\n"
"    lo = t + (rm1 << 32U);\n"
"    c += static_cast<uint64_t>(lo < t);\n"
"    hi = rh + (rm0 >> 32U) + (rm1 >> 32U) + c;\n"
"    *a = lo;\n"
"    *b = hi;\n"
"#    endif\n"
"}\n"
"\n"
"// multiply and xor mix function, aka MUM\n"
"[[nodiscard]] inline auto mix(uint64_t a, uint64_t b) -> uint64_t {\n"
"    mum(&a, &b);\n"
"    return a ^ b;\n"
"}\n"
"\n"
"// read functions. WARNING: we don't care about endianness, so results are different on big endian!\n"
"[[nodiscard]] inline auto r8(const uint8_t* p) -> uint64_t {\n"
"    uint64_t v{};\n"
"    std::memcpy(&v, p, 8U);\n"
"    return v;\n"
"}\n"
"\n"
"[[nodiscard]] inline auto r4(const uint8_t* p) -> uint64_t {\n"
"    uint32_t v{};\n"
"    std::memcpy(&v, p, 4);\n"
"    return v;\n"
"}\n"
"\n"
"// reads 1, 2, or 3 bytes\n"
"[[nodiscard]] inline auto r3(const uint8_t* p, size_t k) -> uint64_t {\n"
"    return (static_cast<uint64_t>(p[0]) << 16U) | (static_cast<uint64_t>(p[k >> 1U]) << 8U) | p[k - 1];\n"
"}\n"
"\n"
"[[maybe_unused]] [[nodiscard]] inline auto hash(void const* key, size_t len) -> uint64_t {\n"
"    static constexpr auto secret = std::array{UINT64_C(0xa0761d6478bd642f),\n"
"                                              UINT64_C(0xe7037ed1a0b428db),\n"
"                                              UINT64_C(0x8ebc6af09c88c6e3),\n"
"                                              UINT64_C(0x589965cc75374cc3)};\n"
"\n"
"    auto const* p = static_cast<uint8_t const*>(key);\n"
"    uint64_t seed = secret[0];\n"
"    uint64_t a{};\n"
"    uint64_t b{};\n"
"    if (ANKERL_UNORDERED_DENSE_LIKELY(len <= 16)) {\n"
"        if (ANKERL_UNORDERED_DENSE_LIKELY(len >= 4)) {\n"
"            a = (r4(p) << 32U) | r4(p + ((len >> 3U) << 2U));\n"
"            b = (r4(p + len - 4) << 32U) | r4(p + len - 4 - ((len >> 3U) << 2U));\n"
"        } else if (ANKERL_UNORDERED_DENSE_LIKELY(len > 0)) {\n"
"            a = r3(p, len);\n"
"            b = 0;\n"
"        } else {\n"
"            a = 0;\n"
"            b = 0;\n"
"        }\n"
"    } else {\n"
"        size_t i = len;\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(i > 48)) {\n"
"            uint64_t see1 = seed;\n"
"            uint64_t see2 = seed;\n"
"            do {\n"
"                seed = mix(r8(p) ^ secret[1], r8(p + 8) ^ seed);\n"
"                see1 = mix(r8(p + 16) ^ secret[2], r8(p + 24) ^ see1);\n"
"                see2 = mix(r8(p + 32) ^ secret[3], r8(p + 40) ^ see2);\n"
"                p += 48;\n"
"                i -= 48;\n"
"            } while (ANKERL_UNORDERED_DENSE_LIKELY(i > 48));\n"
"            seed ^= see1 ^ see2;\n"
"        }\n"
"        while (ANKERL_UNORDERED_DENSE_UNLIKELY(i > 16)) {\n"
"            seed = mix(r8(p) ^ secret[1], r8(p + 8) ^ seed);\n"
"            i -= 16;\n"
"            p += 16;\n"
"        }\n"
"        a = r8(p + i - 16);\n"
"        b = r8(p + i - 8);\n"
"    }\n"
"\n"
"    return mix(secret[1] ^ len, mix(a ^ secret[1], b ^ seed));\n"
"}\n"
"\n"
"[[nodiscard]] inline auto hash(uint64_t x) -> uint64_t {\n"
"    return detail::wyhash::mix(x, UINT64_C(0x9E3779B97F4A7C15));\n"
"}\n"
"\n"
"} // namespace detail::wyhash\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <typename T, typename Enable = void>\n"
"struct hash {\n"
"    auto operator()(T const& obj) const noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>())))\n"
"        -> uint64_t {\n"
"        return std::hash<T>{}(obj);\n"
"    }\n"
"};\n"
"\n"
"template <typename T>\n"
"struct hash<T, typename std::hash<T>::is_avalanching> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(T const& obj) const noexcept(noexcept(std::declval<std::hash<T>>().operator()(std::declval<T const&>())))\n"
"        -> uint64_t {\n"
"        return std::hash<T>{}(obj);\n"
"    }\n"
"};\n"
"\n"
"template <typename CharT>\n"
"struct hash<std::basic_string<CharT>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::basic_string<CharT> const& str) const noexcept -> uint64_t {\n"
"        return detail::wyhash::hash(str.data(), sizeof(CharT) * str.size());\n"
"    }\n"
"};\n"
"\n"
"template <typename CharT>\n"
"struct hash<std::basic_string_view<CharT>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::basic_string_view<CharT> const& sv) const noexcept -> uint64_t {\n"
"        return detail::wyhash::hash(sv.data(), sizeof(CharT) * sv.size());\n"
"    }\n"
"};\n"
"\n"
"template <class T>\n"
"struct hash<T*> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(T* ptr) const noexcept -> uint64_t {\n"
"        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n"
"        return detail::wyhash::hash(reinterpret_cast<uintptr_t>(ptr));\n"
"    }\n"
"};\n"
"\n"
"template <class T>\n"
"struct hash<std::unique_ptr<T>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::unique_ptr<T> const& ptr) const noexcept -> uint64_t {\n"
"        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n"
"        return detail::wyhash::hash(reinterpret_cast<uintptr_t>(ptr.get()));\n"
"    }\n"
"};\n"
"\n"
"template <class T>\n"
"struct hash<std::shared_ptr<T>> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::shared_ptr<T> const& ptr) const noexcept -> uint64_t {\n"
"        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)\n"
"        return detail::wyhash::hash(reinterpret_cast<uintptr_t>(ptr.get()));\n"
"    }\n"
"};\n"
"\n"
"template <typename Enum>\n"
"struct hash<Enum, typename std::enable_if<std::is_enum<Enum>::value>::type> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(Enum e) const noexcept -> uint64_t {\n"
"        using underlying = typename std::underlying_type_t<Enum>;\n"
"        return detail::wyhash::hash(static_cast<underlying>(e));\n"
"    }\n"
"};\n"
"\n"
"template <typename... Args>\n"
"struct tuple_hash_helper {\n"
"    // Converts the value into 64bit. If it is an integral type, just cast it. Mixing is doing the rest.\n"
"    // If it isn't an integral we need to hash it.\n"
"    template <typename Arg>\n"
"    [[nodiscard]] constexpr static auto to64(Arg const& arg) -> uint64_t {\n"
"        if constexpr (std::is_integral_v<Arg> || std::is_enum_v<Arg>) {\n"
"            return static_cast<uint64_t>(arg);\n"
"        } else {\n"
"            return hash<Arg>{}(arg);\n"
"        }\n"
"    }\n"
"\n"
"    [[nodiscard]] static auto mix64(uint64_t state, uint64_t v) -> uint64_t {\n"
"        return detail::wyhash::mix(state + v, uint64_t{0x9ddfea08eb382d69});\n"
"    }\n"
"\n"
"    // Creates a buffer that holds all the data from each element of the tuple. If possible we memcpy the data directly. If\n"
"    // not, we hash the object and use this for the array. Size of the array is known at compile time, and memcpy is optimized\n"
"    // away, so filling the buffer is highly efficient. Finally, call wyhash with this buffer.\n"
"    template <typename T, std::size_t... Idx>\n"
"    [[nodiscard]] static auto calc_hash(T const& t, std::index_sequence<Idx...>) noexcept -> uint64_t {\n"
"        auto h = uint64_t{};\n"
"        ((h = mix64(h, to64(std::get<Idx>(t)))), ...);\n"
"        return h;\n"
"    }\n"
"};\n"
"\n"
"template <typename... Args>\n"
"struct hash<std::tuple<Args...>> : tuple_hash_helper<Args...> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::tuple<Args...> const& t) const noexcept -> uint64_t {\n"
"        return tuple_hash_helper<Args...>::calc_hash(t, std::index_sequence_for<Args...>{});\n"
"    }\n"
"};\n"
"\n"
"template <typename A, typename B>\n"
"struct hash<std::pair<A, B>> : tuple_hash_helper<A, B> {\n"
"    using is_avalanching = void;\n"
"    auto operator()(std::pair<A, B> const& t) const noexcept -> uint64_t {\n"
"        return tuple_hash_helper<A, B>::calc_hash(t, std::index_sequence_for<A, B>{});\n"
"    }\n"
"};\n"
"\n"
"// NOLINTNEXTLINE(cppcoreguidelines-macro-usage)\n"
"#    define ANKERL_UNORDERED_DENSE_HASH_STATICCAST(T)                    \\\n"
"        template <>                                                      \\\n"
"        struct hash<T> {                                                 \\\n"
"            using is_avalanching = void;                                 \\\n"
"            auto operator()(T const& obj) const noexcept -> uint64_t {   \\\n"
"                return detail::wyhash::hash(static_cast<uint64_t>(obj)); \\\n"
"            }                                                            \\\n"
"        }\n"
"\n"
"#    if defined(__GNUC__) && !defined(__clang__)\n"
"#        pragma GCC diagnostic push\n"
"#        pragma GCC diagnostic ignored \"-Wuseless-cast\"\n"
"#    endif\n"
"// see https://en.cppreference.com/w/cpp/utility/hash\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(bool);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(signed char);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned char);\n"
"#    if ANKERL_UNORDERED_DENSE_CPP_VERSION >= 202002L && defined(__cpp_char8_t)\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char8_t);\n"
"#    endif\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char16_t);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(char32_t);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(wchar_t);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(short);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned short);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(int);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned int);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(long);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(long long);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned long);\n"
"ANKERL_UNORDERED_DENSE_HASH_STATICCAST(unsigned long long);\n"
"\n"
"#    if defined(__GNUC__) && !defined(__clang__)\n"
"#        pragma GCC diagnostic pop\n"
"#    endif\n"
"\n"
"// bucket_type //////////////////////////////////////////////////////////\n"
"\n"
"namespace bucket_type {\n"
"\n"
"struct standard {\n"
"    static constexpr uint32_t dist_inc = 1U << 8U;             // skip 1 byte fingerprint\n"
"    static constexpr uint32_t fingerprint_mask = dist_inc - 1; // mask for 1 byte of fingerprint\n"
"\n"
"    uint32_t m_dist_and_fingerprint; // upper 3 byte: distance to original bucket. lower byte: fingerprint from hash\n"
"    uint32_t m_value_idx;            // index into the m_values vector.\n"
"};\n"
"\n"
"ANKERL_UNORDERED_DENSE_PACK(struct big {\n"
"    static constexpr uint32_t dist_inc = 1U << 8U;             // skip 1 byte fingerprint\n"
"    static constexpr uint32_t fingerprint_mask = dist_inc - 1; // mask for 1 byte of fingerprint\n"
"\n"
"    uint32_t m_dist_and_fingerprint; // upper 3 byte: distance to original bucket. lower byte: fingerprint from hash\n"
"    size_t m_value_idx;              // index into the m_values vector.\n"
"});\n"
"\n"
"} // namespace bucket_type\n"
"\n"
"namespace detail {\n"
"\n"
"struct nonesuch {};\n"
"struct default_container_t {};\n"
"\n"
"template <class Default, class AlwaysVoid, template <class...> class Op, class... Args>\n"
"struct detector {\n"
"    using value_t = std::false_type;\n"
"    using type = Default;\n"
"};\n"
"\n"
"template <class Default, template <class...> class Op, class... Args>\n"
"struct detector<Default, std::void_t<Op<Args...>>, Op, Args...> {\n"
"    using value_t = std::true_type;\n"
"    using type = Op<Args...>;\n"
"};\n"
"\n"
"template <template <class...> class Op, class... Args>\n"
"using is_detected = typename detail::detector<detail::nonesuch, void, Op, Args...>::value_t;\n"
"\n"
"template <template <class...> class Op, class... Args>\n"
"constexpr bool is_detected_v = is_detected<Op, Args...>::value;\n"
"\n"
;
sb << 
"template <typename T>\n"
"using detect_avalanching = typename T::is_avalanching;\n"
"\n"
"template <typename T>\n"
"using detect_is_transparent = typename T::is_transparent;\n"
"\n"
"template <typename T>\n"
"using detect_iterator = typename T::iterator;\n"
"\n"
"template <typename T>\n"
"using detect_reserve = decltype(std::declval<T&>().reserve(size_t{}));\n"
"\n"
"// enable_if helpers\n"
"\n"
"template <typename Mapped>\n"
"constexpr bool is_map_v = !std::is_void_v<Mapped>;\n"
"\n"
"// clang-format off\n"
"template <typename Hash, typename KeyEqual>\n"
"constexpr bool is_transparent_v = is_detected_v<detect_is_transparent, Hash> && is_detected_v<detect_is_transparent, KeyEqual>;\n"
"// clang-format on\n"
"\n"
"template <typename From, typename To1, typename To2>\n"
"constexpr bool is_neither_convertible_v = !std::is_convertible_v<From, To1> && !std::is_convertible_v<From, To2>;\n"
"\n"
"template <typename T>\n"
"constexpr bool has_reserve = is_detected_v<detect_reserve, T>;\n"
"\n"
"// base type for map has mapped_type\n"
"template <class T>\n"
"struct base_table_type_map {\n"
"    using mapped_type = T;\n"
"};\n"
"\n"
"// base type for set doesn't have mapped_type\n"
"struct base_table_type_set {};\n"
"\n"
"} // namespace detail\n"
"\n"
"// Very much like std::deque, but faster for indexing (in most cases). As of now this doesn't implement the full std::vector\n"
"// API, but merely what's necessary to work as an underlying container for ankerl::unordered_dense::{map, set}.\n"
"// It allocates blocks of equal size and puts them into the m_blocks vector. That means it can grow simply by adding a new\n"
"// block to the back of m_blocks, and doesn't double its size like an std::vector. The disadvantage is that memory is not\n"
"// linear and thus there is one more indirection necessary for indexing.\n"
"template <typename T, typename Allocator = std::allocator<T>, size_t MaxSegmentSizeBytes = 4096>\n"
"class segmented_vector {\n"
"    template <bool IsConst>\n"
"    class iter_t;\n"
"\n"
"public:\n"
"    using allocator_type = Allocator;\n"
"    using pointer = typename std::allocator_traits<allocator_type>::pointer;\n"
"    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;\n"
"    using difference_type = typename std::allocator_traits<allocator_type>::difference_type;\n"
"    using value_type = T;\n"
"    using size_type = std::size_t;\n"
"    using reference = T&;\n"
"    using const_reference = T const&;\n"
"    using iterator = iter_t<false>;\n"
"    using const_iterator = iter_t<true>;\n"
"\n"
"private:\n"
"    using vec_alloc = typename std::allocator_traits<Allocator>::template rebind_alloc<pointer>;\n"
"    std::vector<pointer, vec_alloc> m_blocks{};\n"
"    size_t m_size{};\n"
"\n"
"    // Calculates the maximum number for x in  (s << x) <= max_val\n"
"    static constexpr auto num_bits_closest(size_t max_val, size_t s) -> size_t {\n"
"        auto f = size_t{0};\n"
"        while (s << (f + 1) <= max_val) {\n"
"            ++f;\n"
"        }\n"
"        return f;\n"
"    }\n"
"\n"
"    using self_t = segmented_vector<T, Allocator, MaxSegmentSizeBytes>;\n"
"    static constexpr auto num_bits = num_bits_closest(MaxSegmentSizeBytes, sizeof(T));\n"
"    static constexpr auto num_elements_in_block = 1U << num_bits;\n"
"    static constexpr auto mask = num_elements_in_block - 1U;\n"
"\n"
"    /**\n"
"     * Iterator class doubles as const_iterator and iterator\n"
"     */\n"
"    template <bool IsConst>\n"
"    class iter_t {\n"
"        using ptr_t = typename std::conditional_t<IsConst, segmented_vector::const_pointer const*, segmented_vector::pointer*>;\n"
"        ptr_t m_data{};\n"
"        size_t m_idx{};\n"
"\n"
"        template <bool B>\n"
"        friend class iter_t;\n"
"\n"
"    public:\n"
"        using difference_type = segmented_vector::difference_type;\n"
"        using value_type = T;\n"
"        using reference = typename std::conditional_t<IsConst, value_type const&, value_type&>;\n"
"        using pointer = typename std::conditional_t<IsConst, segmented_vector::const_pointer, segmented_vector::pointer>;\n"
"        using iterator_category = std::forward_iterator_tag;\n"
"\n"
"        iter_t() noexcept = default;\n"
"\n"
"        template <bool OtherIsConst, typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n"
"        // NOLINTNEXTLINE(google-explicit-constructor,hicpp-explicit-conversions)\n"
"        constexpr iter_t(iter_t<OtherIsConst> const& other) noexcept\n"
"            : m_data(other.m_data)\n"
"            , m_idx(other.m_idx) {}\n"
"\n"
"        constexpr iter_t(ptr_t data, size_t idx) noexcept\n"
"            : m_data(data)\n"
"            , m_idx(idx) {}\n"
"\n"
"        template <bool OtherIsConst, typename = typename std::enable_if<IsConst && !OtherIsConst>::type>\n"
"        constexpr auto operator=(iter_t<OtherIsConst> const& other) noexcept -> iter_t& {\n"
"            m_data = other.m_data;\n"
"            m_idx = other.m_idx;\n"
"            return *this;\n"
"        }\n"
"\n"
"        constexpr auto operator++() noexcept -> iter_t& {\n"
"            ++m_idx;\n"
"            return *this;\n"
"        }\n"
"\n"
"        constexpr auto operator++(int) noexcept -> iter_t {\n"
"            iter_t prev(*this);\n"
"            this->operator++();\n"
"            return prev;\n"
"        }\n"
"\n"
"        constexpr auto operator+(difference_type diff) noexcept -> iter_t {\n"
"            return {m_data, static_cast<size_t>(static_cast<difference_type>(m_idx) + diff)};\n"
"        }\n"
"\n"
"        template <bool OtherIsConst>\n"
"        constexpr auto operator-(iter_t<OtherIsConst> const& other) noexcept -> difference_type {\n"
"            return static_cast<difference_type>(m_idx) - static_cast<difference_type>(other.m_idx);\n"
"        }\n"
"\n"
"        constexpr auto operator*() const noexcept -> reference {\n"
"            return m_data[m_idx >> num_bits][m_idx & mask];\n"
"        }\n"
"\n"
"        constexpr auto operator->() const noexcept -> pointer {\n"
"            return &m_data[m_idx >> num_bits][m_idx & mask];\n"
"        }\n"
"\n"
"        template <bool O>\n"
"        constexpr auto operator==(iter_t<O> const& o) const noexcept -> bool {\n"
"            return m_idx == o.m_idx;\n"
"        }\n"
"\n"
"        template <bool O>\n"
"        constexpr auto operator!=(iter_t<O> const& o) const noexcept -> bool {\n"
"            return !(*this == o);\n"
"        }\n"
"    };\n"
"\n"
"    // slow path: need to allocate a new segment every once in a while\n"
"    void increase_capacity() {\n"
"        auto ba = Allocator(m_blocks.get_allocator());\n"
"        pointer block = std::allocator_traits<Allocator>::allocate(ba, num_elements_in_block);\n"
"        m_blocks.push_back(block);\n"
"    }\n"
"\n"
"    // Moves everything from other\n"
"    void append_everything_from(segmented_vector&& other) {\n"
"        reserve(size() + other.size());\n"
"        for (auto&& o : other) {\n"
"            emplace_back(std::move(o));\n"
"        }\n"
"    }\n"
"\n"
"    // Copies everything from other\n"
"    void append_everything_from(segmented_vector const& other) {\n"
"        reserve(size() + other.size());\n"
"        for (auto const& o : other) {\n"
"            emplace_back(o);\n"
"        }\n"
"    }\n"
"\n"
"    void dealloc() {\n"
"        auto ba = Allocator(m_blocks.get_allocator());\n"
"        for (auto ptr : m_blocks) {\n"
"            std::allocator_traits<Allocator>::deallocate(ba, ptr, num_elements_in_block);\n"
"        }\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto calc_num_blocks_for_capacity(size_t capacity) {\n"
"        return (capacity + num_elements_in_block - 1U) / num_elements_in_block;\n"
"    }\n"
"\n"
"public:\n"
"    segmented_vector() = default;\n"
"\n"
"    // NOLINTNEXTLINE(google-explicit-constructor,hicpp-explicit-conversions)\n"
"    segmented_vector(Allocator alloc)\n"
"        : m_blocks(vec_alloc(alloc)) {}\n"
"\n"
"    segmented_vector(segmented_vector&& other, Allocator alloc)\n"
"        : segmented_vector(alloc) {\n"
"        *this = std::move(other);\n"
"    }\n"
"\n"
"    segmented_vector(segmented_vector const& other, Allocator alloc)\n"
"        : m_blocks(vec_alloc(alloc)) {\n"
"        append_everything_from(other);\n"
"    }\n"
"\n"
"    segmented_vector(segmented_vector&& other) noexcept\n"
"        : segmented_vector(std::move(other), get_allocator()) {}\n"
"\n"
"    segmented_vector(segmented_vector const& other) {\n"
"        append_everything_from(other);\n"
"    }\n"
"\n"
"    auto operator=(segmented_vector const& other) -> segmented_vector& {\n"
"        if (this == &other) {\n"
"            return *this;\n"
"        }\n"
"        clear();\n"
"        append_everything_from(other);\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto operator=(segmented_vector&& other) noexcept -> segmented_vector& {\n"
"        clear();\n"
"        dealloc();\n"
"        if (other.get_allocator() == get_allocator()) {\n"
"            m_blocks = std::move(other.m_blocks);\n"
"            m_size = std::exchange(other.m_size, {});\n"
"        } else {\n"
"            // make sure to construct with other's allocator!\n"
"            m_blocks = std::vector<pointer, vec_alloc>(vec_alloc(other.get_allocator()));\n"
"            append_everything_from(std::move(other));\n"
"        }\n"
"        return *this;\n"
"    }\n"
"\n"
"    ~segmented_vector() {\n"
"        clear();\n"
"        dealloc();\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto size() const -> size_t {\n"
"        return m_size;\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto capacity() const -> size_t {\n"
"        return m_blocks.size() * num_elements_in_block;\n"
"    }\n"
"\n"
"    // Indexing is highly performance critical\n"
"    [[nodiscard]] constexpr auto operator[](size_t i) const noexcept -> T const& {\n"
"        return m_blocks[i >> num_bits][i & mask];\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto operator[](size_t i) noexcept -> T& {\n"
"        return m_blocks[i >> num_bits][i & mask];\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto begin() -> iterator {\n"
"        return {m_blocks.data(), 0U};\n"
"    }\n"
"    [[nodiscard]] constexpr auto begin() const -> const_iterator {\n"
"        return {m_blocks.data(), 0U};\n"
"    }\n"
"    [[nodiscard]] constexpr auto cbegin() const -> const_iterator {\n"
"        return {m_blocks.data(), 0U};\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto end() -> iterator {\n"
"        return {m_blocks.data(), m_size};\n"
"    }\n"
"    [[nodiscard]] constexpr auto end() const -> const_iterator {\n"
"        return {m_blocks.data(), m_size};\n"
"    }\n"
"    [[nodiscard]] constexpr auto cend() const -> const_iterator {\n"
"        return {m_blocks.data(), m_size};\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto back() -> reference {\n"
"        return operator[](m_size - 1);\n"
"    }\n"
"    [[nodiscard]] constexpr auto back() const -> const_reference {\n"
"        return operator[](m_size - 1);\n"
"    }\n"
"\n"
"    void pop_back() {\n"
"        back().~T();\n"
"        --m_size;\n"
"    }\n"
"\n"
"    [[nodiscard]] auto empty() const {\n"
"        return 0 == m_size;\n"
"    }\n"
"\n"
"    void reserve(size_t new_capacity) {\n"
"        m_blocks.reserve(calc_num_blocks_for_capacity(new_capacity));\n"
"        while (new_capacity > capacity()) {\n"
"            increase_capacity();\n"
"        }\n"
"    }\n"
"\n"
"    [[nodiscard]] auto get_allocator() const -> allocator_type {\n"
"        return allocator_type{m_blocks.get_allocator()};\n"
"    }\n"
"\n"
"    template <class... Args>\n"
"    auto emplace_back(Args&&... args) -> reference {\n"
"        if (m_size == capacity()) {\n"
"            increase_capacity();\n"
"        }\n"
"        auto* ptr = static_cast<void*>(&operator[](m_size));\n"
"        auto& ref = *new (ptr) T(std::forward<Args>(args)...);\n"
"        ++m_size;\n"
"        return ref;\n"
"    }\n"
"\n"
"    void clear() {\n"
"        if constexpr (!std::is_trivially_destructible_v<T>) {\n"
"            for (size_t i = 0, s = size(); i < s; ++i) {\n"
"                operator[](i).~T();\n"
"            }\n"
"        }\n"
"        m_size = 0;\n"
"    }\n"
"\n"
"    void shrink_to_fit() {\n"
"        auto ba = Allocator(m_blocks.get_allocator());\n"
"        auto num_blocks_required = calc_num_blocks_for_capacity(m_size);\n"
"        while (m_blocks.size() > num_blocks_required) {\n"
"            std::allocator_traits<Allocator>::deallocate(ba, m_blocks.back(), num_elements_in_block);\n"
"            m_blocks.pop_back();\n"
"        }\n"
"        m_blocks.shrink_to_fit();\n"
"    }\n"
"};\n"
"\n"
"namespace detail {\n"
"\n"
"// This is it, the table. Doubles as map and set, and uses `void` for T when its used as a set.\n"
"template <class Key,\n"
"          class T, // when void, treat it as a set.\n"
"          class Hash,\n"
"          class KeyEqual,\n"
"          class AllocatorOrContainer,\n"
"          class Bucket,\n"
"          class BucketContainer,\n"
"          bool IsSegmented>\n"
"class table : public std::conditional_t<is_map_v<T>, base_table_type_map<T>, base_table_type_set> {\n"
"    using underlying_value_type = typename std::conditional_t<is_map_v<T>, std::pair<Key, T>, Key>;\n"
"    using underlying_container_type = std::conditional_t<IsSegmented,\n"
"                                                         segmented_vector<underlying_value_type, AllocatorOrContainer>,\n"
"                                                         std::vector<underlying_value_type, AllocatorOrContainer>>;\n"
"\n"
"public:\n"
"    using value_container_type = std::\n"
"        conditional_t<is_detected_v<detect_iterator, AllocatorOrContainer>, AllocatorOrContainer, underlying_container_type>;\n"
"\n"
"private:\n"
"    using bucket_alloc =\n"
"        typename std::allocator_traits<typename value_container_type::allocator_type>::template rebind_alloc<Bucket>;\n"
"    using default_bucket_container_type =\n"
"        std::conditional_t<IsSegmented, segmented_vector<Bucket, bucket_alloc>, std::vector<Bucket, bucket_alloc>>;\n"
"\n"
"    using bucket_container_type = std::conditional_t<std::is_same_v<BucketContainer, detail::default_container_t>,\n"
"                                                     default_bucket_container_type,\n"
"                                                     BucketContainer>;\n"
"\n"
"    static constexpr uint8_t initial_shifts = 64 - 2; // 2^(64-m_shift) number of buckets\n"
"    static constexpr float default_max_load_factor = 0.8F;\n"
"\n"
"public:\n"
"    using key_type = Key;\n"
"    using value_type = typename value_container_type::value_type;\n"
"    using size_type = typename value_container_type::size_type;\n"
"    using difference_type = typename value_container_type::difference_type;\n"
"    using hasher = Hash;\n"
"    using key_equal = KeyEqual;\n"
"    using allocator_type = typename value_container_type::allocator_type;\n"
"    using reference = typename value_container_type::reference;\n"
"    using const_reference = typename value_container_type::const_reference;\n"
"    using pointer = typename value_container_type::pointer;\n"
"    using const_pointer = typename value_container_type::const_pointer;\n"
"    using const_iterator = typename value_container_type::const_iterator;\n"
"    using iterator = std::conditional_t<is_map_v<T>, typename value_container_type::iterator, const_iterator>;\n"
"    using bucket_type = Bucket;\n"
"\n"
"private:\n"
"    using value_idx_type = decltype(Bucket::m_value_idx);\n"
"    using dist_and_fingerprint_type = decltype(Bucket::m_dist_and_fingerprint);\n"
"\n"
"    static_assert(std::is_trivially_destructible_v<Bucket>, \"assert there's no need to call destructor / std::destroy\");\n"
"    static_assert(std::is_trivially_copyable_v<Bucket>, \"assert we can just memset / memcpy\");\n"
"\n"
"    value_container_type m_values{}; // Contains all the key-value pairs in one densely stored container. No holes.\n"
"    bucket_container_type m_buckets{};\n"
"    size_t m_max_bucket_capacity = 0;\n"
"    float m_max_load_factor = default_max_load_factor;\n"
"    Hash m_hash{};\n"
"    KeyEqual m_equal{};\n"
"    uint8_t m_shifts = initial_shifts;\n"
"\n"
"    [[nodiscard]] auto next(value_idx_type bucket_idx) const -> value_idx_type {\n"
"        return ANKERL_UNORDERED_DENSE_UNLIKELY(bucket_idx + 1U == bucket_count())\n"
"                   ? 0\n"
"                   : static_cast<value_idx_type>(bucket_idx + 1U);\n"
"    }\n"
"\n"
"    // Helper to access bucket through pointer types\n"
"    [[nodiscard]] static constexpr auto at(bucket_container_type& bucket, size_t offset) -> Bucket& {\n"
"        return bucket[offset];\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto at(const bucket_container_type& bucket, size_t offset) -> const Bucket& {\n"
"        return bucket[offset];\n"
"    }\n"
"\n"
"    // use the dist_inc and dist_dec functions so that uint16_t types work without warning\n"
"    [[nodiscard]] static constexpr auto dist_inc(dist_and_fingerprint_type x) -> dist_and_fingerprint_type {\n"
"        return static_cast<dist_and_fingerprint_type>(x + Bucket::dist_inc);\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto dist_dec(dist_and_fingerprint_type x) -> dist_and_fingerprint_type {\n"
"        return static_cast<dist_and_fingerprint_type>(x - Bucket::dist_inc);\n"
"    }\n"
"\n"
"    // The goal of mixed_hash is to always produce a high quality 64bit hash.\n"
"    template <typename K>\n"
"    [[nodiscard]] constexpr auto mixed_hash(K const& key) const -> uint64_t {\n"
"        if constexpr (is_detected_v<detect_avalanching, Hash>) {\n"
"            // we know that the hash is good because is_avalanching.\n"
"            if constexpr (sizeof(decltype(m_hash(key))) < sizeof(uint64_t)) {\n"
"                // 32bit hash and is_avalanching => multiply with a constant to avalanche bits upwards\n"
"                return m_hash(key) * UINT64_C(0x9ddfea08eb382d69);\n"
"            } else {\n"
"                // 64bit and is_avalanching => only use the hash itself.\n"
"                return m_hash(key);\n"
"            }\n"
"        } else {\n"
"            // not is_avalanching => apply wyhash\n"
"            return wyhash::hash(m_hash(key));\n"
"        }\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto dist_and_fingerprint_from_hash(uint64_t hash) const -> dist_and_fingerprint_type {\n"
;
sb << 
"        return Bucket::dist_inc | (static_cast<dist_and_fingerprint_type>(hash) & Bucket::fingerprint_mask);\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto bucket_idx_from_hash(uint64_t hash) const -> value_idx_type {\n"
"        return static_cast<value_idx_type>(hash >> m_shifts);\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto get_key(value_type const& vt) -> key_type const& {\n"
"        if constexpr (is_map_v<T>) {\n"
"            return vt.first;\n"
"        } else {\n"
"            return vt;\n"
"        }\n"
"    }\n"
"\n"
"    template <typename K>\n"
"    [[nodiscard]] auto next_while_less(K const& key) const -> Bucket {\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (dist_and_fingerprint < at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"        return {dist_and_fingerprint, bucket_idx};\n"
"    }\n"
"\n"
"    void place_and_shift_up(Bucket bucket, value_idx_type place) {\n"
"        while (0 != at(m_buckets, place).m_dist_and_fingerprint) {\n"
"            bucket = std::exchange(at(m_buckets, place), bucket);\n"
"            bucket.m_dist_and_fingerprint = dist_inc(bucket.m_dist_and_fingerprint);\n"
"            place = next(place);\n"
"        }\n"
"        at(m_buckets, place) = bucket;\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto calc_num_buckets(uint8_t shifts) -> size_t {\n"
"        return (std::min)(max_bucket_count(), size_t{1} << (64U - shifts));\n"
"    }\n"
"\n"
"    [[nodiscard]] constexpr auto calc_shifts_for_size(size_t s) const -> uint8_t {\n"
"        auto shifts = initial_shifts;\n"
"        while (shifts > 0 && static_cast<size_t>(static_cast<float>(calc_num_buckets(shifts)) * max_load_factor()) < s) {\n"
"            --shifts;\n"
"        }\n"
"        return shifts;\n"
"    }\n"
"\n"
"    // assumes m_values has data, m_buckets=m_buckets_end=nullptr, m_shifts is INITIAL_SHIFTS\n"
"    void copy_buckets(table const& other) {\n"
"        // assumes m_values has already the correct data copied over.\n"
"        if (empty()) {\n"
"            // when empty, at least allocate an initial buckets and clear them.\n"
"            allocate_buckets_from_shift();\n"
"            clear_buckets();\n"
"        } else {\n"
"            m_shifts = other.m_shifts;\n"
"            allocate_buckets_from_shift();\n"
"            if constexpr (IsSegmented || !std::is_same_v<BucketContainer, default_container_t>) {\n"
"                for (auto i = 0UL; i < bucket_count(); ++i) {\n"
"                    at(m_buckets, i) = at(other.m_buckets, i);\n"
"                }\n"
"            } else {\n"
"                std::memcpy(m_buckets.data(), other.m_buckets.data(), sizeof(Bucket) * bucket_count());\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    /**\n"
"     * True when no element can be added any more without increasing the size\n"
"     */\n"
"    [[nodiscard]] auto is_full() const -> bool {\n"
"        return size() > m_max_bucket_capacity;\n"
"    }\n"
"\n"
"    void deallocate_buckets() {\n"
"        m_buckets.clear();\n"
"        m_buckets.shrink_to_fit();\n"
"        m_max_bucket_capacity = 0;\n"
"    }\n"
"\n"
"    void allocate_buckets_from_shift() {\n"
"        auto num_buckets = calc_num_buckets(m_shifts);\n"
"        if constexpr (IsSegmented || !std::is_same_v<BucketContainer, default_container_t>) {\n"
"            if constexpr (has_reserve<bucket_container_type>) {\n"
"                m_buckets.reserve(num_buckets);\n"
"            }\n"
"            for (size_t i = m_buckets.size(); i < num_buckets; ++i) {\n"
"                m_buckets.emplace_back();\n"
"            }\n"
"        } else {\n"
"            m_buckets.resize(num_buckets);\n"
"        }\n"
"        if (num_buckets == max_bucket_count()) {\n"
"            // reached the maximum, make sure we can use each bucket\n"
"            m_max_bucket_capacity = max_bucket_count();\n"
"        } else {\n"
"            m_max_bucket_capacity = static_cast<value_idx_type>(static_cast<float>(num_buckets) * max_load_factor());\n"
"        }\n"
"    }\n"
"\n"
"    void clear_buckets() {\n"
"        if constexpr (IsSegmented || !std::is_same_v<BucketContainer, default_container_t>) {\n"
"            for (auto&& e : m_buckets) {\n"
"                std::memset(&e, 0, sizeof(e));\n"
"            }\n"
"        } else {\n"
"            std::memset(m_buckets.data(), 0, sizeof(Bucket) * bucket_count());\n"
"        }\n"
"    }\n"
"\n"
"    void clear_and_fill_buckets_from_values() {\n"
"        clear_buckets();\n"
"        for (value_idx_type value_idx = 0, end_idx = static_cast<value_idx_type>(m_values.size()); value_idx < end_idx;\n"
"             ++value_idx) {\n"
"            auto const& key = get_key(m_values[value_idx]);\n"
"            auto [dist_and_fingerprint, bucket] = next_while_less(key);\n"
"\n"
"            // we know for certain that key has not yet been inserted, so no need to check it.\n"
"            place_and_shift_up({dist_and_fingerprint, value_idx}, bucket);\n"
"        }\n"
"    }\n"
"\n"
"    void increase_size() {\n"
"        if (m_max_bucket_capacity == max_bucket_count()) {\n"
"            // remove the value again, we can't add it!\n"
"            m_values.pop_back();\n"
"            on_error_bucket_overflow();\n"
"        }\n"
"        --m_shifts;\n"
"        if constexpr (!IsSegmented || std::is_same_v<BucketContainer, default_container_t>) {\n"
"            deallocate_buckets();\n"
"        }\n"
"        allocate_buckets_from_shift();\n"
"        clear_and_fill_buckets_from_values();\n"
"    }\n"
"\n"
"    template <typename Op>\n"
"    void do_erase(value_idx_type bucket_idx, Op handle_erased_value) {\n"
"        auto const value_idx_to_remove = at(m_buckets, bucket_idx).m_value_idx;\n"
"\n"
"        // shift down until either empty or an element with correct spot is found\n"
"        auto next_bucket_idx = next(bucket_idx);\n"
"        while (at(m_buckets, next_bucket_idx).m_dist_and_fingerprint >= Bucket::dist_inc * 2) {\n"
"            at(m_buckets, bucket_idx) = {dist_dec(at(m_buckets, next_bucket_idx).m_dist_and_fingerprint),\n"
"                                         at(m_buckets, next_bucket_idx).m_value_idx};\n"
"            bucket_idx = std::exchange(next_bucket_idx, next(next_bucket_idx));\n"
"        }\n"
"        at(m_buckets, bucket_idx) = {};\n"
"        handle_erased_value(std::move(m_values[value_idx_to_remove]));\n"
"\n"
"        // update m_values\n"
"        if (value_idx_to_remove != m_values.size() - 1) {\n"
"            // no luck, we'll have to replace the value with the last one and update the index accordingly\n"
"            auto& val = m_values[value_idx_to_remove];\n"
"            val = std::move(m_values.back());\n"
"\n"
"            // update the values_idx of the moved entry. No need to play the info game, just look until we find the values_idx\n"
"            auto mh = mixed_hash(get_key(val));\n"
"            bucket_idx = bucket_idx_from_hash(mh);\n"
"\n"
"            auto const values_idx_back = static_cast<value_idx_type>(m_values.size() - 1);\n"
"            while (values_idx_back != at(m_buckets, bucket_idx).m_value_idx) {\n"
"                bucket_idx = next(bucket_idx);\n"
"            }\n"
"            at(m_buckets, bucket_idx).m_value_idx = value_idx_to_remove;\n"
"        }\n"
"        m_values.pop_back();\n"
"    }\n"
"\n"
"    template <typename K, typename Op>\n"
"    auto do_erase_key(K&& key, Op handle_erased_value) -> size_t {\n"
"        if (empty()) {\n"
"            return 0;\n"
"        }\n"
"\n"
"        auto [dist_and_fingerprint, bucket_idx] = next_while_less(key);\n"
"\n"
"        while (dist_and_fingerprint == at(m_buckets, bucket_idx).m_dist_and_fingerprint &&\n"
"               !m_equal(key, get_key(m_values[at(m_buckets, bucket_idx).m_value_idx]))) {\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        if (dist_and_fingerprint != at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            return 0;\n"
"        }\n"
"        do_erase(bucket_idx, handle_erased_value);\n"
"        return 1;\n"
"    }\n"
"\n"
"    template <class K, class M>\n"
"    auto do_insert_or_assign(K&& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        auto it_isinserted = try_emplace(std::forward<K>(key), std::forward<M>(mapped));\n"
"        if (!it_isinserted.second) {\n"
"            it_isinserted.first->second = std::forward<M>(mapped);\n"
"        }\n"
"        return it_isinserted;\n"
"    }\n"
"\n"
"    template <typename... Args>\n"
"    auto do_place_element(dist_and_fingerprint_type dist_and_fingerprint, value_idx_type bucket_idx, Args&&... args)\n"
"        -> std::pair<iterator, bool> {\n"
"\n"
"        // emplace the new value. If that throws an exception, no harm done; index is still in a valid state\n"
"        m_values.emplace_back(std::forward<Args>(args)...);\n"
"\n"
"        auto value_idx = static_cast<value_idx_type>(m_values.size() - 1);\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(is_full())) {\n"
"            increase_size();\n"
"        } else {\n"
"            place_and_shift_up({dist_and_fingerprint, value_idx}, bucket_idx);\n"
"        }\n"
"\n"
"        // place element and shift up until we find an empty spot\n"
"        return {begin() + static_cast<difference_type>(value_idx), true};\n"
"    }\n"
"\n"
"    template <typename K, typename... Args>\n"
"    auto do_try_emplace(K&& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (true) {\n"
"            auto* bucket = &at(m_buckets, bucket_idx);\n"
"            if (dist_and_fingerprint == bucket->m_dist_and_fingerprint) {\n"
"                if (m_equal(key, get_key(m_values[bucket->m_value_idx]))) {\n"
"                    return {begin() + static_cast<difference_type>(bucket->m_value_idx), false};\n"
"                }\n"
"            } else if (dist_and_fingerprint > bucket->m_dist_and_fingerprint) {\n"
"                return do_place_element(dist_and_fingerprint,\n"
"                                        bucket_idx,\n"
"                                        std::piecewise_construct,\n"
"                                        std::forward_as_tuple(std::forward<K>(key)),\n"
"                                        std::forward_as_tuple(std::forward<Args>(args)...));\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"    }\n"
"\n"
"    template <typename K>\n"
"    auto do_find(K const& key) -> iterator {\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(empty())) {\n"
"            return end();\n"
"        }\n"
"\n"
"        auto mh = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(mh);\n"
"        auto bucket_idx = bucket_idx_from_hash(mh);\n"
"        auto* bucket = &at(m_buckets, bucket_idx);\n"
"\n"
"        // unrolled loop. *Always* check a few directly, then enter the loop. This is faster.\n"
"        if (dist_and_fingerprint == bucket->m_dist_and_fingerprint && m_equal(key, get_key(m_values[bucket->m_value_idx]))) {\n"
"            return begin() + static_cast<difference_type>(bucket->m_value_idx);\n"
"        }\n"
"        dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"        bucket_idx = next(bucket_idx);\n"
"        bucket = &at(m_buckets, bucket_idx);\n"
"\n"
"        if (dist_and_fingerprint == bucket->m_dist_and_fingerprint && m_equal(key, get_key(m_values[bucket->m_value_idx]))) {\n"
"            return begin() + static_cast<difference_type>(bucket->m_value_idx);\n"
"        }\n"
"        dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"        bucket_idx = next(bucket_idx);\n"
"        bucket = &at(m_buckets, bucket_idx);\n"
"\n"
"        while (true) {\n"
"            if (dist_and_fingerprint == bucket->m_dist_and_fingerprint) {\n"
"                if (m_equal(key, get_key(m_values[bucket->m_value_idx]))) {\n"
"                    return begin() + static_cast<difference_type>(bucket->m_value_idx);\n"
"                }\n"
"            } else if (dist_and_fingerprint > bucket->m_dist_and_fingerprint) {\n"
"                return end();\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"            bucket = &at(m_buckets, bucket_idx);\n"
"        }\n"
"    }\n"
"\n"
"    template <typename K>\n"
"    auto do_find(K const& key) const -> const_iterator {\n"
"        return const_cast<table*>(this)->do_find(key); // NOLINT(cppcoreguidelines-pro-type-const-cast)\n"
"    }\n"
"\n"
"    template <typename K, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto do_at(K const& key) -> Q& {\n"
"        if (auto it = find(key); ANKERL_UNORDERED_DENSE_LIKELY(end() != it)) {\n"
"            return it->second;\n"
"        }\n"
"        on_error_key_not_found();\n"
"    }\n"
"\n"
"    template <typename K, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto do_at(K const& key) const -> Q const& {\n"
"        return const_cast<table*>(this)->at(key); // NOLINT(cppcoreguidelines-pro-type-const-cast)\n"
"    }\n"
"\n"
"public:\n"
"    explicit table(size_t bucket_count,\n"
"                   Hash const& hash = Hash(),\n"
"                   KeyEqual const& equal = KeyEqual(),\n"
"                   allocator_type const& alloc_or_container = allocator_type())\n"
"        : m_values(alloc_or_container)\n"
"        , m_buckets(alloc_or_container)\n"
"        , m_hash(hash)\n"
"        , m_equal(equal) {\n"
"        if (0 != bucket_count) {\n"
"            reserve(bucket_count);\n"
"        } else {\n"
"            allocate_buckets_from_shift();\n"
"            clear_buckets();\n"
"        }\n"
"    }\n"
"\n"
"    table()\n"
"        : table(0) {}\n"
"\n"
"    table(size_t bucket_count, allocator_type const& alloc)\n"
"        : table(bucket_count, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    table(size_t bucket_count, Hash const& hash, allocator_type const& alloc)\n"
"        : table(bucket_count, hash, KeyEqual(), alloc) {}\n"
"\n"
"    explicit table(allocator_type const& alloc)\n"
"        : table(0, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    template <class InputIt>\n"
"    table(InputIt first,\n"
"          InputIt last,\n"
"          size_type bucket_count = 0,\n"
"          Hash const& hash = Hash(),\n"
"          KeyEqual const& equal = KeyEqual(),\n"
"          allocator_type const& alloc = allocator_type())\n"
"        : table(bucket_count, hash, equal, alloc) {\n"
"        insert(first, last);\n"
"    }\n"
"\n"
"    template <class InputIt>\n"
"    table(InputIt first, InputIt last, size_type bucket_count, allocator_type const& alloc)\n"
"        : table(first, last, bucket_count, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    template <class InputIt>\n"
"    table(InputIt first, InputIt last, size_type bucket_count, Hash const& hash, allocator_type const& alloc)\n"
"        : table(first, last, bucket_count, hash, KeyEqual(), alloc) {}\n"
"\n"
"    table(table const& other)\n"
"        : table(other, other.m_values.get_allocator()) {}\n"
"\n"
"    table(table const& other, allocator_type const& alloc)\n"
"        : m_values(other.m_values, alloc)\n"
"        , m_max_load_factor(other.m_max_load_factor)\n"
"        , m_hash(other.m_hash)\n"
"        , m_equal(other.m_equal) {\n"
"        copy_buckets(other);\n"
"    }\n"
"\n"
"    table(table&& other) noexcept\n"
"        : table(std::move(other), other.m_values.get_allocator()) {}\n"
"\n"
"    table(table&& other, allocator_type const& alloc) noexcept\n"
"        : m_values(alloc) {\n"
"        *this = std::move(other);\n"
"    }\n"
"\n"
"    table(std::initializer_list<value_type> ilist,\n"
"          size_t bucket_count = 0,\n"
"          Hash const& hash = Hash(),\n"
"          KeyEqual const& equal = KeyEqual(),\n"
"          allocator_type const& alloc = allocator_type())\n"
"        : table(bucket_count, hash, equal, alloc) {\n"
"        insert(ilist);\n"
"    }\n"
"\n"
"    table(std::initializer_list<value_type> ilist, size_type bucket_count, allocator_type const& alloc)\n"
"        : table(ilist, bucket_count, Hash(), KeyEqual(), alloc) {}\n"
"\n"
"    table(std::initializer_list<value_type> init, size_type bucket_count, Hash const& hash, allocator_type const& alloc)\n"
"        : table(init, bucket_count, hash, KeyEqual(), alloc) {}\n"
"\n"
"    ~table() {}\n"
"\n"
"    auto operator=(table const& other) -> table& {\n"
"        if (&other != this) {\n"
"            deallocate_buckets(); // deallocate before m_values is set (might have another allocator)\n"
"            m_values = other.m_values;\n"
"            m_max_load_factor = other.m_max_load_factor;\n"
"            m_hash = other.m_hash;\n"
"            m_equal = other.m_equal;\n"
"            m_shifts = initial_shifts;\n"
"            copy_buckets(other);\n"
"        }\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto operator=(table&& other) noexcept(noexcept(std::is_nothrow_move_assignable_v<value_container_type> &&\n"
"                                                    std::is_nothrow_move_assignable_v<Hash> &&\n"
"                                                    std::is_nothrow_move_assignable_v<KeyEqual>)) -> table& {\n"
"        if (&other != this) {\n"
"            deallocate_buckets(); // deallocate before m_values is set (might have another allocator)\n"
"            m_values = std::move(other.m_values);\n"
"            other.m_values.clear();\n"
"\n"
"            // we can only reuse m_buckets when both maps have the same allocator!\n"
"            if (get_allocator() == other.get_allocator()) {\n"
"                m_buckets = std::move(other.m_buckets);\n"
"                other.m_buckets.clear();\n"
"                m_max_bucket_capacity = std::exchange(other.m_max_bucket_capacity, 0);\n"
;
sb << 
"                m_shifts = std::exchange(other.m_shifts, initial_shifts);\n"
"                m_max_load_factor = std::exchange(other.m_max_load_factor, default_max_load_factor);\n"
"                m_hash = std::exchange(other.m_hash, {});\n"
"                m_equal = std::exchange(other.m_equal, {});\n"
"                other.allocate_buckets_from_shift();\n"
"                other.clear_buckets();\n"
"            } else {\n"
"                // set max_load_factor *before* copying the other's buckets, so we have the same\n"
"                // behavior\n"
"                m_max_load_factor = other.m_max_load_factor;\n"
"\n"
"                // copy_buckets sets m_buckets, m_num_buckets, m_max_bucket_capacity, m_shifts\n"
"                copy_buckets(other);\n"
"                // clear's the other's buckets so other is now already usable.\n"
"                other.clear_buckets();\n"
"                m_hash = other.m_hash;\n"
"                m_equal = other.m_equal;\n"
"            }\n"
"            // map \"other\" is now already usable, it's empty.\n"
"        }\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto operator=(std::initializer_list<value_type> ilist) -> table& {\n"
"        clear();\n"
"        insert(ilist);\n"
"        return *this;\n"
"    }\n"
"\n"
"    auto get_allocator() const noexcept -> allocator_type {\n"
"        return m_values.get_allocator();\n"
"    }\n"
"\n"
"    // iterators //////////////////////////////////////////////////////////////\n"
"\n"
"    auto begin() noexcept -> iterator {\n"
"        return m_values.begin();\n"
"    }\n"
"\n"
"    auto begin() const noexcept -> const_iterator {\n"
"        return m_values.begin();\n"
"    }\n"
"\n"
"    auto cbegin() const noexcept -> const_iterator {\n"
"        return m_values.cbegin();\n"
"    }\n"
"\n"
"    auto end() noexcept -> iterator {\n"
"        return m_values.end();\n"
"    }\n"
"\n"
"    auto cend() const noexcept -> const_iterator {\n"
"        return m_values.cend();\n"
"    }\n"
"\n"
"    auto end() const noexcept -> const_iterator {\n"
"        return m_values.end();\n"
"    }\n"
"\n"
"    // capacity ///////////////////////////////////////////////////////////////\n"
"\n"
"    [[nodiscard]] auto empty() const noexcept -> bool {\n"
"        return m_values.empty();\n"
"    }\n"
"\n"
"    [[nodiscard]] auto size() const noexcept -> size_t {\n"
"        return m_values.size();\n"
"    }\n"
"\n"
"    [[nodiscard]] static constexpr auto max_size() noexcept -> size_t {\n"
"        if constexpr ((std::numeric_limits<value_idx_type>::max)() == (std::numeric_limits<size_t>::max)()) {\n"
"            return size_t{1} << (sizeof(value_idx_type) * 8 - 1);\n"
"        } else {\n"
"            return size_t{1} << (sizeof(value_idx_type) * 8);\n"
"        }\n"
"    }\n"
"\n"
"    // modifiers //////////////////////////////////////////////////////////////\n"
"\n"
"    void clear() {\n"
"        m_values.clear();\n"
"        clear_buckets();\n"
"    }\n"
"\n"
"    auto insert(value_type const& value) -> std::pair<iterator, bool> {\n"
"        return emplace(value);\n"
"    }\n"
"\n"
"    auto insert(value_type&& value) -> std::pair<iterator, bool> {\n"
"        return emplace(std::move(value));\n"
"    }\n"
"\n"
"    template <class P, std::enable_if_t<std::is_constructible_v<value_type, P&&>, bool> = true>\n"
"    auto insert(P&& value) -> std::pair<iterator, bool> {\n"
"        return emplace(std::forward<P>(value));\n"
"    }\n"
"\n"
"    auto insert(const_iterator /*hint*/, value_type const& value) -> iterator {\n"
"        return insert(value).first;\n"
"    }\n"
"\n"
"    auto insert(const_iterator /*hint*/, value_type&& value) -> iterator {\n"
"        return insert(std::move(value)).first;\n"
"    }\n"
"\n"
"    template <class P, std::enable_if_t<std::is_constructible_v<value_type, P&&>, bool> = true>\n"
"    auto insert(const_iterator /*hint*/, P&& value) -> iterator {\n"
"        return insert(std::forward<P>(value)).first;\n"
"    }\n"
"\n"
"    template <class InputIt>\n"
"    void insert(InputIt first, InputIt last) {\n"
"        while (first != last) {\n"
"            insert(*first);\n"
"            ++first;\n"
"        }\n"
"    }\n"
"\n"
"    void insert(std::initializer_list<value_type> ilist) {\n"
"        insert(ilist.begin(), ilist.end());\n"
"    }\n"
"\n"
"    // nonstandard API: *this is emptied.\n"
"    // Also see \"A Standard flat_map\" https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0429r9.pdf\n"
"    auto extract() && -> value_container_type {\n"
"        return std::move(m_values);\n"
"    }\n"
"\n"
"    // nonstandard API:\n"
"    // Discards the internally held container and replaces it with the one passed. Erases non-unique elements.\n"
"    auto replace(value_container_type&& container) {\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(container.size() > max_size())) {\n"
"            on_error_too_many_elements();\n"
"        }\n"
"        auto shifts = calc_shifts_for_size(container.size());\n"
"        if (0 == bucket_count() || shifts < m_shifts || container.get_allocator() != m_values.get_allocator()) {\n"
"            m_shifts = shifts;\n"
"            deallocate_buckets();\n"
"            allocate_buckets_from_shift();\n"
"        }\n"
"        clear_buckets();\n"
"\n"
"        m_values = std::move(container);\n"
"\n"
"        // can't use clear_and_fill_buckets_from_values() because container elements might not be unique\n"
"        auto value_idx = value_idx_type{};\n"
"\n"
"        // loop until we reach the end of the container. duplicated entries will be replaced with back().\n"
"        while (value_idx != static_cast<value_idx_type>(m_values.size())) {\n"
"            auto const& key = get_key(m_values[value_idx]);\n"
"\n"
"            auto hash = mixed_hash(key);\n"
"            auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"            auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"            bool key_found = false;\n"
"            while (true) {\n"
"                auto const& bucket = at(m_buckets, bucket_idx);\n"
"                if (dist_and_fingerprint > bucket.m_dist_and_fingerprint) {\n"
"                    break;\n"
"                }\n"
"                if (dist_and_fingerprint == bucket.m_dist_and_fingerprint &&\n"
"                    m_equal(key, get_key(m_values[bucket.m_value_idx]))) {\n"
"                    key_found = true;\n"
"                    break;\n"
"                }\n"
"                dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"                bucket_idx = next(bucket_idx);\n"
"            }\n"
"\n"
"            if (key_found) {\n"
"                if (value_idx != static_cast<value_idx_type>(m_values.size() - 1)) {\n"
"                    m_values[value_idx] = std::move(m_values.back());\n"
"                }\n"
"                m_values.pop_back();\n"
"            } else {\n"
"                place_and_shift_up({dist_and_fingerprint, value_idx}, bucket_idx);\n"
"                ++value_idx;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(Key const& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        return do_insert_or_assign(key, std::forward<M>(mapped));\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(Key&& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        return do_insert_or_assign(std::move(key), std::forward<M>(mapped));\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename M,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto insert_or_assign(K&& key, M&& mapped) -> std::pair<iterator, bool> {\n"
"        return do_insert_or_assign(std::forward<K>(key), std::forward<M>(mapped));\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(const_iterator /*hint*/, Key const& key, M&& mapped) -> iterator {\n"
"        return do_insert_or_assign(key, std::forward<M>(mapped)).first;\n"
"    }\n"
"\n"
"    template <class M, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto insert_or_assign(const_iterator /*hint*/, Key&& key, M&& mapped) -> iterator {\n"
"        return do_insert_or_assign(std::move(key), std::forward<M>(mapped)).first;\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename M,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto insert_or_assign(const_iterator /*hint*/, K&& key, M&& mapped) -> iterator {\n"
"        return do_insert_or_assign(std::forward<K>(key), std::forward<M>(mapped)).first;\n"
"    }\n"
"\n"
"    // Single arguments for unordered_set can be used without having to construct the value_type\n"
"    template <class K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<!is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto emplace(K&& key) -> std::pair<iterator, bool> {\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (dist_and_fingerprint <= at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            if (dist_and_fingerprint == at(m_buckets, bucket_idx).m_dist_and_fingerprint &&\n"
"                m_equal(key, m_values[at(m_buckets, bucket_idx).m_value_idx])) {\n"
"                // found it, return without ever actually creating anything\n"
"                return {begin() + static_cast<difference_type>(at(m_buckets, bucket_idx).m_value_idx), false};\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        // value is new, insert element first, so when exception happens we are in a valid state\n"
"        return do_place_element(dist_and_fingerprint, bucket_idx, std::forward<K>(key));\n"
"    }\n"
"\n"
"    template <class... Args>\n"
"    auto emplace(Args&&... args) -> std::pair<iterator, bool> {\n"
"        // we have to instantiate the value_type to be able to access the key.\n"
"        // 1. emplace_back the object so it is constructed. 2. If the key is already there, pop it later in the loop.\n"
"        auto& key = get_key(m_values.emplace_back(std::forward<Args>(args)...));\n"
"        auto hash = mixed_hash(key);\n"
"        auto dist_and_fingerprint = dist_and_fingerprint_from_hash(hash);\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        while (dist_and_fingerprint <= at(m_buckets, bucket_idx).m_dist_and_fingerprint) {\n"
"            if (dist_and_fingerprint == at(m_buckets, bucket_idx).m_dist_and_fingerprint &&\n"
"                m_equal(key, get_key(m_values[at(m_buckets, bucket_idx).m_value_idx]))) {\n"
"                m_values.pop_back(); // value was already there, so get rid of it\n"
"                return {begin() + static_cast<difference_type>(at(m_buckets, bucket_idx).m_value_idx), false};\n"
"            }\n"
"            dist_and_fingerprint = dist_inc(dist_and_fingerprint);\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        // value is new, place the bucket and shift up until we find an empty spot\n"
"        auto value_idx = static_cast<value_idx_type>(m_values.size() - 1);\n"
"        if (ANKERL_UNORDERED_DENSE_UNLIKELY(is_full())) {\n"
"            // increase_size just rehashes all the data we have in m_values\n"
"            increase_size();\n"
"        } else {\n"
"            // place element and shift up until we find an empty spot\n"
"            place_and_shift_up({dist_and_fingerprint, value_idx}, bucket_idx);\n"
"        }\n"
"        return {begin() + static_cast<difference_type>(value_idx), true};\n"
"    }\n"
"\n"
"    template <class... Args>\n"
"    auto emplace_hint(const_iterator /*hint*/, Args&&... args) -> iterator {\n"
"        return emplace(std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(Key const& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        return do_try_emplace(key, std::forward<Args>(args)...);\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(Key&& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        return do_try_emplace(std::move(key), std::forward<Args>(args)...);\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(const_iterator /*hint*/, Key const& key, Args&&... args) -> iterator {\n"
"        return do_try_emplace(key, std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    template <class... Args, typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto try_emplace(const_iterator /*hint*/, Key&& key, Args&&... args) -> iterator {\n"
"        return do_try_emplace(std::move(key), std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    template <\n"
"        typename K,\n"
"        typename... Args,\n"
"        typename Q = T,\n"
"        typename H = Hash,\n"
"        typename KE = KeyEqual,\n"
"        std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE> && is_neither_convertible_v<K&&, iterator, const_iterator>,\n"
"                         bool> = true>\n"
"    auto try_emplace(K&& key, Args&&... args) -> std::pair<iterator, bool> {\n"
"        return do_try_emplace(std::forward<K>(key), std::forward<Args>(args)...);\n"
"    }\n"
"\n"
"    template <\n"
"        typename K,\n"
"        typename... Args,\n"
"        typename Q = T,\n"
"        typename H = Hash,\n"
"        typename KE = KeyEqual,\n"
"        std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE> && is_neither_convertible_v<K&&, iterator, const_iterator>,\n"
"                         bool> = true>\n"
"    auto try_emplace(const_iterator /*hint*/, K&& key, Args&&... args) -> iterator {\n"
"        return do_try_emplace(std::forward<K>(key), std::forward<Args>(args)...).first;\n"
"    }\n"
"\n"
"    auto erase(iterator it) -> iterator {\n"
"        auto hash = mixed_hash(get_key(*it));\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        auto const value_idx_to_remove = static_cast<value_idx_type>(it - cbegin());\n"
"        while (at(m_buckets, bucket_idx).m_value_idx != value_idx_to_remove) {\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        do_erase(bucket_idx, [](value_type&& /*unused*/) {\n"
"        });\n"
"        return begin() + static_cast<difference_type>(value_idx_to_remove);\n"
"    }\n"
"\n"
"    auto extract(iterator it) -> value_type {\n"
"        auto hash = mixed_hash(get_key(*it));\n"
"        auto bucket_idx = bucket_idx_from_hash(hash);\n"
"\n"
"        auto const value_idx_to_remove = static_cast<value_idx_type>(it - cbegin());\n"
"        while (at(m_buckets, bucket_idx).m_value_idx != value_idx_to_remove) {\n"
"            bucket_idx = next(bucket_idx);\n"
"        }\n"
"\n"
"        auto tmp = std::optional<value_type>{};\n"
"        do_erase(bucket_idx, [&tmp](value_type&& val) {\n"
"            tmp = std::move(val);\n"
"        });\n"
"        return std::move(tmp).value();\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto erase(const_iterator it) -> iterator {\n"
"        return erase(begin() + (it - cbegin()));\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto extract(const_iterator it) -> value_type {\n"
"        return extract(begin() + (it - cbegin()));\n"
"    }\n"
"\n"
"    auto erase(const_iterator first, const_iterator last) -> iterator {\n"
"        auto const idx_first = first - cbegin();\n"
"        auto const idx_last = last - cbegin();\n"
"        auto const first_to_last = std::distance(first, last);\n"
"        auto const last_to_end = std::distance(last, cend());\n"
"\n"
"        // remove elements from left to right which moves elements from the end back\n"
"        auto const mid = idx_first + (std::min)(first_to_last, last_to_end);\n"
"        auto idx = idx_first;\n"
"        while (idx != mid) {\n"
"            erase(begin() + idx);\n"
"            ++idx;\n"
"        }\n"
"\n"
"        // all elements from the right are moved, now remove the last element until all done\n"
"        idx = idx_last;\n"
"        while (idx != mid) {\n"
"            --idx;\n"
"            erase(begin() + idx);\n"
"        }\n"
"\n"
"        return begin() + idx_first;\n"
"    }\n"
"\n"
"    auto erase(Key const& key) -> size_t {\n"
"        return do_erase_key(key, [](value_type&& /*unused*/) {\n"
"        });\n"
"    }\n"
"\n"
"    auto extract(Key const& key) -> std::optional<value_type> {\n"
"        auto tmp = std::optional<value_type>{};\n"
"        do_erase_key(key, [&tmp](value_type&& val) {\n"
"            tmp = std::move(val);\n"
"        });\n"
"        return tmp;\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto erase(K&& key) -> size_t {\n"
"        return do_erase_key(std::forward<K>(key), [](value_type&& /*unused*/) {\n"
"        });\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto extract(K&& key) -> std::optional<value_type> {\n"
"        auto tmp = std::optional<value_type>{};\n"
"        do_erase_key(std::forward<K>(key), [&tmp](value_type&& val) {\n"
"            tmp = std::move(val);\n"
"        });\n"
"        return tmp;\n"
"    }\n"
"\n"
"    void swap(table& other) noexcept(noexcept(std::is_nothrow_swappable_v<value_container_type> &&\n"
;
sb << 
"                                              std::is_nothrow_swappable_v<Hash> && std::is_nothrow_swappable_v<KeyEqual>)) {\n"
"        using std::swap;\n"
"        swap(other, *this);\n"
"    }\n"
"\n"
"    // lookup /////////////////////////////////////////////////////////////////\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto at(key_type const& key) -> Q& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto at(K const& key) -> Q& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto at(key_type const& key) const -> Q const& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto at(K const& key) const -> Q const& {\n"
"        return do_at(key);\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto operator[](Key const& key) -> Q& {\n"
"        return try_emplace(key).first->second;\n"
"    }\n"
"\n"
"    template <typename Q = T, std::enable_if_t<is_map_v<Q>, bool> = true>\n"
"    auto operator[](Key&& key) -> Q& {\n"
"        return try_emplace(std::move(key)).first->second;\n"
"    }\n"
"\n"
"    template <typename K,\n"
"              typename Q = T,\n"
"              typename H = Hash,\n"
"              typename KE = KeyEqual,\n"
"              std::enable_if_t<is_map_v<Q> && is_transparent_v<H, KE>, bool> = true>\n"
"    auto operator[](K&& key) -> Q& {\n"
"        return try_emplace(std::forward<K>(key)).first->second;\n"
"    }\n"
"\n"
"    auto count(Key const& key) const -> size_t {\n"
"        return find(key) == end() ? 0 : 1;\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto count(K const& key) const -> size_t {\n"
"        return find(key) == end() ? 0 : 1;\n"
"    }\n"
"\n"
"    auto find(Key const& key) -> iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    auto find(Key const& key) const -> const_iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto find(K const& key) -> iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto find(K const& key) const -> const_iterator {\n"
"        return do_find(key);\n"
"    }\n"
"\n"
"    auto contains(Key const& key) const -> bool {\n"
"        return find(key) != end();\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto contains(K const& key) const -> bool {\n"
"        return find(key) != end();\n"
"    }\n"
"\n"
"    auto equal_range(Key const& key) -> std::pair<iterator, iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    auto equal_range(const Key& key) const -> std::pair<const_iterator, const_iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto equal_range(K const& key) -> std::pair<iterator, iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    template <class K, class H = Hash, class KE = KeyEqual, std::enable_if_t<is_transparent_v<H, KE>, bool> = true>\n"
"    auto equal_range(K const& key) const -> std::pair<const_iterator, const_iterator> {\n"
"        auto it = do_find(key);\n"
"        return {it, it == end() ? end() : it + 1};\n"
"    }\n"
"\n"
"    // bucket interface ///////////////////////////////////////////////////////\n"
"\n"
"    auto bucket_count() const noexcept -> size_t { // NOLINT(modernize-use-nodiscard)\n"
"        return m_buckets.size();\n"
"    }\n"
"\n"
"    static constexpr auto max_bucket_count() noexcept -> size_t { // NOLINT(modernize-use-nodiscard)\n"
"        return max_size();\n"
"    }\n"
"\n"
"    // hash policy ////////////////////////////////////////////////////////////\n"
"\n"
"    [[nodiscard]] auto load_factor() const -> float {\n"
"        return bucket_count() ? static_cast<float>(size()) / static_cast<float>(bucket_count()) : 0.0F;\n"
"    }\n"
"\n"
"    [[nodiscard]] auto max_load_factor() const -> float {\n"
"        return m_max_load_factor;\n"
"    }\n"
"\n"
"    void max_load_factor(float ml) {\n"
"        m_max_load_factor = ml;\n"
"        if (bucket_count() != max_bucket_count()) {\n"
"            m_max_bucket_capacity = static_cast<value_idx_type>(static_cast<float>(bucket_count()) * max_load_factor());\n"
"        }\n"
"    }\n"
"\n"
"    void rehash(size_t count) {\n"
"        count = (std::min)(count, max_size());\n"
"        auto shifts = calc_shifts_for_size((std::max)(count, size()));\n"
"        if (shifts != m_shifts) {\n"
"            m_shifts = shifts;\n"
"            deallocate_buckets();\n"
"            m_values.shrink_to_fit();\n"
"            allocate_buckets_from_shift();\n"
"            clear_and_fill_buckets_from_values();\n"
"        }\n"
"    }\n"
"\n"
"    void reserve(size_t capa) {\n"
"        capa = (std::min)(capa, max_size());\n"
"        if constexpr (has_reserve<value_container_type>) {\n"
"            // std::deque doesn't have reserve(). Make sure we only call when available\n"
"            m_values.reserve(capa);\n"
"        }\n"
"        auto shifts = calc_shifts_for_size((std::max)(capa, size()));\n"
"        if (0 == bucket_count() || shifts < m_shifts) {\n"
"            m_shifts = shifts;\n"
"            deallocate_buckets();\n"
"            allocate_buckets_from_shift();\n"
"            clear_and_fill_buckets_from_values();\n"
"        }\n"
"    }\n"
"\n"
"    // observers //////////////////////////////////////////////////////////////\n"
"\n"
"    auto hash_function() const -> hasher {\n"
"        return m_hash;\n"
"    }\n"
"\n"
"    auto key_eq() const -> key_equal {\n"
"        return m_equal;\n"
"    }\n"
"\n"
"    // nonstandard API: expose the underlying values container\n"
"    [[nodiscard]] auto values() const noexcept -> value_container_type const& {\n"
"        return m_values;\n"
"    }\n"
"\n"
"    // non-member functions ///////////////////////////////////////////////////\n"
"\n"
"    friend auto operator==(table const& a, table const& b) -> bool {\n"
"        if (&a == &b) {\n"
"            return true;\n"
"        }\n"
"        if (a.size() != b.size()) {\n"
"            return false;\n"
"        }\n"
"        for (auto const& b_entry : b) {\n"
"            auto it = a.find(get_key(b_entry));\n"
"            if constexpr (is_map_v<T>) {\n"
"                // map: check that key is here, then also check that value is the same\n"
"                if (a.end() == it || !(b_entry.second == it->second)) {\n"
"                    return false;\n"
"                }\n"
"            } else {\n"
"                // set: only check that the key is here\n"
"                if (a.end() == it) {\n"
"                    return false;\n"
"                }\n"
"            }\n"
"        }\n"
"        return true;\n"
"    }\n"
"\n"
"    friend auto operator!=(table const& a, table const& b) -> bool {\n"
"        return !(a == b);\n"
"    }\n"
"};\n"
"\n"
"} // namespace detail\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class T,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class AllocatorOrContainer = std::allocator<std::pair<Key, T>>,\n"
"                                        class Bucket = bucket_type::standard,\n"
"                                        class BucketContainer = detail::default_container_t>\n"
"using map = detail::table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, BucketContainer, false>;\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class T,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class AllocatorOrContainer = std::allocator<std::pair<Key, T>>,\n"
"                                        class Bucket = bucket_type::standard,\n"
"                                        class BucketContainer = detail::default_container_t>\n"
"using segmented_map = detail::table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, BucketContainer, true>;\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class AllocatorOrContainer = std::allocator<Key>,\n"
"                                        class Bucket = bucket_type::standard,\n"
"                                        class BucketContainer = detail::default_container_t>\n"
"using set = detail::table<Key, void, Hash, KeyEqual, AllocatorOrContainer, Bucket, BucketContainer, false>;\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class AllocatorOrContainer = std::allocator<Key>,\n"
"                                        class Bucket = bucket_type::standard,\n"
"                                        class BucketContainer = detail::default_container_t>\n"
"using segmented_set = detail::table<Key, void, Hash, KeyEqual, AllocatorOrContainer, Bucket, BucketContainer, true>;\n"
"\n"
"#    if defined(ANKERL_UNORDERED_DENSE_PMR)\n"
"\n"
"namespace pmr {\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class T,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class Bucket = bucket_type::standard>\n"
"using map = detail::table<Key,\n"
"                          T,\n"
"                          Hash,\n"
"                          KeyEqual,\n"
"                          ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<std::pair<Key, T>>,\n"
"                          Bucket,\n"
"                          detail::default_container_t,\n"
"                          false>;\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class T,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class Bucket = bucket_type::standard>\n"
"using segmented_map = detail::table<Key,\n"
"                                    T,\n"
"                                    Hash,\n"
"                                    KeyEqual,\n"
"                                    ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<std::pair<Key, T>>,\n"
"                                    Bucket,\n"
"                                    detail::default_container_t,\n"
"                                    true>;\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class Bucket = bucket_type::standard>\n"
"using set = detail::table<Key,\n"
"                          void,\n"
"                          Hash,\n"
"                          KeyEqual,\n"
"                          ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<Key>,\n"
"                          Bucket,\n"
"                          detail::default_container_t,\n"
"                          false>;\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class Hash = hash<Key>,\n"
"                                        class KeyEqual = std::equal_to<Key>,\n"
"                                        class Bucket = bucket_type::standard>\n"
"using segmented_set = detail::table<Key,\n"
"                                    void,\n"
"                                    Hash,\n"
"                                    KeyEqual,\n"
"                                    ANKERL_UNORDERED_DENSE_PMR::polymorphic_allocator<Key>,\n"
"                                    Bucket,\n"
"                                    detail::default_container_t,\n"
"                                    true>;\n"
"\n"
"} // namespace pmr\n"
"\n"
"#    endif\n"
"\n"
"// deduction guides ///////////////////////////////////////////////////////////\n"
"\n"
"// deduction guides for alias templates are only possible since C++20\n"
"// see https://en.cppreference.com/w/cpp/language/class_template_argument_deduction\n"
"\n"
"} // namespace ANKERL_UNORDERED_DENSE_NAMESPACE\n"
"} // namespace ankerl::unordered_dense\n"
"\n"
"// std extensions /////////////////////////////////////////////////////////////\n"
"\n"
"namespace std { // NOLINT(cert-dcl58-cpp)\n"
"\n"
"ANKERL_UNORDERED_DENSE_EXPORT template <class Key,\n"
"                                        class T,\n"
"                                        class Hash,\n"
"                                        class KeyEqual,\n"
"                                        class AllocatorOrContainer,\n"
"                                        class Bucket,\n"
"                                        class Pred,\n"
"                                        class BucketContainer,\n"
"                                        bool IsSegmented>\n"
"// NOLINTNEXTLINE(cert-dcl58-cpp)\n"
"auto erase_if(\n"
"    ankerl::unordered_dense::detail::table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, BucketContainer, IsSegmented>&\n"
"        map,\n"
"    Pred pred) -> size_t {\n"
"    using map_t = ankerl::unordered_dense::detail::\n"
"        table<Key, T, Hash, KeyEqual, AllocatorOrContainer, Bucket, BucketContainer, IsSegmented>;\n"
"\n"
"    // going back to front because erase() invalidates the end iterator\n"
"    auto const old_size = map.size();\n"
"    auto idx = old_size;\n"
"    while (idx) {\n"
"        --idx;\n"
"        auto it = map.begin() + static_cast<typename map_t::difference_type>(idx);\n"
"        if (pred(*it)) {\n"
"            map.erase(it);\n"
"        }\n"
"    }\n"
"\n"
"    return old_size - map.size();\n"
"}\n"
"\n"
"} // namespace std\n"
"\n"
"#endif\n"
"#endif\n"
"\n"
"#include <cstring>\n"
"#include <type_traits>\n"
"\n"
"namespace Slang\n"
"{\n"
"//\n"
"// Types\n"
"//\n"
"\n"
"// A fixed 64bit wide hash on all targets.\n"
"typedef uint64_t HashCode64;\n"
"typedef HashCode64 HashCode;\n"
"// A fixed 32bit wide hash on all targets.\n"
"typedef uint32_t HashCode32;\n"
"\n"
"//\n"
"// Some helpers to determine which hash to use for a type\n"
"//\n"
"\n"
"// Forward declare Hash\n"
"template<typename T>\n"
"struct Hash;\n"
"\n"
"template<typename T, typename = void>\n"
"constexpr static bool HasSlangHash = false;\n"
"template<typename T>\n"
"constexpr static bool HasSlangHash<\n"
"    T,\n"
"    std::enable_if_t<\n"
"        std::is_convertible_v<decltype((std::declval<const T&>()).getHashCode()), HashCode64>>> =\n"
"    true;\n"
"\n"
"// Does the hashmap implementation provide a uniform hash for this type.\n"
"template<typename T, typename = void>\n"
"constexpr static bool HasWyhash = false;\n"
"template<typename T>\n"
"constexpr static bool HasWyhash<T, typename ankerl::unordered_dense::hash<T>::is_avalanching> =\n"
"    true;\n"
"\n"
"// We want to have an associated type 'is_avalanching = void' iff we have a\n"
"// hash with good uniformity, the two specializations here add that member\n"
"// when appropriate (since we can't declare an associated type with\n"
"// constexpr if or something terse like that)\n"
"template<typename T, typename = void>\n"
"struct DetectAvalanchingHash\n"
"{\n"
"};\n"
"template<typename T>\n"
"struct DetectAvalanchingHash<T, std::enable_if_t<HasWyhash<T>>>\n"
"{\n"
"    using is_avalanching = void;\n"
"};\n"
"// Have we marked 'getHashCode' as having good uniformity properties.\n"
"template<typename T>\n"
"struct DetectAvalanchingHash<T, std::enable_if_t<T::kHasUniformHash>>\n"
"{\n"
"    using is_avalanching = void;\n"
"};\n"
"\n"
"// A helper for hashing according to the bit representation\n"
"template<typename T, typename U>\n"
"struct BitCastHash : DetectAvalanchingHash<U>\n"
"{\n"
"    auto operator()(const T& t) const\n"
"    {\n"
"        // Doesn't discard or invent bits\n"
"        static_assert(sizeof(T) == sizeof(U));\n"
"        // Can we copy bytes to and fro\n"
"        static_assert(std::is_trivially_copyable_v<T>);\n"
"        static_assert(std::is_trivially_copyable_v<U>);\n"
"        // Because we construct a U to memcpy into\n"
"        static_assert(std::is_trivially_constructible_v<U>);\n"
"\n"
"        U u;\n"
"        memcpy(&u, &t, sizeof(T));\n"
"        return Hash<U>{}(u);\n"
"    }\n"
"};\n"
"\n"
"//\n"
"// Our hashing functor which disptaches to the most appropriate hashing\n"
"// function for the type\n"
"//\n"
"\n"
"template<typename T>\n"
"struct Hash : DetectAvalanchingHash<T>\n"
"{\n"
"    auto operator()(const T& t) const\n"
"    {\n"
"        // Our preference is for any hash we've defined ourselves\n"
"        if constexpr (HasSlangHash<T>)\n"
"            return t.getHashCode();\n"
"        // Otherwise fall back to any good hash provided by the hashmap\n"
"        // library\n"
"        else if constexpr (HasWyhash<T>)\n"
;
sb << 
"            return ankerl::unordered_dense::hash<T>{}(t);\n"
"        // Otherwise fail\n"
"        else\n"
"        {\n"
"            // !sizeof(T*) is a 'false' which is dependent on T (pending P2593R0)\n"
"            static_assert(!sizeof(T*), \"No hash implementation found for this type\");\n"
"            // This is to avoid the return type being deduced as 'void' and creating further errors.\n"
"            return HashCode64(0);\n"
"        }\n"
"    }\n"
"};\n"
"\n"
"// Specializations for float and double which hash 0 and -0 to distinct values\n"
"template<>\n"
"struct Hash<float> : BitCastHash<float, uint32_t>\n"
"{\n"
"};\n"
"template<>\n"
"struct Hash<double> : BitCastHash<double, uint64_t>\n"
"{\n"
"};\n"
"\n"
"//\n"
"// Utility functions for using hashes\n"
"//\n"
"\n"
"// A wrapper for Hash<TKey>\n"
"template<typename TKey>\n"
"auto getHashCode(const TKey& key)\n"
"{\n"
"    return Hash<TKey>{}(key);\n"
"}\n"
"\n"
"inline HashCode64 getHashCode(const char* buffer, std::size_t len)\n"
"{\n"
"    return ankerl::unordered_dense::detail::wyhash::hash(buffer, len);\n"
"}\n"
"\n"
"template<typename T>\n"
"HashCode64 hashObjectBytes(const T& t)\n"
"{\n"
"    static_assert(\n"
"        std::has_unique_object_representations_v<T>,\n"
"        \"This type must have a unique object representation to use hashObjectBytes\");\n"
"    return getHashCode(reinterpret_cast<const char*>(&t), sizeof(t));\n"
"}\n"
"\n"
"// Use in a struct to declare a uniform hash which doens't care about the\n"
"// structure of the members.\n"
"#define SLANG_BYTEWISE_HASHABLE                   \\\n"
"    static constexpr bool kHasUniformHash = true; \\\n"
"    ::Slang::HashCode64 getHashCode() const       \\\n"
"    {                                             \\\n"
"        return ::Slang::hashObjectBytes(*this);   \\\n"
"    }\n"
"\n"
"#define SLANG_COMPONENTWISE_HASHABLE_1 \\\n"
"    auto getHashCode() const           \\\n"
"    {                                  \\\n"
"        const auto& [m1] = *this;      \\\n"
"        return Slang::getHashCode(m1); \\\n"
"    }\n"
"\n"
"#define SLANG_COMPONENTWISE_HASHABLE_2                                          \\\n"
"    auto getHashCode() const                                                    \\\n"
"    {                                                                           \\\n"
"        const auto& [m1, m2] = *this;                                           \\\n"
"        return combineHash(::Slang::getHashCode(m1), ::Slang::getHashCode(m2)); \\\n"
"    }\n"
"\n"
"inline HashCode64 combineHash(HashCode64 h)\n"
"{\n"
"    return h;\n"
"}\n"
"\n"
"inline HashCode32 combineHash(HashCode32 h)\n"
"{\n"
"    return h;\n"
"}\n"
"\n"
"// A left fold of a mixing operation\n"
"template<typename H1, typename H2, typename... Hs>\n"
"auto combineHash(H1 n, H2 m, Hs... args)\n"
"{\n"
"    // TODO: restrict the types here more, currently we tend to throw\n"
"    // unhashed integers in here along with proper hashes of objects.\n"
"    static_assert(std::is_convertible_v<H1, HashCode64> || std::is_convertible_v<H1, HashCode32>);\n"
"    static_assert(std::is_convertible_v<H2, HashCode64> || std::is_convertible_v<H2, HashCode32>);\n"
"    return combineHash((n * 16777619) ^ m, args...);\n"
"}\n"
"\n"
"struct Hasher\n"
"{\n"
"public:\n"
"    Hasher() {}\n"
"\n"
"    /// Hash the given `value` and combine it into this hash state\n"
"    template<typename T>\n"
"    void hashValue(T const& value)\n"
"    {\n"
"        // TODO: Eventually, we should replace `getHashCode`\n"
"        // with a \"hash into\" operation that takes the value\n"
"        // and a `Hasher`.\n"
"\n"
"        m_hashCode = combineHash(m_hashCode, getHashCode(value));\n"
"    }\n"
"\n"
"    /// Combine the given `hash` code into the hash state.\n"
"    ///\n"
"    /// Note: users should prefer to use `hashValue` or `hashObject`\n"
"    /// when possible, as they may be able to ensure a higher-quality\n"
"    /// hash result (e.g., by using more bits to represent the state\n"
"    /// during hashing than are used for the final hash code).\n"
"    ///\n"
"    void addHash(HashCode hash) { m_hashCode = combineHash(m_hashCode, hash); }\n"
"\n"
"    HashCode getResult() const { return m_hashCode; }\n"
"\n"
"private:\n"
"    HashCode m_hashCode = 0;\n"
"};\n"
"} // namespace Slang\n"
"\n"
"#endif\n"
"\n"
"#ifndef _WIN32\n"
"#ifndef SLANG_CORE_SECURE_CRT_H\n"
"#define SLANG_CORE_SECURE_CRT_H\n"
"#include <assert.h>\n"
"#include <stdarg.h>\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#include <strings.h>\n"
"#include <wchar.h>\n"
"\n"
"inline void memcpy_s(void* dest, [[maybe_unused]] size_t destSize, const void* src, size_t count)\n"
"{\n"
"    assert(destSize >= count);\n"
"    memcpy(dest, src, count);\n"
"}\n"
"\n"
"#define _TRUNCATE ((size_t)-1)\n"
"#define _stricmp strcasecmp\n"
"\n"
"inline void fopen_s(FILE** f, const char* fileName, const char* mode)\n"
"{\n"
"    *f = fopen(fileName, mode);\n"
"}\n"
"\n"
"inline size_t fread_s(\n"
"    void* buffer,\n"
"    [[maybe_unused]] size_t bufferSize,\n"
"    size_t elementSize,\n"
"    size_t count,\n"
"    FILE* stream)\n"
"{\n"
"    assert(bufferSize >= elementSize * count);\n"
"    return fread(buffer, elementSize, count, stream);\n"
"}\n"
"\n"
"inline size_t wcsnlen_s(const wchar_t* str, size_t /*numberofElements*/)\n"
"{\n"
"    return wcslen(str);\n"
"}\n"
"\n"
"inline size_t strnlen_s(const char* str, size_t numberOfElements)\n"
"{\n"
"#if defined(__CYGWIN__)\n"
"    const char* cur = str;\n"
"    if (str)\n"
"    {\n"
"        const char* const end = str + numberOfElements;\n"
"        while (*cur && cur < end)\n"
"            cur++;\n"
"    }\n"
"    return size_t(cur - str);\n"
"#else\n"
"    return strnlen(str, numberOfElements);\n"
"#endif\n"
"}\n"
"\n"
"__attribute__((format(printf, 3, 4))) inline int sprintf_s(\n"
"    char* buffer,\n"
"    size_t sizeOfBuffer,\n"
"    const char* format,\n"
"    ...)\n"
"{\n"
"    va_list argptr;\n"
"    va_start(argptr, format);\n"
"    int rs = vsnprintf(buffer, sizeOfBuffer, format, argptr);\n"
"    va_end(argptr);\n"
"    return rs;\n"
"}\n"
"\n"
"// A patch was submitted to GCC wchar_t support in 2001, so I'm sure we can\n"
"// enable this any day now...\n"
"// __attribute__((format(wprintf, 3, 4)))\n"
"inline int swprintf_s(wchar_t* buffer, size_t sizeOfBuffer, const wchar_t* format, ...)\n"
"{\n"
"    va_list argptr;\n"
"    va_start(argptr, format);\n"
"    int rs = vswprintf(buffer, sizeOfBuffer, format, argptr);\n"
"    va_end(argptr);\n"
"    return rs;\n"
"}\n"
"\n"
"inline void wcscpy_s(wchar_t* strDestination, size_t /*numberOfElements*/, const wchar_t* strSource)\n"
"{\n"
"    wcscpy(strDestination, strSource);\n"
"}\n"
"inline void strcpy_s(char* strDestination, size_t /*numberOfElements*/, const char* strSource)\n"
"{\n"
"    strcpy(strDestination, strSource);\n"
"}\n"
"\n"
"inline void wcsncpy_s(\n"
"    wchar_t* strDestination,\n"
"    size_t /*numberOfElements*/,\n"
"    const wchar_t* strSource,\n"
"    size_t count)\n"
"{\n"
"    wcsncpy(strDestination, strSource, count);\n"
"}\n"
"inline void strncpy_s(\n"
"    char* strDestination,\n"
"    size_t /*numberOfElements*/,\n"
"    const char* strSource,\n"
"    size_t count)\n"
"{\n"
"    strncpy(strDestination, strSource, count);\n"
"}\n"
"#endif\n"
"#endif\n"
"\n"
"#ifndef SLANG_CORE_SMART_POINTER_H\n"
"#define SLANG_CORE_SMART_POINTER_H\n"
"\n"
"#ifndef SLANG_CORE_TYPE_TRAITS_H\n"
"#define SLANG_CORE_TYPE_TRAITS_H\n"
"\n"
"namespace Slang\n"
"{\n"
"struct TraitResultYes\n"
"{\n"
"    char x;\n"
"};\n"
"struct TraitResultNo\n"
"{\n"
"    char x[2];\n"
"};\n"
"\n"
"template<typename B, typename D>\n"
"struct IsBaseOfTraitHost\n"
"{\n"
"    operator B*() const { return nullptr; }\n"
"    operator D*() { return nullptr; }\n"
"};\n"
"\n"
"template<typename B, typename D>\n"
"struct IsBaseOf\n"
"{\n"
"    template<typename T>\n"
"    static TraitResultYes Check(D*, T)\n"
"    {\n"
"        return TraitResultYes();\n"
"    }\n"
"    static TraitResultNo Check(B*, int) { return TraitResultNo(); }\n"
"    enum\n"
"    {\n"
"        Value = sizeof(Check(IsBaseOfTraitHost<B, D>(), int())) == sizeof(TraitResultYes)\n"
"    };\n"
"};\n"
"\n"
"template<bool B, class T = void>\n"
"struct EnableIf\n"
"{\n"
"};\n"
"\n"
"template<class T>\n"
"struct EnableIf<true, T>\n"
"{\n"
"    typedef T type;\n"
"};\n"
"\n"
"template<typename B, typename D>\n"
"struct IsConvertible\n"
"{\n"
"    static TraitResultYes Use(B) { return TraitResultYes(); };\n"
"    static TraitResultNo Use(...) { return TraitResultNo(); };\n"
"    enum\n"
"    {\n"
"        Value = sizeof(Use(*(D*)(nullptr))) == sizeof(TraitResultYes)\n"
"    };\n"
"};\n"
"} // namespace Slang\n"
"\n"
"#endif\n"
"\n"
"\n"
"namespace Slang\n"
"{\n"
"// Base class for all reference-counted objects\n"
"class SLANG_RT_API RefObject\n"
"{\n"
"private:\n"
"    UInt referenceCount;\n"
"\n"
"public:\n"
"    RefObject()\n"
"        : referenceCount(0)\n"
"    {\n"
"    }\n"
"\n"
"    RefObject(const RefObject&)\n"
"        : referenceCount(0)\n"
"    {\n"
"    }\n"
"\n"
"    RefObject& operator=(const RefObject&) { return *this; }\n"
"\n"
"    virtual ~RefObject() {}\n"
"\n"
"    UInt addReference() { return ++referenceCount; }\n"
"\n"
"    UInt decreaseReference() { return --referenceCount; }\n"
"\n"
"    UInt releaseReference()\n"
"    {\n"
"        SLANG_ASSERT(referenceCount != 0);\n"
"        if (--referenceCount == 0)\n"
"        {\n"
"            delete this;\n"
"            return 0;\n"
"        }\n"
"        return referenceCount;\n"
"    }\n"
"\n"
"    bool isUniquelyReferenced()\n"
"    {\n"
"        SLANG_ASSERT(referenceCount != 0);\n"
"        return referenceCount == 1;\n"
"    }\n"
"\n"
"    UInt debugGetReferenceCount() { return referenceCount; }\n"
"};\n"
"\n"
"SLANG_FORCE_INLINE void addReference(RefObject* obj)\n"
"{\n"
"    if (obj)\n"
"        obj->addReference();\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void releaseReference(RefObject* obj)\n"
"{\n"
"    if (obj)\n"
"        obj->releaseReference();\n"
"}\n"
"\n"
"// For straight dynamic cast.\n"
"// Use instead of dynamic_cast as it allows for replacement without using Rtti in the future\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE T* dynamicCast(RefObject* obj)\n"
"{\n"
"    return dynamic_cast<T*>(obj);\n"
"}\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE const T* dynamicCast(const RefObject* obj)\n"
"{\n"
"    return dynamic_cast<const T*>(obj);\n"
"}\n"
"\n"
"// Like a dynamicCast, but allows a type to implement a specific implementation that is suitable for\n"
"// it\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE T* as(RefObject* obj)\n"
"{\n"
"    return dynamicCast<T>(obj);\n"
"}\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE const T* as(const RefObject* obj)\n"
"{\n"
"    return dynamicCast<T>(obj);\n"
"}\n"
"\n"
"// \"Smart\" pointer to a reference-counted object\n"
"template<typename T>\n"
"struct SLANG_RT_API RefPtr\n"
"{\n"
"    RefPtr()\n"
"        : pointer(nullptr)\n"
"    {\n"
"    }\n"
"\n"
"    RefPtr(T* p)\n"
"        : pointer(p)\n"
"    {\n"
"        addReference(p);\n"
"    }\n"
"\n"
"    RefPtr(RefPtr<T> const& p)\n"
"        : pointer(p.pointer)\n"
"    {\n"
"        addReference(p.pointer);\n"
"    }\n"
"\n"
"    RefPtr(RefPtr<T>&& p)\n"
"        : pointer(p.pointer)\n"
"    {\n"
"        p.pointer = nullptr;\n"
"    }\n"
"\n"
"    template<typename U>\n"
"    RefPtr(RefPtr<U> const& p, typename EnableIf<IsConvertible<T*, U*>::Value, void>::type* = 0)\n"
"        : pointer(static_cast<U*>(p))\n"
"    {\n"
"        addReference(static_cast<U*>(p));\n"
"    }\n"
"\n"
"#if 0\n"
"        void operator=(T* p)\n"
"        {\n"
"            T* old = pointer;\n"
"            addReference(p);\n"
"            pointer = p;\n"
"            releaseReference(old);\n"
"        }\n"
"#endif\n"
"\n"
"    void operator=(RefPtr<T> const& p)\n"
"    {\n"
"        T* old = pointer;\n"
"        addReference(p.pointer);\n"
"        pointer = p.pointer;\n"
"        releaseReference(old);\n"
"    }\n"
"\n"
"    void operator=(RefPtr<T>&& p)\n"
"    {\n"
"        T* old = pointer;\n"
"        pointer = p.pointer;\n"
"        p.pointer = old;\n"
"    }\n"
"\n"
"    template<typename U>\n"
"    typename EnableIf<IsConvertible<T*, U*>::value, void>::type operator=(RefPtr<U> const& p)\n"
"    {\n"
"        T* old = pointer;\n"
"        addReference(p.pointer);\n"
"        pointer = p.pointer;\n"
"        releaseReference(old);\n"
"    }\n"
"\n"
"    HashCode getHashCode() const\n"
"    {\n"
"        // Note: We need a `RefPtr<T>` to hash the same as a `T*`,\n"
"        // so that a `T*` can be used as a key in a dictionary with\n"
"        // `RefPtr<T>` keys, and vice versa.\n"
"        //\n"
"        return Slang::getHashCode(pointer);\n"
"    }\n"
"\n"
"    bool operator==(const T* ptr) const { return pointer == ptr; }\n"
"\n"
"    bool operator!=(const T* ptr) const { return pointer != ptr; }\n"
"\n"
"    bool operator==(RefPtr<T> const& ptr) const { return pointer == ptr.pointer; }\n"
"\n"
"    bool operator!=(RefPtr<T> const& ptr) const { return pointer != ptr.pointer; }\n"
"\n"
"    template<typename U>\n"
"    RefPtr<U> dynamicCast() const\n"
"    {\n"
"        return RefPtr<U>(Slang::dynamicCast<U>(pointer));\n"
"    }\n"
"\n"
"    template<typename U>\n"
"    RefPtr<U> as() const\n"
"    {\n"
"        return RefPtr<U>(Slang::as<U>(pointer));\n"
"    }\n"
"\n"
"    template<typename U>\n"
"    bool is() const\n"
"    {\n"
"        return Slang::as<U>(pointer) != nullptr;\n"
"    }\n"
"\n"
"    ~RefPtr() { releaseReference(static_cast<Slang::RefObject*>(pointer)); }\n"
"\n"
"    T& operator*() const { return *pointer; }\n"
"\n"
"    T* operator->() const { return pointer; }\n"
"\n"
"    T* Ptr() const { return pointer; }\n"
"\n"
"    T* get() const { return pointer; }\n"
"\n"
"    operator T*() const { return pointer; }\n"
"\n"
"    void attach(T* p)\n"
"    {\n"
"        T* old = pointer;\n"
"        pointer = p;\n"
"        releaseReference(old);\n"
"    }\n"
"\n"
"    T* detach()\n"
"    {\n"
"        auto rs = pointer;\n"
"        pointer = nullptr;\n"
"        return rs;\n"
"    }\n"
"\n"
"    void swapWith(RefPtr<T>& rhs)\n"
"    {\n"
"        auto rhsPtr = rhs.pointer;\n"
"        rhs.pointer = pointer;\n"
"        pointer = rhsPtr;\n"
"    }\n"
"\n"
"    SLANG_FORCE_INLINE void setNull()\n"
"    {\n"
"        releaseReference(pointer);\n"
"        pointer = nullptr;\n"
"    }\n"
"\n"
"    /// Get ready for writing (nulls contents)\n"
"    SLANG_FORCE_INLINE T** writeRef()\n"
"    {\n"
"        *this = nullptr;\n"
"        return &pointer;\n"
"    }\n"
"\n"
"    /// Get for read access\n"
"    SLANG_FORCE_INLINE T* const* readRef() const { return &pointer; }\n"
"\n"
"private:\n"
"    T* pointer;\n"
"};\n"
"\n"
"// Helper type for implementing weak pointers. The object being pointed at weakly creates a WeakSink\n"
"// object that other objects can reference and share. When the object is destroyed it detaches the\n"
"// sink doing so will make other users call to 'get' return null. Thus any user of the WeakSink,\n"
"// must check if the weakly pointed to things pointer is nullptr before using.\n"
"template<typename T>\n"
"class WeakSink : public RefObject\n"
"{\n"
"public:\n"
"    WeakSink(T* ptr)\n"
"        : m_ptr(ptr)\n"
"    {\n"
"    }\n"
"\n"
"    SLANG_FORCE_INLINE T* get() const { return m_ptr; }\n"
"    SLANG_FORCE_INLINE void detach() { m_ptr = nullptr; }\n"
"\n"
"private:\n"
"    T* m_ptr;\n"
"};\n"
"\n"
"// A pointer that can be transformed to hold either a weak reference or a strong reference.\n"
"template<typename T>\n"
"class TransformablePtr\n"
"{\n"
"private:\n"
"    T* m_weakPtr = nullptr;\n"
"    RefPtr<T> m_strongPtr;\n"
"\n"
"public:\n"
"    TransformablePtr() = default;\n"
"    TransformablePtr(T* ptr) { *this = ptr; }\n"
"    TransformablePtr(RefPtr<T> ptr) { *this = ptr; }\n"
"    TransformablePtr(const TransformablePtr<T>& ptr) = default;\n"
"    TransformablePtr<T>& operator=(const TransformablePtr<T>& ptr) = default;\n"
"\n"
"    void promoteToStrongReference() { m_strongPtr = m_weakPtr; }\n"
"    void demoteToWeakReference() { m_strongPtr = nullptr; }\n"
"    bool isStrongReference() const { return m_strongPtr != nullptr; }\n"
"\n"
"    T& operator*() const { return *m_weakPtr; }\n"
"\n"
"    T* operator->() const { return m_weakPtr; }\n"
"\n"
"    T* Ptr() const { return m_weakPtr; }\n"
"    T* get() const { return m_weakPtr; }\n"
"\n"
"    operator T*() const { return m_weakPtr; }\n"
"    operator RefPtr<T>() const { return m_weakPtr; }\n"
"\n"
"\n"
"    TransformablePtr<T>& operator=(T* ptr)\n"
"    {\n"
"        m_weakPtr = ptr;\n"
"        m_strongPtr = ptr;\n"
"        return *this;\n"
"    }\n"
"    template<typename U>\n"
"    TransformablePtr<T>& operator=(const RefPtr<U>& ptr)\n"
"    {\n"
"        m_weakPtr = ptr.Ptr();\n"
"        m_strongPtr = ptr;\n"
"        return *this;\n"
"    }\n"
"\n"
"    HashCode getHashCode() const\n"
"    {\n"
"        // Note: We need a `RefPtr<T>` to hash the same as a `T*`,\n"
"        // so that a `T*` can be used as a key in a dictionary with\n"
"        // `RefPtr<T>` keys, and vice versa.\n"
"        //\n"
"        return Slang::getHashCode(m_weakPtr);\n"
"    }\n"
"\n"
"    bool operator==(const T* ptr) const { return m_weakPtr == ptr; }\n"
"\n"
"    bool operator!=(const T* ptr) const { return m_weakPtr != ptr; }\n"
"\n"
"    bool operator==(RefPtr<T> const& ptr) const { return m_weakPtr == ptr.Ptr(); }\n"
"\n"
"    bool operator!=(RefPtr<T> const& ptr) const { return m_weakPtr != ptr.Ptr(); }\n"
"\n"
"    bool operator==(TransformablePtr<T> const& ptr) const { return m_weakPtr == ptr.m_weakPtr; }\n"
"\n"
"    bool operator!=(TransformablePtr<T> const& ptr) const { return m_weakPtr != ptr.m_weakPtr; }\n"
"};\n"
"} // namespace Slang\n"
"#endif\n"
"\n"
"#pragma once\n"
"\n"
"#include <cstdint>\n"
"#include <cstring>\n"
"#include <type_traits>\n"
"\n"
"namespace Slang\n"
"{\n"
"//\n"
"// Types\n"
"//\n"
"\n"
"struct StableHashCode64\n"
"{\n"
"    uint64_t hash;\n"
"    explicit operator uint64_t() const { return hash; }\n"
"    bool operator==(StableHashCode64 other) const { return other.hash == hash; };\n"
"    bool operator!=(StableHashCode64 other) const { return other.hash != hash; };\n"
"};\n"
"\n"
"struct StableHashCode32\n"
"{\n"
"    uint32_t hash;\n"
"    explicit operator uint32_t() const { return hash; }\n"
"    bool operator==(StableHashCode32 other) const { return other.hash == hash; };\n"
"    bool operator!=(StableHashCode32 other) const { return other.hash != hash; };\n"
"};\n"
"\n"
"/* The 'Stable' hash code functions produce hashes that must be\n"
"\n"
"* The same result for the same inputs on all targets\n"
"* Rarely change - as their values can change the output of the Slang API/Serialization\n"
"\n"
"Hash value used from the 'Stable' functions can also be used as part of serialization -\n"
"so it is in effect part of the API.\n"
"\n"
"In effect this means changing a 'Stable' algorithm will typically require doing a new release.\n"
"*/\n"
"inline StableHashCode64 getStableHashCode64(const char* buffer, size_t numChars)\n"
"{\n"
"    uint64_t hash = 0;\n"
"    for (size_t i = 0; i < numChars; ++i)\n"
"    {\n"
"        hash = uint64_t(buffer[i]) + (hash << 6) + (hash << 16) - hash;\n"
"    }\n"
"    return StableHashCode64{hash};\n"
"}\n"
"\n"
"template<typename T>\n"
"inline StableHashCode64 getStableHashCode64(const T& t)\n"
"{\n"
"    static_assert(std::has_unique_object_representations_v<T>);\n"
"    return getStableHashCode64(reinterpret_cast<const char*>(&t), sizeof(T));\n"
"}\n"
"\n"
;
sb << 
"inline StableHashCode32 getStableHashCode32(const char* buffer, size_t numChars)\n"
"{\n"
"    uint32_t hash = 0;\n"
"    for (size_t i = 0; i < numChars; ++i)\n"
"    {\n"
"        hash = uint32_t(buffer[i]) + (hash << 6) + (hash << 16) - hash;\n"
"    }\n"
"    return StableHashCode32{hash};\n"
"}\n"
"\n"
"template<typename T>\n"
"inline StableHashCode32 getStableHashCode32(const T& t)\n"
"{\n"
"    static_assert(std::has_unique_object_representations_v<T>);\n"
"    return getStableHashCode32(reinterpret_cast<const char*>(&t), sizeof(T));\n"
"}\n"
"\n"
"inline StableHashCode64 combineStableHash(StableHashCode64 h)\n"
"{\n"
"    return h;\n"
"}\n"
"\n"
"inline StableHashCode32 combineStableHash(StableHashCode32 h)\n"
"{\n"
"    return h;\n"
"}\n"
"\n"
"// A left fold with a mixing operation\n"
"template<typename H, typename... Hs>\n"
"H combineStableHash(H n, H m, Hs... args)\n"
"{\n"
"    return combineStableHash(H{(n.hash * 16777619) ^ m.hash}, args...);\n"
"}\n"
"} // namespace Slang\n"
"\n"
"// > Please draw a small horse in ASCII art:\n"
"//\n"
"//           ,~~.\n"
"//          (  9 )-_,\n"
"//  (\\___ )=='-' )\n"
"//   \\ .   ) )  /\n"
"//    \\ `-' /  /\n"
"// ~'`~'`~'`~'`~\n"
"//\n"
"\n"
"\n"
"#include <cstdlib>\n"
"#include <iostream>\n"
"#include <new>\n"
"#include <stdio.h>\n"
"#include <string.h>\n"
"#include <type_traits>\n"
"\n"
"namespace Slang\n"
"{\n"
"class _EndLine\n"
"{\n"
"};\n"
"extern _EndLine EndLine;\n"
"\n"
"// in-place reversion, works only for ascii string\n"
"inline void reverseInplaceAscii(char* buffer, int length)\n"
"{\n"
"    int i, j;\n"
"    char c;\n"
"    for (i = 0, j = length - 1; i < j; i++, j--)\n"
"    {\n"
"        c = buffer[i];\n"
"        buffer[i] = buffer[j];\n"
"        buffer[j] = c;\n"
"    }\n"
"}\n"
"template<typename IntType>\n"
"inline int intToAscii(char* buffer, IntType val, int radix, int padTo = 0)\n"
"{\n"
"    static_assert(std::is_integral_v<IntType>);\n"
"\n"
"    int i = 0;\n"
"    IntType sign;\n"
"\n"
"    sign = val;\n"
"    if (sign < 0)\n"
"    {\n"
"        val = (IntType)(0 - val);\n"
"    }\n"
"\n"
"    do\n"
"    {\n"
"        int digit = (val % radix);\n"
"        if (digit <= 9)\n"
"            buffer[i++] = (char)(digit + '0');\n"
"        else\n"
"            buffer[i++] = (char)(digit - 10 + 'A');\n"
"    } while ((val /= radix) > 0);\n"
"\n"
"    SLANG_ASSERT(i >= 0);\n"
"    while (i < padTo)\n"
"        buffer[i++] = '0';\n"
"\n"
"    if (sign < 0)\n"
"        buffer[i++] = '-';\n"
"\n"
"    // Put in normal character order\n"
"    reverseInplaceAscii(buffer, i);\n"
"\n"
"    buffer[i] = '\\0';\n"
"    return i;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE bool isUtf8LeadingByte(char ch)\n"
"{\n"
"    return (((unsigned char)ch) & 0xC0) == 0xC0;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE bool isUtf8ContinuationByte(char ch)\n"
"{\n"
"    return (((unsigned char)ch) & 0xC0) == 0x80;\n"
"}\n"
"\n"
"/* A string slice that doesn't own the contained characters.\n"
"It is the responsibility of code using the type to keep the memory backing\n"
"the slice in scope.\n"
"A slice is generally *not* zero terminated. */\n"
"struct SLANG_RT_API UnownedStringSlice\n"
"{\n"
"public:\n"
"    typedef UnownedStringSlice ThisType;\n"
"\n"
"    // Type to indicate that a ctor is with a length to disabmiguate 0/nullptr\n"
"    // causing ambiguity.\n"
"    struct WithLength\n"
"    {\n"
"    };\n"
"\n"
"    UnownedStringSlice()\n"
"        : m_begin(nullptr), m_end(nullptr)\n"
"    {\n"
"    }\n"
"\n"
"    explicit UnownedStringSlice(char const* a)\n"
"        : m_begin(a), m_end(a ? a + strlen(a) : nullptr)\n"
"    {\n"
"    }\n"
"    UnownedStringSlice(char const* b, char const* e)\n"
"        : m_begin(b), m_end(e)\n"
"    {\n"
"    }\n"
"    UnownedStringSlice(char const* b, size_t len)\n"
"        : m_begin(b), m_end(b + len)\n"
"    {\n"
"    }\n"
"    UnownedStringSlice(WithLength, char const* b, size_t len)\n"
"        : m_begin(b), m_end(b + len)\n"
"    {\n"
"    }\n"
"\n"
"    SLANG_FORCE_INLINE char const* begin() const { return m_begin; }\n"
"\n"
"    SLANG_FORCE_INLINE char const* end() const { return m_end; }\n"
"\n"
"    /// True if slice is strictly contained in memory.\n"
"    bool isMemoryContained(const UnownedStringSlice& slice) const\n"
"    {\n"
"        return slice.m_begin >= m_begin && slice.m_end <= m_end;\n"
"    }\n"
"    bool isMemoryContained(const char* pos) const { return pos >= m_begin && pos <= m_end; }\n"
"\n"
"    /// Get the length in *bytes*\n"
"    Count getLength() const { return Index(m_end - m_begin); }\n"
"\n"
"    /// Finds first index of char 'c'. If not found returns -1.\n"
"    Index indexOf(char c) const;\n"
"    /// Find first index of slice. If not found returns -1\n"
"    Index indexOf(const UnownedStringSlice& slice) const;\n"
"\n"
"    /// Returns a substring. idx is the start index, and len\n"
"    /// is the amount of characters.\n"
"    /// The returned length might be truncated, if len extends beyond slice.\n"
"    UnownedStringSlice subString(Index idx, Index len) const;\n"
"\n"
"    /// Return a head of the slice - everything up to the index\n"
"    SLANG_FORCE_INLINE UnownedStringSlice head(Index idx) const\n"
"    {\n"
"        SLANG_ASSERT(idx >= 0 && idx <= getLength());\n"
"        return UnownedStringSlice(m_begin, idx);\n"
"    }\n"
"    /// Return a tail of the slice - everything from the index to the end of the slice\n"
"    SLANG_FORCE_INLINE UnownedStringSlice tail(Index idx) const\n"
"    {\n"
"        SLANG_ASSERT(idx >= 0 && idx <= getLength());\n"
"        return UnownedStringSlice(m_begin + idx, m_end);\n"
"    }\n"
"\n"
"    /// True if rhs and this are equal without having to take into account case\n"
"    /// Note 'case' here is *not* locale specific - it is only A-Z and a-z\n"
"    bool caseInsensitiveEquals(const ThisType& rhs) const;\n"
"\n"
"    Index lastIndexOf(char c) const\n"
"    {\n"
"        const Index size = Index(m_end - m_begin);\n"
"        for (Index i = size - 1; i >= 0; --i)\n"
"        {\n"
"            if (m_begin[i] == c)\n"
"            {\n"
"                return i;\n"
"            }\n"
"        }\n"
"        return -1;\n"
"    }\n"
"\n"
"    const char& operator[](Index i) const\n"
"    {\n"
"        assert(i >= 0 && i < Index(m_end - m_begin));\n"
"        return m_begin[i];\n"
"    }\n"
"\n"
"    bool operator==(ThisType const& other) const;\n"
"    bool operator!=(UnownedStringSlice const& other) const { return !(*this == other); }\n"
"\n"
"    bool operator==(char const* str) const { return (*this) == UnownedStringSlice(str); }\n"
"    bool operator!=(char const* str) const { return !(*this == str); }\n"
"\n"
"    /// True if contents is a single char of c\n"
"    SLANG_FORCE_INLINE bool isChar(char c) const { return getLength() == 1 && m_begin[0] == c; }\n"
"\n"
"    bool startsWithCaseInsensitive(UnownedStringSlice const& other) const;\n"
"    bool startsWith(UnownedStringSlice const& other) const;\n"
"    bool startsWith(char const* str) const;\n"
"\n"
"    bool endsWithCaseInsensitive(UnownedStringSlice const& other) const;\n"
"    bool endsWithCaseInsensitive(char const* str) const;\n"
"\n"
"    bool endsWith(UnownedStringSlice const& other) const;\n"
"    bool endsWith(char const* str) const;\n"
"\n"
"    /// Trims any horizontal whitespace from the start and end and returns as a substring\n"
"    UnownedStringSlice trim() const;\n"
"    /// Trims any 'c' from the start or the end, and returns as a substring\n"
"    UnownedStringSlice trim(char c) const;\n"
"\n"
"    /// Trims any horizontal whitespace from start and returns as a substring\n"
"    UnownedStringSlice trimStart() const;\n"
"\n"
"    static constexpr bool kHasUniformHash = true;\n"
"    HashCode64 getHashCode() const { return Slang::getHashCode(m_begin, size_t(m_end - m_begin)); }\n"
"\n"
"    template<size_t SIZE>\n"
"    SLANG_FORCE_INLINE static UnownedStringSlice fromLiteral(const char (&in)[SIZE])\n"
"    {\n"
"        return UnownedStringSlice(in, SIZE - 1);\n"
"    }\n"
"\n"
"protected:\n"
"    char const* m_begin;\n"
"    char const* m_end;\n"
"};\n"
"\n"
"/// Three-way comparison of string slices.\n"
"///\n"
"/// * Returns 0 if `lhs == rhs`\n"
"/// * Returns a value < 0 if `lhs < rhs`\n"
"/// * Returns a value > 0 if `lhs > rhs`\n"
"///\n"
"int compare(UnownedStringSlice const& lhs, UnownedStringSlice const& rhs);\n"
"\n"
"// A more convenient way to make slices from *string literals*\n"
"template<size_t SIZE>\n"
"SLANG_FORCE_INLINE UnownedStringSlice toSlice(const char (&in)[SIZE])\n"
"{\n"
"    return UnownedStringSlice(in, SIZE - 1);\n"
"}\n"
"\n"
"/// Same as UnownedStringSlice, but must be zero terminated.\n"
"/// Zero termination is *not* included in the length.\n"
"struct SLANG_RT_API UnownedTerminatedStringSlice : public UnownedStringSlice\n"
"{\n"
"public:\n"
"    typedef UnownedStringSlice Super;\n"
"    typedef UnownedTerminatedStringSlice ThisType;\n"
"\n"
"    /// We can turn into a regular zero terminated string\n"
"    SLANG_FORCE_INLINE operator const char*() const { return m_begin; }\n"
"\n"
"    /// Exists to match the equivalent function in String.\n"
"    SLANG_FORCE_INLINE char const* getBuffer() const { return m_begin; }\n"
"\n"
"    /// Construct from a literal directly.\n"
"    template<size_t SIZE>\n"
"    SLANG_FORCE_INLINE static ThisType fromLiteral(const char (&in)[SIZE])\n"
"    {\n"
"        return ThisType(in, SIZE - 1);\n"
"    }\n"
"\n"
"    /// Default constructor\n"
"    UnownedTerminatedStringSlice()\n"
"        : Super(Super::WithLength(), \"\", 0)\n"
"    {\n"
"    }\n"
"\n"
"    /// Note, b cannot be null because if it were then the string would not be null terminated\n"
"    UnownedTerminatedStringSlice(char const* b)\n"
"        : Super(b, b + strlen(b))\n"
"    {\n"
"    }\n"
"    UnownedTerminatedStringSlice(char const* b, size_t len)\n"
"        : Super(b, len)\n"
"    {\n"
"        // b must be valid and it must be null terminated\n"
"        SLANG_ASSERT(b && b[len] == 0);\n"
"    }\n"
"};\n"
"\n"
"// A more convenient way to make terminated slices from *string literals*\n"
"template<size_t SIZE>\n"
"SLANG_FORCE_INLINE UnownedTerminatedStringSlice toTerminatedSlice(const char (&in)[SIZE])\n"
"{\n"
"    return UnownedTerminatedStringSlice(in, SIZE - 1);\n"
"}\n"
"\n"
"// A `StringRepresentation` provides the backing storage for\n"
"// all reference-counted string-related types.\n"
"class SLANG_RT_API StringRepresentation : public RefObject\n"
"{\n"
"public:\n"
"    Index length;\n"
"    Index capacity;\n"
"\n"
"    SLANG_FORCE_INLINE Index getLength() const { return length; }\n"
"\n"
"    SLANG_FORCE_INLINE char* getData() { return (char*)(this + 1); }\n"
"    SLANG_FORCE_INLINE const char* getData() const { return (const char*)(this + 1); }\n"
"\n"
"    /// Set the contents to be the slice. Must be enough capacity to hold the slice.\n"
"    void setContents(const UnownedStringSlice& slice);\n"
"\n"
"    static const char* getData(const StringRepresentation* stringRep)\n"
"    {\n"
"        return stringRep ? stringRep->getData() : \"\";\n"
"    }\n"
"\n"
"    static UnownedStringSlice asSlice(const StringRepresentation* rep)\n"
"    {\n"
"        return rep ? UnownedStringSlice(rep->getData(), rep->getLength()) : UnownedStringSlice();\n"
"    }\n"
"\n"
"    static bool equal(const StringRepresentation* a, const StringRepresentation* b)\n"
"    {\n"
"        return (a == b) || asSlice(a) == asSlice(b);\n"
"    }\n"
"\n"
"    static StringRepresentation* createWithCapacityAndLength(Index capacity, Index length)\n"
"    {\n"
"        SLANG_ASSERT(capacity >= length);\n"
"        void* allocation = operator new(sizeof(StringRepresentation) + capacity + 1);\n"
"        StringRepresentation* obj = new (allocation) StringRepresentation();\n"
"        obj->capacity = capacity;\n"
"        obj->length = length;\n"
"        obj->getData()[length] = 0;\n"
"        return obj;\n"
"    }\n"
"\n"
"    static StringRepresentation* createWithCapacity(Index capacity)\n"
"    {\n"
"        return createWithCapacityAndLength(capacity, 0);\n"
"    }\n"
"\n"
"    static StringRepresentation* createWithLength(Index length)\n"
"    {\n"
"        return createWithCapacityAndLength(length, length);\n"
"    }\n"
"\n"
"    /// Create a representation from the slice. If slice is empty will return nullptr.\n"
"    static StringRepresentation* create(const UnownedStringSlice& slice);\n"
"    /// Same as create, but representation will have refcount of 1 (if not nullptr)\n"
"    static StringRepresentation* createWithReference(const UnownedStringSlice& slice);\n"
"\n"
"    StringRepresentation* cloneWithCapacity(Index newCapacity)\n"
"    {\n"
"        StringRepresentation* newObj = createWithCapacityAndLength(newCapacity, length);\n"
"        memcpy(getData(), newObj->getData(), length + 1);\n"
"        return newObj;\n"
"    }\n"
"\n"
"    StringRepresentation* clone() { return cloneWithCapacity(length); }\n"
"\n"
"    StringRepresentation* ensureCapacity(Index required)\n"
"    {\n"
"        if (capacity >= required)\n"
"            return this;\n"
"\n"
"        Index newCapacity = capacity;\n"
"        if (!newCapacity)\n"
"            newCapacity = 16; // TODO: figure out good value for minimum capacity\n"
"\n"
"        while (newCapacity < required)\n"
"        {\n"
"            newCapacity = 2 * newCapacity;\n"
"        }\n"
"\n"
"        return cloneWithCapacity(newCapacity);\n"
"    }\n"
"\n"
"    /// Overload delete to silence ASAN new-delete-type-mismatch errors.\n"
"    /// These occur because the allocation size of StringRepresentation\n"
"    /// does not match deallocation size (due variable sized string payload).\n"
"    void operator delete(void* p)\n"
"    {\n"
"        StringRepresentation* str = (StringRepresentation*)p;\n"
"        ::operator delete(str);\n"
"    }\n"
"};\n"
"\n"
"class String;\n"
"\n"
"struct SLANG_RT_API StringSlice\n"
"{\n"
"public:\n"
"    StringSlice();\n"
"\n"
"    StringSlice(String const& str);\n"
"\n"
"    StringSlice(String const& str, UInt beginIndex, UInt endIndex);\n"
"\n"
"    UInt getLength() const { return endIndex - beginIndex; }\n"
"\n"
"    char const* begin() const\n"
"    {\n"
"        return representation ? representation->getData() + beginIndex : \"\";\n"
"    }\n"
"\n"
"    char const* end() const { return begin() + getLength(); }\n"
"\n"
"private:\n"
"    RefPtr<StringRepresentation> representation;\n"
"    UInt beginIndex;\n"
"    UInt endIndex;\n"
"\n"
"    friend class String;\n"
"\n"
"    StringSlice(RefPtr<StringRepresentation> const& representation, UInt beginIndex, UInt endIndex)\n"
"        : representation(representation), beginIndex(beginIndex), endIndex(endIndex)\n"
"    {\n"
"    }\n"
"};\n"
"\n"
"/// String as expected by underlying platform APIs\n"
"class SLANG_RT_API OSString\n"
"{\n"
"public:\n"
"    /// Default\n"
"    OSString();\n"
"    /// NOTE! This assumes that begin is a new wchar_t[] buffer, and it will\n"
"    /// now be owned by the OSString\n"
"    OSString(wchar_t* begin, wchar_t* end);\n"
"    /// Move Ctor\n"
"    OSString(OSString&& rhs)\n"
"        : m_begin(rhs.m_begin), m_end(rhs.m_end)\n"
"    {\n"
"        rhs.m_begin = nullptr;\n"
"        rhs.m_end = nullptr;\n"
"    }\n"
"    // Copy Ctor\n"
"    OSString(const OSString& rhs)\n"
"        : m_begin(nullptr), m_end(nullptr)\n"
"    {\n"
"        set(rhs.m_begin, rhs.m_end);\n"
"    }\n"
"\n"
"    /// =\n"
"    void operator=(const OSString& rhs) { set(rhs.m_begin, rhs.m_end); }\n"
"    void operator=(OSString&& rhs)\n"
"    {\n"
"        auto begin = m_begin;\n"
"        auto end = m_end;\n"
"        m_begin = rhs.m_begin;\n"
"        m_end = rhs.m_end;\n"
"        rhs.m_begin = begin;\n"
"        rhs.m_end = end;\n"
"    }\n"
"\n"
"    ~OSString() { _releaseBuffer(); }\n"
"\n"
"    size_t getLength() const { return (m_end - m_begin); }\n"
"    void set(const wchar_t* begin, const wchar_t* end);\n"
"\n"
"    operator wchar_t const*() const { return begin(); }\n"
"\n"
"    wchar_t const* begin() const;\n"
"    wchar_t const* end() const;\n"
"\n"
"private:\n"
"    void _releaseBuffer();\n"
"\n"
"    wchar_t* m_begin; ///< First character. This is a new wchar_t[] buffer\n"
"    wchar_t* m_end;   ///< Points to terminating 0\n"
"};\n"
"\n"
"/*!\n"
"@brief Represents an owned, zero-terminated UTF-8 encoded string.\n"
"*/\n"
"class SLANG_RT_API String\n"
"{\n"
"    friend struct StringSlice;\n"
"    friend class StringBuilder;\n"
"\n"
"private:\n"
"    char* getData() const { return m_buffer ? m_buffer->getData() : (char*)\"\"; }\n"
"\n"
"\n"
"    void ensureUniqueStorageWithCapacity(Index capacity);\n"
"\n"
"    RefPtr<StringRepresentation> m_buffer;\n"
"\n"
"public:\n"
"    explicit String(StringRepresentation* buffer)\n"
"        : m_buffer(buffer)\n"
"    {\n"
"    }\n"
"\n"
"    static String fromWString(const wchar_t* wstr);\n"
"    static String fromWString(const wchar_t* wstr, const wchar_t* wend);\n"
"    static String fromWChar(const wchar_t ch);\n"
"    static String fromUnicodePoint(Char32 codePoint);\n"
"\n"
"    String() {}\n"
"\n"
"    /// Returns a buffer which can hold at least count chars\n"
"    char* prepareForAppend(Index count);\n"
"    /// Append data written to buffer output via 'prepareForAppend' directly written 'inplace'\n"
"    void appendInPlace(const char* chars, Index count);\n"
"\n"
"    /// Get the internal string represenation\n"
"    SLANG_FORCE_INLINE StringRepresentation* getStringRepresentation() const { return m_buffer; }\n"
"\n"
"    /// Detach the representation (will leave string as empty). Rep ref count will remain unchanged.\n"
"    SLANG_FORCE_INLINE StringRepresentation* detachStringRepresentation()\n"
"    {\n"
"        return m_buffer.detach();\n"
"    }\n"
"\n"
"    const char* begin() const { return getData(); }\n"
"    const char* end() const { return getData() + getLength(); }\n"
"\n"
"    void append(int32_t value, int radix = 10);\n"
"    void append(uint32_t value, int radix = 10);\n"
"    void append(int64_t value, int radix = 10);\n"
"    void append(uint64_t value, int radix = 10);\n"
"    void append(float val, const char* format = \"%g\");\n"
"    void append(double val, const char* format = \"%g\");\n"
"\n"
"    // Padded hex representations\n"
"    void append(StableHashCode32 val);\n"
"    void append(StableHashCode64 val);\n"
"\n"
"    void append(char const* str);\n"
"    void append(char const* str, size_t len);\n"
"    void append(const char* textBegin, char const* textEnd);\n"
"    void append(char chr);\n"
"    void append(String const& str);\n"
"    void append(StringSlice const& slice);\n"
"    void append(UnownedStringSlice const& slice);\n"
"\n"
"    /// Append a character (to remove ambiguity with other integral types)\n"
"    void appendChar(char chr);\n"
"\n"
"    /// Append the specified char count times\n"
"    void appendRepeatedChar(char chr, Index count);\n"
"\n"
"    String(const char* str) { append(str); }\n"
"    String(const char* textBegin, char const* textEnd) { append(textBegin, textEnd); }\n"
"\n"
"    // Make all String ctors from a numeric explicit, to avoid unexpected/unnecessary conversions\n"
;
sb << 
"    explicit String(int32_t val, int radix = 10) { append(val, radix); }\n"
"    explicit String(uint32_t val, int radix = 10) { append(val, radix); }\n"
"    explicit String(int64_t val, int radix = 10) { append(val, radix); }\n"
"    explicit String(uint64_t val, int radix = 10) { append(val, radix); }\n"
"    explicit String(StableHashCode32 val) { append(val); }\n"
"    explicit String(StableHashCode64 val) { append(val); }\n"
"    explicit String(float val, const char* format = \"%g\") { append(val, format); }\n"
"    explicit String(double val, const char* format = \"%g\") { append(val, format); }\n"
"\n"
"    explicit String(char chr) { appendChar(chr); }\n"
"    String(String const& str) { m_buffer = str.m_buffer; }\n"
"    String(String&& other) { m_buffer = _Move(other.m_buffer); }\n"
"\n"
"    String(StringSlice const& slice) { append(slice); }\n"
"\n"
"    String(UnownedStringSlice const& slice) { append(slice); }\n"
"\n"
"    ~String() { m_buffer.setNull(); }\n"
"\n"
"    String& operator=(const String& str)\n"
"    {\n"
"        m_buffer = str.m_buffer;\n"
"        return *this;\n"
"    }\n"
"    String& operator=(String&& other)\n"
"    {\n"
"        m_buffer = _Move(other.m_buffer);\n"
"        return *this;\n"
"    }\n"
"    char operator[](Index id) const\n"
"    {\n"
"        SLANG_ASSERT(id >= 0 && id < getLength());\n"
"        // Silence a pedantic warning on GCC\n"
"#if __GNUC__\n"
"        if (id < 0)\n"
"            __builtin_unreachable();\n"
"#endif\n"
"        return begin()[id];\n"
"    }\n"
"\n"
"    Index getLength() const { return m_buffer ? m_buffer->getLength() : 0; }\n"
"    /// Make the length of the string the amount specified. Must be less than current size\n"
"    void reduceLength(Index length);\n"
"\n"
"    friend String operator+(const char* op1, const String& op2);\n"
"    friend String operator+(const String& op1, const char* op2);\n"
"    friend String operator+(const String& op1, const String& op2);\n"
"\n"
"    StringSlice trimStart() const\n"
"    {\n"
"        if (!m_buffer)\n"
"            return StringSlice();\n"
"        Index startIndex = 0;\n"
"        const char* const data = getData();\n"
"        while (startIndex < getLength() && (data[startIndex] == ' ' || data[startIndex] == '\\t' ||\n"
"                                            data[startIndex] == '\\r' || data[startIndex] == '\\n'))\n"
"            startIndex++;\n"
"        return StringSlice(m_buffer, startIndex, getLength());\n"
"    }\n"
"\n"
"    StringSlice trimEnd() const\n"
"    {\n"
"        if (!m_buffer)\n"
"            return StringSlice();\n"
"\n"
"        Index endIndex = getLength();\n"
"        const char* const data = getData();\n"
"        while (endIndex > 0 && (data[endIndex - 1] == ' ' || data[endIndex - 1] == '\\t' ||\n"
"                                data[endIndex - 1] == '\\r' || data[endIndex - 1] == '\\n'))\n"
"            endIndex--;\n"
"\n"
"        return StringSlice(m_buffer, 0, endIndex);\n"
"    }\n"
"\n"
"    StringSlice trim() const\n"
"    {\n"
"        if (!m_buffer)\n"
"            return StringSlice();\n"
"\n"
"        Index startIndex = 0;\n"
"        const char* const data = getData();\n"
"        while (startIndex < getLength() && (data[startIndex] == ' ' || data[startIndex] == '\\t' ||\n"
"                                            data[startIndex] == '\\r' || data[startIndex] == '\\n'))\n"
"            startIndex++;\n"
"        Index endIndex = getLength();\n"
"        while (endIndex > startIndex && (data[endIndex - 1] == ' ' || data[endIndex - 1] == '\\t' ||\n"
"                                         data[endIndex - 1] == '\\r' || data[endIndex - 1] == '\\n'))\n"
"            endIndex--;\n"
"\n"
"        return StringSlice(m_buffer, startIndex, endIndex);\n"
"    }\n"
"\n"
"    StringSlice subString(Index id, Index len) const\n"
"    {\n"
"        if (len == 0)\n"
"            return StringSlice();\n"
"\n"
"        if (id + len > getLength())\n"
"            len = getLength() - id;\n"
"#if _DEBUG\n"
"        if (id < 0 || id >= getLength() || (id + len) > getLength())\n"
"            SLANG_ASSERT_FAILURE(\"SubString: index out of range.\");\n"
"        if (len < 0)\n"
"            SLANG_ASSERT_FAILURE(\"SubString: length less than zero.\");\n"
"#endif\n"
"        return StringSlice(m_buffer, id, id + len);\n"
"    }\n"
"\n"
"    char const* getBuffer() const { return getData(); }\n"
"\n"
"    OSString toWString(Index* len = 0) const;\n"
"\n"
"    bool equals(const String& str, bool caseSensitive = true)\n"
"    {\n"
"        if (caseSensitive)\n"
"            return (strcmp(begin(), str.begin()) == 0);\n"
"        else\n"
"        {\n"
"#ifdef _MSC_VER\n"
"            return (_stricmp(begin(), str.begin()) == 0);\n"
"#else\n"
"            return (strcasecmp(begin(), str.begin()) == 0);\n"
"#endif\n"
"        }\n"
"    }\n"
"    bool operator==(const char* strbuffer) const { return (strcmp(begin(), strbuffer) == 0); }\n"
"\n"
"    bool operator==(const String& str) const { return (strcmp(begin(), str.begin()) == 0); }\n"
"    bool operator!=(const char* strbuffer) const { return (strcmp(begin(), strbuffer) != 0); }\n"
"    bool operator!=(const String& str) const { return (strcmp(begin(), str.begin()) != 0); }\n"
"    bool operator>(const String& str) const { return (strcmp(begin(), str.begin()) > 0); }\n"
"    bool operator<(const String& str) const { return (strcmp(begin(), str.begin()) < 0); }\n"
"    bool operator>=(const String& str) const { return (strcmp(begin(), str.begin()) >= 0); }\n"
"    bool operator<=(const String& str) const { return (strcmp(begin(), str.begin()) <= 0); }\n"
"\n"
"    SLANG_FORCE_INLINE bool operator==(const UnownedStringSlice& slice) const\n"
"    {\n"
"        return getUnownedSlice() == slice;\n"
"    }\n"
"    SLANG_FORCE_INLINE bool operator!=(const UnownedStringSlice& slice) const\n"
"    {\n"
"        return getUnownedSlice() != slice;\n"
"    }\n"
"\n"
"    String toUpper() const\n"
"    {\n"
"        String result;\n"
"        for (auto c : *this)\n"
"        {\n"
"            char d = (c >= 'a' && c <= 'z') ? (c - ('a' - 'A')) : c;\n"
"            result.append(d);\n"
"        }\n"
"        return result;\n"
"    }\n"
"\n"
"    String toLower() const\n"
"    {\n"
"        String result;\n"
"        for (auto c : *this)\n"
"        {\n"
"            char d = (c >= 'A' && c <= 'Z') ? (c - ('A' - 'a')) : c;\n"
"            result.append(d);\n"
"        }\n"
"        return result;\n"
"    }\n"
"\n"
"    Index indexOf(const char* str, Index id) const // String str\n"
"    {\n"
"        if (id >= getLength())\n"
"            return Index(-1);\n"
"        auto findRs = strstr(begin() + id, str);\n"
"        Index res = findRs ? findRs - begin() : Index(-1);\n"
"        return res;\n"
"    }\n"
"\n"
"    Index indexOf(const String& str, Index id) const { return indexOf(str.begin(), id); }\n"
"\n"
"    Index indexOf(const char* str) const { return indexOf(str, 0); }\n"
"\n"
"    Index indexOf(const String& str) const { return indexOf(str.begin(), 0); }\n"
"\n"
"    void swapWith(String& other) { m_buffer.swapWith(other.m_buffer); }\n"
"\n"
"    Index indexOf(char ch, Index id) const\n"
"    {\n"
"        const Index length = getLength();\n"
"        SLANG_ASSERT(id >= 0 && id <= length);\n"
"\n"
"        if (!m_buffer)\n"
"            return Index(-1);\n"
"\n"
"        const char* data = getData();\n"
"        for (Index i = id; i < length; i++)\n"
"            if (data[i] == ch)\n"
"                return i;\n"
"        return Index(-1);\n"
"    }\n"
"\n"
"    Index indexOf(char ch) const { return indexOf(ch, 0); }\n"
"\n"
"    Index lastIndexOf(char ch) const\n"
"    {\n"
"        const Index length = getLength();\n"
"        const char* data = getData();\n"
"\n"
"        for (Index i = length - 1; i >= 0; --i)\n"
"            if (data[i] == ch)\n"
"                return i;\n"
"        return Index(-1);\n"
"    }\n"
"\n"
"    bool startsWith(const char* str) const\n"
"    {\n"
"        if (!m_buffer)\n"
"            return false;\n"
"        Index strLen = Index(::strlen(str));\n"
"        if (strLen > getLength())\n"
"            return false;\n"
"\n"
"        const char* const data = getData();\n"
"\n"
"        for (Index i = 0; i < strLen; i++)\n"
"            if (str[i] != data[i])\n"
"                return false;\n"
"        return true;\n"
"    }\n"
"\n"
"    bool startsWith(const String& str) const { return startsWith(str.begin()); }\n"
"\n"
"    bool endsWith(char const* str) const // String str\n"
"    {\n"
"        if (!m_buffer)\n"
"            return false;\n"
"\n"
"        const Index strLen = Index(::strlen(str));\n"
"        const Index len = getLength();\n"
"\n"
"        if (strLen > len)\n"
"            return false;\n"
"        const char* data = getData();\n"
"        for (Index i = strLen; i > 0; i--)\n"
"            if (str[i - 1] != data[len - strLen + i - 1])\n"
"                return false;\n"
"        return true;\n"
"    }\n"
"\n"
"    bool endsWith(const String& str) const { return endsWith(str.begin()); }\n"
"\n"
"    bool contains(const char* str) const // String str\n"
"    {\n"
"        return m_buffer && indexOf(str) != Index(-1);\n"
"    }\n"
"\n"
"    bool contains(const String& str) const { return contains(str.begin()); }\n"
"\n"
"    static constexpr bool kHasUniformHash = true;\n"
"    HashCode64 getHashCode() const\n"
"    {\n"
"        return Slang::getHashCode(StringRepresentation::asSlice(m_buffer));\n"
"    }\n"
"\n"
"    UnownedStringSlice getUnownedSlice() const { return StringRepresentation::asSlice(m_buffer); }\n"
"};\n"
"\n"
"class ImmutableHashedString\n"
"{\n"
"public:\n"
"    String slice;\n"
"    HashCode64 hashCode;\n"
"    ImmutableHashedString()\n"
"        : hashCode(0)\n"
"    {\n"
"    }\n"
"    ImmutableHashedString(const UnownedStringSlice& slice)\n"
"        : slice(slice), hashCode(slice.getHashCode())\n"
"    {\n"
"    }\n"
"    ImmutableHashedString(const char* begin, const char* end)\n"
"        : slice(begin, end), hashCode(slice.getHashCode())\n"
"    {\n"
"    }\n"
"    ImmutableHashedString(const char* begin, size_t len)\n"
"        : slice(UnownedStringSlice(begin, len)), hashCode(slice.getHashCode())\n"
"    {\n"
"    }\n"
"    ImmutableHashedString(const char* begin)\n"
"        : slice(begin), hashCode(slice.getHashCode())\n"
"    {\n"
"    }\n"
"    ImmutableHashedString(const String& str)\n"
"        : slice(str), hashCode(str.getHashCode())\n"
"    {\n"
"    }\n"
"    ImmutableHashedString(String&& str)\n"
"        : slice(_Move(str)), hashCode(str.getHashCode())\n"
"    {\n"
"    }\n"
"    ImmutableHashedString(const ImmutableHashedString& other) = default;\n"
"    ImmutableHashedString& operator=(const ImmutableHashedString& other) = default;\n"
"    bool operator==(const ImmutableHashedString& other) const\n"
"    {\n"
"        return hashCode == other.hashCode && slice == other.slice;\n"
"    }\n"
"    bool operator!=(const ImmutableHashedString& other) const\n"
"    {\n"
"        return hashCode != other.hashCode || slice != other.slice;\n"
"    }\n"
"    bool operator==(const UnownedStringSlice& other) const { return slice == other; }\n"
"    bool operator!=(const UnownedStringSlice& other) const { return slice != other; }\n"
"    bool operator==(const String& other) const { return slice == other.getUnownedSlice(); }\n"
"    bool operator!=(const String& other) const { return slice != other.getUnownedSlice(); }\n"
"    bool operator==(const char* other) const { return slice == UnownedStringSlice(other); }\n"
"    HashCode64 getHashCode() const { return hashCode; }\n"
"};\n"
"\n"
"class SLANG_RT_API StringBuilder : public String\n"
"{\n"
"private:\n"
"    enum\n"
"    {\n"
"        InitialSize = 1024\n"
"    };\n"
"\n"
"public:\n"
"    typedef String Super;\n"
"    using Super::append;\n"
"\n"
"    explicit StringBuilder(UInt bufferSize = InitialSize)\n"
"    {\n"
"        ensureUniqueStorageWithCapacity(bufferSize);\n"
"    }\n"
"\n"
"    void ensureCapacity(UInt size) { ensureUniqueStorageWithCapacity(size); }\n"
"    StringBuilder& operator<<(char ch)\n"
"    {\n"
"        appendChar(ch);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(Int32 val)\n"
"    {\n"
"        append(val);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(UInt32 val)\n"
"    {\n"
"        append(val);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(Int64 val)\n"
"    {\n"
"        append(val);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(UInt64 val)\n"
"    {\n"
"        append(val);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(float val)\n"
"    {\n"
"        append(val);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(double val)\n"
"    {\n"
"        append(val);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(const char* str)\n"
"    {\n"
"        append(str, strlen(str));\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(const String& str)\n"
"    {\n"
"        append(str);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(UnownedStringSlice const& str)\n"
"    {\n"
"        append(str);\n"
"        return *this;\n"
"    }\n"
"    StringBuilder& operator<<(const _EndLine)\n"
"    {\n"
"        appendChar('\\n');\n"
"        return *this;\n"
"    }\n"
"\n"
"    String toString() { return *this; }\n"
"\n"
"    String produceString() { return *this; }\n"
"\n"
"#if 0\n"
"        void Remove(int id, int len)\n"
"        {\n"
"#if _DEBUG\n"
"            if (id >= length || id < 0)\n"
"                SLANG_ASSERT_FAILURE(\"Remove: Index out of range.\");\n"
"            if (len < 0)\n"
"                SLANG_ASSERT_FAILURE(\"Remove: remove length smaller than zero.\");\n"
"#endif\n"
"            int actualDelLength = ((id + len) >= length) ? (length - id) : len;\n"
"            for (int i = id + actualDelLength; i <= length; i++)\n"
"                buffer[i - actualDelLength] = buffer[i];\n"
"            length -= actualDelLength;\n"
"        }\n"
"#endif\n"
"    friend std::ostream& operator<<(std::ostream& stream, const String& s);\n"
"\n"
"    void clear() { m_buffer.setNull(); }\n"
"};\n"
"\n"
"int stringToInt(const String& str, int radix = 10);\n"
"unsigned int stringToUInt(const String& str, int radix = 10);\n"
"double stringToDouble(const String& str);\n"
"float stringToFloat(const String& str);\n"
"} // namespace Slang\n"
"\n"
"std::ostream& operator<<(std::ostream& stream, const Slang::String& s);\n"
"\n"
"#endif\n"
"\n"
"\n"
"#if defined(_MSC_VER)\n"
"#define SLANG_PRELUDE_SHARED_LIB_EXPORT __declspec(dllexport)\n"
"#else\n"
"#define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__((__visibility__(\"default\")))\n"
"// #   define SLANG_PRELUDE_SHARED_LIB_EXPORT __attribute__ ((dllexport))\n"
"// __attribute__((__visibility__(\"default\")))\n"
"#endif\n"
"\n"
"#ifdef __cplusplus\n"
"#define SLANG_PRELUDE_EXTERN_C extern \"C\"\n"
"#define SLANG_PRELUDE_EXTERN_C_START \\\n"
"    extern \"C\"                       \\\n"
"    {\n"
"#define SLANG_PRELUDE_EXTERN_C_END }\n"
"#else\n"
"#define SLANG_PRELUDE_EXTERN_C\n"
"#define SLANG_PRELUDE_EXTERN_C_START\n"
"#define SLANG_PRELUDE_EXTERN_C_END\n"
"#endif\n"
"\n"
"#define SLANG_PRELUDE_NAMESPACE\n"
"\n"
"#ifndef SLANG_NO_THROW\n"
"#define SLANG_NO_THROW\n"
"#endif\n"
"#ifndef SLANG_STDCALL\n"
"#define SLANG_STDCALL\n"
"#endif\n"
"#ifndef SLANG_MCALL\n"
"#define SLANG_MCALL SLANG_STDCALL\n"
"#endif\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"#ifndef SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"#define SLANG_PRELUDE_SCALAR_INTRINSICS_H\n"
"\n"
"#if !defined(SLANG_LLVM) && SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"//  If we have visual studio and 64 bit processor, we can assume we have popcnt, and can include\n"
"//  x86 intrinsics\n"
"#include <intrin.h>\n"
"#endif\n"
"\n"
"#ifndef SLANG_FORCE_INLINE\n"
"#define SLANG_FORCE_INLINE inline\n"
"#endif\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"namespace SLANG_PRELUDE_NAMESPACE\n"
"{\n"
"#endif\n"
"\n"
"#ifndef SLANG_PRELUDE_PI\n"
"#define SLANG_PRELUDE_PI 3.14159265358979323846\n"
"#endif\n"
"\n"
"\n"
"union Union32\n"
"{\n"
"    uint32_t u;\n"
"    int32_t i;\n"
"    float f;\n"
"};\n"
"\n"
"union Union64\n"
"{\n"
"    uint64_t u;\n"
"    int64_t i;\n"
"    double d;\n"
"};\n"
"\n"
"// 32 bit cast conversions\n"
"SLANG_FORCE_INLINE int32_t _bitCastFloatToInt(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.i;\n"
"}\n"
"SLANG_FORCE_INLINE float _bitCastIntToFloat(int32_t i)\n"
"{\n"
"    Union32 u;\n"
"    u.i = i;\n"
"    return u.f;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t _bitCastFloatToUInt(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.u;\n"
"}\n"
"SLANG_FORCE_INLINE float _bitCastUIntToFloat(uint32_t ui)\n"
"{\n"
"    Union32 u;\n"
"    u.u = ui;\n"
"    return u.f;\n"
"}\n"
"\n"
"// ----------------------------- F16 -----------------------------------------\n"
"\n"
"\n"
"// This impl is based on FloatToHalf that is in Slang codebase\n"
"SLANG_FORCE_INLINE uint32_t f32tof16(const float value)\n"
"{\n"
"    const uint32_t inBits = _bitCastFloatToUInt(value);\n"
"\n"
"    // bits initially set to just the sign bit\n"
"    uint32_t bits = (inBits >> 16) & 0x8000;\n"
"    // Mantissa can't be used as is, as it holds last bit, for rounding.\n"
"    uint32_t m = (inBits >> 12) & 0x07ff;\n"
"    uint32_t e = (inBits >> 23) & 0xff;\n"
"\n"
"    if (e < 103)\n"
"    {\n"
"        // It's zero\n"
"        return bits;\n"
"    }\n"
"    if (e == 0xff)\n"
"    {\n"
"        // Could be a NAN or INF. Is INF if *input* mantissa is 0.\n"
"\n"
"        // Remove last bit for rounding to make output mantissa.\n"
"        m >>= 1;\n"
"\n"
"        // We *assume* float16/float32 signaling bit and remaining bits\n"
"        // semantics are the same. (The signalling bit convention is target specific!).\n"
"        // Non signal bit's usage within mantissa for a NAN are also target specific.\n"
"\n"
"        // If the m is 0, it could be because the result is INF, but it could also be because all\n"
"        // the bits that made NAN were dropped as we have less mantissa bits in f16.\n"
"\n"
"        // To fix for this we make non zero if m is 0 and the input mantissa was not.\n"
"        // This will (typically) produce a signalling NAN.\n"
"        m += uint32_t(m == 0 && (inBits & 0x007fffffu));\n"
"\n"
"        // Combine for output\n"
"        return (bits | 0x7c00u | m);\n"
"    }\n"
"    if (e > 142)\n"
"    {\n"
"        // INF.\n"
"        return bits | 0x7c00u;\n"
"    }\n"
"    if (e < 113)\n"
"    {\n"
"        m |= 0x0800u;\n"
"        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n"
"        return bits;\n"
"    }\n"
"    bits |= ((e - 112) << 10) | (m >> 1);\n"
"    bits += m & 1;\n"
"    return bits;\n"
"}\n"
"\n"
"static const float g_f16tof32Magic = _bitCastIntToFloat((127 + (127 - 15)) << 23);\n"
"\n"
"SLANG_FORCE_INLINE float f16tof32(const uint32_t value)\n"
"{\n"
"    const uint32_t sign = (value & 0x8000) << 16;\n"
"    uint32_t exponent = (value & 0x7c00) >> 10;\n"
"    uint32_t mantissa = (value & 0x03ff);\n"
"\n"
"    if (exponent == 0)\n"
"    {\n"
;
sb << 
"        // If mantissa is 0 we are done, as output is 0.\n"
"        // If it's not zero we must have a denormal.\n"
"        if (mantissa)\n"
"        {\n"
"            // We have a denormal so use the magic to do exponent adjust\n"
"            return _bitCastIntToFloat(sign | ((value & 0x7fff) << 13)) * g_f16tof32Magic;\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        // If the exponent is NAN or INF exponent is 0x1f on input.\n"
"        // If that's the case, we just need to set the exponent to 0xff on output\n"
"        // and the mantissa can just stay the same. If its 0 it's INF, else it is NAN and we just\n"
"        // copy the bits\n"
"        //\n"
"        // Else we need to correct the exponent in the normalized case.\n"
"        exponent = (exponent == 0x1F) ? 0xff : (exponent + (-15 + 127));\n"
"    }\n"
"\n"
"    return _bitCastUIntToFloat(sign | (exponent << 23) | (mantissa << 13));\n"
"}\n"
"\n"
"// ----------------------------- F32 -----------------------------------------\n"
"\n"
"// Helpers\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary\n"
"float F32_ceil(float f);\n"
"float F32_floor(float f);\n"
"float F32_round(float f);\n"
"float F32_sin(float f);\n"
"float F32_cos(float f);\n"
"float F32_tan(float f);\n"
"float F32_asin(float f);\n"
"float F32_acos(float f);\n"
"float F32_atan(float f);\n"
"float F32_sinh(float f);\n"
"float F32_cosh(float f);\n"
"float F32_tanh(float f);\n"
"float F32_log2(float f);\n"
"float F32_log(float f);\n"
"float F32_log10(float f);\n"
"float F32_exp2(float f);\n"
"float F32_exp(float f);\n"
"float F32_abs(float f);\n"
"float F32_trunc(float f);\n"
"float F32_sqrt(float f);\n"
"\n"
"bool F32_isnan(float f);\n"
"bool F32_isfinite(float f);\n"
"bool F32_isinf(float f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"float F32_pow(float a, float b);\n"
"float F32_fmod(float a, float b);\n"
"float F32_remainder(float a, float b);\n"
"float F32_atan2(float a, float b);\n"
"\n"
"float F32_frexp(float x, int* e);\n"
"\n"
"float F32_modf(float x, float* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c)\n"
"{\n"
"    return a * b + c;\n"
"}\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else\n"
"\n"
"// Unary\n"
"SLANG_FORCE_INLINE float F32_ceil(float f)\n"
"{\n"
"    return ::ceilf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_floor(float f)\n"
"{\n"
"    return ::floorf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_round(float f)\n"
"{\n"
"    return ::roundf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sin(float f)\n"
"{\n"
"    return ::sinf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_cos(float f)\n"
"{\n"
"    return ::cosf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_tan(float f)\n"
"{\n"
"    return ::tanf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_asin(float f)\n"
"{\n"
"    return ::asinf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_acos(float f)\n"
"{\n"
"    return ::acosf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_atan(float f)\n"
"{\n"
"    return ::atanf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sinh(float f)\n"
"{\n"
"    return ::sinhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_cosh(float f)\n"
"{\n"
"    return ::coshf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_tanh(float f)\n"
"{\n"
"    return ::tanhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_asinh(float f)\n"
"{\n"
"    return ::asinhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_acosh(float f)\n"
"{\n"
"    return ::acoshf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_atanh(float f)\n"
"{\n"
"    return ::atanhf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_log2(float f)\n"
"{\n"
"    return ::log2f(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_log(float f)\n"
"{\n"
"    return ::logf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_log10(float f)\n"
"{\n"
"    return ::log10f(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_exp2(float f)\n"
"{\n"
"    return ::exp2f(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_exp(float f)\n"
"{\n"
"    return ::expf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_abs(float f)\n"
"{\n"
"    return ::fabsf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_trunc(float f)\n"
"{\n"
"    return ::truncf(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sqrt(float f)\n"
"{\n"
"    return ::sqrtf(f);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE bool F32_isnan(float f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isnan(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F32_isfinite(float f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isfinite(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F32_isinf(float f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isinf(f);\n"
"}\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE float F32_min(float a, float b)\n"
"{\n"
"    return ::fminf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_max(float a, float b)\n"
"{\n"
"    return ::fmaxf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_pow(float a, float b)\n"
"{\n"
"    return ::powf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_fmod(float a, float b)\n"
"{\n"
"    return ::fmodf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_remainder(float a, float b)\n"
"{\n"
"    return ::remainderf(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_atan2(float a, float b)\n"
"{\n"
"    return float(::atan2(a, b));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_frexp(float x, int* e)\n"
"{\n"
"    return ::frexpf(x, e);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_modf(float x, float* ip)\n"
"{\n"
"    return ::modff(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE float F32_fma(float a, float b, float c)\n"
"{\n"
"    return ::fmaf(a, b, c);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"SLANG_FORCE_INLINE float F32_calcSafeRadians(float radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1\n"
"    float a = radians * (1.0f / float(SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F32_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"    return (a * float(SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float F32_rsqrt(float f)\n"
"{\n"
"    return 1.0f / F32_sqrt(f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_sign(float f)\n"
"{\n"
"    return (f == 0.0f) ? f : ((f < 0.0f) ? -1.0f : 1.0f);\n"
"}\n"
"SLANG_FORCE_INLINE float F32_frac(float f)\n"
"{\n"
"    return f - F32_floor(f);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t F32_asuint(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.u;\n"
"}\n"
"SLANG_FORCE_INLINE int32_t F32_asint(float f)\n"
"{\n"
"    Union32 u;\n"
"    u.f = f;\n"
"    return u.i;\n"
"}\n"
"\n"
"// ----------------------------- F64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians);\n"
"\n"
"#ifdef SLANG_LLVM\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_START\n"
"\n"
"// Unary\n"
"double F64_ceil(double f);\n"
"double F64_floor(double f);\n"
"double F64_round(double f);\n"
"double F64_sin(double f);\n"
"double F64_cos(double f);\n"
"double F64_tan(double f);\n"
"double F64_asin(double f);\n"
"double F64_acos(double f);\n"
"double F64_atan(double f);\n"
"double F64_sinh(double f);\n"
"double F64_cosh(double f);\n"
"double F64_tanh(double f);\n"
"double F64_log2(double f);\n"
"double F64_log(double f);\n"
"double F64_log10(double f);\n"
"double F64_exp2(double f);\n"
"double F64_exp(double f);\n"
"double F64_abs(double f);\n"
"double F64_trunc(double f);\n"
"double F64_sqrt(double f);\n"
"\n"
"bool F64_isnan(double f);\n"
"bool F64_isfinite(double f);\n"
"bool F64_isinf(double f);\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"double F64_pow(double a, double b);\n"
"double F64_fmod(double a, double b);\n"
"double F64_remainder(double a, double b);\n"
"double F64_atan2(double a, double b);\n"
"\n"
"double F64_frexp(double x, int* e);\n"
"\n"
"double F64_modf(double x, double* ip);\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c)\n"
"{\n"
"    return a * b + c;\n"
"}\n"
"\n"
"SLANG_PRELUDE_EXTERN_C_END\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"// Unary\n"
"SLANG_FORCE_INLINE double F64_ceil(double f)\n"
"{\n"
"    return ::ceil(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_floor(double f)\n"
"{\n"
"    return ::floor(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_round(double f)\n"
"{\n"
"    return ::round(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sin(double f)\n"
"{\n"
"    return ::sin(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_cos(double f)\n"
"{\n"
"    return ::cos(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_tan(double f)\n"
"{\n"
"    return ::tan(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_asin(double f)\n"
"{\n"
"    return ::asin(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_acos(double f)\n"
"{\n"
"    return ::acos(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_atan(double f)\n"
"{\n"
"    return ::atan(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sinh(double f)\n"
"{\n"
"    return ::sinh(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_cosh(double f)\n"
"{\n"
"    return ::cosh(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_tanh(double f)\n"
"{\n"
"    return ::tanh(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_log2(double f)\n"
"{\n"
"    return ::log2(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_log(double f)\n"
"{\n"
"    return ::log(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_log10(float f)\n"
"{\n"
"    return ::log10(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_exp2(double f)\n"
"{\n"
"    return ::exp2(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_exp(double f)\n"
"{\n"
"    return ::exp(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_abs(double f)\n"
"{\n"
"    return ::fabs(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_trunc(double f)\n"
"{\n"
"    return ::trunc(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sqrt(double f)\n"
"{\n"
"    return ::sqrt(f);\n"
"}\n"
"\n"
"\n"
"SLANG_FORCE_INLINE bool F64_isnan(double f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isnan(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F64_isfinite(double f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isfinite(f);\n"
"}\n"
"SLANG_FORCE_INLINE bool F64_isinf(double f)\n"
"{\n"
"    return SLANG_PRELUDE_STD isinf(f);\n"
"}\n"
"\n"
"// Binary\n"
"SLANG_FORCE_INLINE double F64_min(double a, double b)\n"
"{\n"
"    return ::fmin(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_max(double a, double b)\n"
"{\n"
"    return ::fmax(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_pow(double a, double b)\n"
"{\n"
"    return ::pow(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_fmod(double a, double b)\n"
"{\n"
"    return ::fmod(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_remainder(double a, double b)\n"
"{\n"
"    return ::remainder(a, b);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_atan2(double a, double b)\n"
"{\n"
"    return ::atan2(a, b);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_frexp(double x, int* e)\n"
"{\n"
"    return ::frexp(x, e);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_modf(double x, double* ip)\n"
"{\n"
"    return ::modf(x, ip);\n"
"}\n"
"\n"
"// Ternary\n"
"SLANG_FORCE_INLINE double F64_fma(double a, double b, double c)\n"
"{\n"
"    return ::fma(a, b, c);\n"
"}\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"SLANG_FORCE_INLINE double F64_rsqrt(double f)\n"
"{\n"
"    return 1.0 / F64_sqrt(f);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_sign(double f)\n"
"{\n"
"    return (f == 0.0) ? f : ((f < 0.0) ? -1.0 : 1.0);\n"
"}\n"
"SLANG_FORCE_INLINE double F64_frac(double f)\n"
"{\n"
"    return f - F64_floor(f);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void F64_asuint(double d, uint32_t* low, uint32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = uint32_t(u.u);\n"
"    *hi = uint32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE void F64_asint(double d, int32_t* low, int32_t* hi)\n"
"{\n"
"    Union64 u;\n"
"    u.d = d;\n"
"    *low = int32_t(u.u);\n"
"    *hi = int32_t(u.u >> 32);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double F64_calcSafeRadians(double radians)\n"
"{\n"
"    // Put 0 to 2pi cycles to cycle around 0 to 1\n"
"    double a = radians * (1.0f / (SLANG_PRELUDE_PI * 2));\n"
"    // Get truncated fraction, as value in  0 - 1 range\n"
"    a = a - F64_floor(a);\n"
"    // Convert back to 0 - 2pi range\n"
"    return (a * (SLANG_PRELUDE_PI * 2));\n"
"}\n"
"\n"
"// ----------------------------- U16 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t U16_countbits(uint16_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return __builtin_popcount(uint32_t(v));\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return __popcnt16(v);\n"
"#else\n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I16 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t I16_countbits(int16_t v)\n"
"{\n"
"    return U16_countbits(uint16_t(v));\n"
"}\n"
"\n"
"// ----------------------------- U8 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t U8_countbits(uint8_t v)\n"
"{\n"
"    // No native 8bit __popcnt yet, just cast and use 16bit variant\n"
"    return U16_countbits(uint16_t(v));\n"
"}\n"
"\n"
"// ----------------------------- I8 -----------------------------------------\n"
"SLANG_FORCE_INLINE uint32_t I8_countbits(int16_t v)\n"
"{\n"
"    return U8_countbits(uint8_t(v));\n"
"}\n"
"\n"
"// ----------------------------- U32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_abs(uint32_t f)\n"
"{\n"
"    return f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_min(uint32_t a, uint32_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t U32_max(uint32_t a, uint32_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float U32_asfloat(uint32_t x)\n"
"{\n"
"    Union32 u;\n"
"    u.u = x;\n"
"    return u.f;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t U32_asint(int32_t x)\n"
"{\n"
"    return uint32_t(x);\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE double U32_asdouble(uint32_t low, uint32_t hi)\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | low;\n"
"    return u.d;\n"
"}\n"
"\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_countbits(uint32_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return __builtin_popcount(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return __popcnt(v);\n"
"#else\n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_firstbitlow(uint32_t v)\n"
"{\n"
"    if (v == 0)\n"
"        return ~0u;\n"
"\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    // __builtin_ctz returns number of trailing zeros, which is the 0-based index of first set bit\n"
"    return __builtin_ctz(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    // _BitScanForward returns 1 on success, 0 on failure, and sets index\n"
"    unsigned long index;\n"
"    return _BitScanForward(&index, v) ? index : ~0u;\n"
"#else\n"
"    // Generic implementation - find first set bit\n"
"    uint32_t result = 0;\n"
"    while (result < 32 && !(v & (1u << result)))\n"
"        result++;\n"
"    return result;\n"
"#endif\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U32_firstbithigh(uint32_t v)\n"
"{\n"
"    if ((int32_t)v < 0)\n"
"        v = ~v;\n"
"    if (v == 0)\n"
"        return ~0u;\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    // __builtin_clz returns number of leading zeros\n"
"    // firstbithigh should return 0-based bit position of MSB\n"
"    return 31 - __builtin_clz(v);\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    // _BitScanReverse returns 1 on success, 0 on failure, and sets index\n"
"    unsigned long index;\n"
"    return _BitScanReverse(&index, v) ? index : ~0u;\n"
"#else\n"
"    // Generic implementation - find highest set bit\n"
"    int result = 31;\n"
"    while (result >= 0 && !(v & (1u << result)))\n"
"        result--;\n"
"    return result;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I32 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_abs(int32_t f)\n"
"{\n"
"    return (f < 0) ? -f : f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE int32_t I32_min(int32_t a, int32_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE int32_t I32_max(int32_t a, int32_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE float I32_asfloat(int32_t x)\n"
"{\n"
"    Union32 u;\n"
"    u.i = x;\n"
"    return u.f;\n"
"}\n"
"SLANG_FORCE_INLINE uint32_t I32_asuint(int32_t x)\n"
"{\n"
"    return uint32_t(x);\n"
"}\n"
"SLANG_FORCE_INLINE double I32_asdouble(int32_t low, int32_t hi)\n"
"{\n"
"    Union64 u;\n"
"    u.u = (uint64_t(hi) << 32) | uint32_t(low);\n"
"    return u.d;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I32_countbits(int32_t v)\n"
"{\n"
"    return U32_countbits(uint32_t(v));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I32_firstbitlow(int32_t v)\n"
"{\n"
"    return U32_firstbitlow(uint32_t(v));\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I32_firstbithigh(int32_t v)\n"
"{\n"
"    return U32_firstbithigh(uint32_t(v));\n"
"}\n"
"\n"
"// ----------------------------- U64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_abs(uint64_t f)\n"
"{\n"
"    return f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint64_t U64_min(uint64_t a, uint64_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE uint64_t U64_max(uint64_t a, uint64_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t U64_countbits(uint64_t v)\n"
"{\n"
"#if SLANG_GCC_FAMILY && !defined(SLANG_LLVM)\n"
"    return uint32_t(__builtin_popcountll(v));\n"
"#elif SLANG_PROCESSOR_X86_64 && SLANG_VC\n"
"    return uint32_t(__popcnt64(v));\n"
"#else\n"
"    uint32_t c = 0;\n"
"    while (v)\n"
"    {\n"
"        c++;\n"
"        v &= v - 1;\n"
"    }\n"
"    return c;\n"
"#endif\n"
"}\n"
"\n"
"// ----------------------------- I64 -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_abs(int64_t f)\n"
"{\n"
"    return (f < 0) ? -f : f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE int64_t I64_min(int64_t a, int64_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"SLANG_FORCE_INLINE int64_t I64_max(int64_t a, int64_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uint32_t I64_countbits(int64_t v)\n"
"{\n"
"    return U64_countbits(uint64_t(v));\n"
"}\n"
"\n"
"// ----------------------------- UPTR -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE uintptr_t UPTR_abs(uintptr_t f)\n"
"{\n"
"    return f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uintptr_t UPTR_min(uintptr_t a, uintptr_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE uintptr_t UPTR_max(uintptr_t a, uintptr_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"// ----------------------------- IPTR -----------------------------------------\n"
"\n"
"SLANG_FORCE_INLINE intptr_t IPTR_abs(intptr_t f)\n"
"{\n"
"    return (f < 0) ? -f : f;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE intptr_t IPTR_min(intptr_t a, intptr_t b)\n"
"{\n"
"    return a < b ? a : b;\n"
"}\n"
"\n"
"SLANG_FORCE_INLINE intptr_t IPTR_max(intptr_t a, intptr_t b)\n"
"{\n"
"    return a > b ? a : b;\n"
"}\n"
"\n"
"// ----------------------------- Interlocked ---------------------------------\n"
"\n"
"#if SLANG_LLVM\n"
"\n"
"#else // SLANG_LLVM\n"
"\n"
"#ifdef _WIN32\n"
"#include <intrin.h>\n"
"#endif\n"
"\n"
"SLANG_FORCE_INLINE void InterlockedAdd(uint32_t* dest, uint32_t value, uint32_t* oldValue)\n"
"{\n"
"#ifdef _WIN32\n"
"    *oldValue = _InterlockedExchangeAdd((long*)dest, (long)value);\n"
"#else\n"
"    *oldValue = __sync_fetch_and_add(dest, value);\n"
"#endif\n"
"}\n"
"\n"
"#endif // SLANG_LLVM\n"
"\n"
"\n"
"// ----------------------- fmod --------------------------\n"
"SLANG_FORCE_INLINE float _slang_fmod(float x, float y)\n"
"{\n"
"    return F32_fmod(x, y);\n"
"}\n"
"SLANG_FORCE_INLINE double _slang_fmod(double x, double y)\n"
"{\n"
"    return F64_fmod(x, y);\n"
"}\n"
"\n"
"#ifdef SLANG_PRELUDE_NAMESPACE\n"
"}\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
;
sb << 
"#ifndef SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"#define SLANG_PRELUDE_CPP_TYPES_CORE_H\n"
"\n"
"#ifndef SLANG_PRELUDE_ASSERT\n"
"#ifdef SLANG_PRELUDE_ENABLE_ASSERT\n"
"#define SLANG_PRELUDE_ASSERT(VALUE) assert(VALUE)\n"
"#else\n"
"#define SLANG_PRELUDE_ASSERT(VALUE)\n"
"#endif\n"
"#endif\n"
"\n"
"// Since we are using unsigned arithmatic care is need in this comparison.\n"
"// It is *assumed* that sizeInBytes >= elemSize. Which means (sizeInBytes >= elemSize) >= 0\n"
"// Which means only a single test is needed\n"
"\n"
"// Asserts for bounds checking.\n"
"// It is assumed index/count are unsigned types.\n"
"#define SLANG_BOUND_ASSERT(index, count) SLANG_PRELUDE_ASSERT(index < count);\n"
"#define SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    SLANG_PRELUDE_ASSERT(index <= (sizeInBytes - elemSize) && (index & 3) == 0);\n"
"\n"
"// Macros to zero index if an access is out of range\n"
"#define SLANG_BOUND_ZERO_INDEX(index, count) index = (index < count) ? index : 0;\n"
"#define SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    index = (index <= (sizeInBytes - elemSize)) ? index : 0;\n"
"\n"
"// The 'FIX' macro define how the index is fixed. The default is to do nothing. If\n"
"// SLANG_ENABLE_BOUND_ZERO_INDEX the fix macro will zero the index, if out of range\n"
"#ifdef SLANG_ENABLE_BOUND_ZERO_INDEX\n"
"#define SLANG_BOUND_FIX(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    SLANG_BOUND_ZERO_INDEX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#define SLANG_BOUND_FIX_FIXED_ARRAY(index, count) SLANG_BOUND_ZERO_INDEX(index, count)\n"
"#else\n"
"#define SLANG_BOUND_FIX(index, count)\n"
"#define SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#define SLANG_BOUND_FIX_FIXED_ARRAY(index, count)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK\n"
"#define SLANG_BOUND_CHECK(index, count) \\\n"
"    SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX(index, count)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_BYTE_ADDRESS\n"
"#define SLANG_BOUND_CHECK_BYTE_ADDRESS(index, elemSize, sizeInBytes) \\\n"
"    SLANG_BOUND_ASSERT_BYTE_ADDRESS(index, elemSize, sizeInBytes)    \\\n"
"    SLANG_BOUND_FIX_BYTE_ADDRESS(index, elemSize, sizeInBytes)\n"
"#endif\n"
"\n"
"#ifndef SLANG_BOUND_CHECK_FIXED_ARRAY\n"
"#define SLANG_BOUND_CHECK_FIXED_ARRAY(index, count) \\\n"
"    SLANG_BOUND_ASSERT(index, count) SLANG_BOUND_FIX_FIXED_ARRAY(index, count)\n"
"#endif\n"
"\n"
"struct TypeInfo\n"
"{\n"
"    size_t typeSize;\n"
"};\n"
"\n"
"template<typename T, size_t SIZE>\n"
"struct FixedArray\n"
"{\n"
"    const T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE);\n"
"        return m_data[index];\n"
"    }\n"
"    T& operator[](size_t index)\n"
"    {\n"
"        SLANG_BOUND_CHECK_FIXED_ARRAY(index, SIZE);\n"
"        return m_data[index];\n"
"    }\n"
"\n"
"    T m_data[SIZE];\n"
"};\n"
"\n"
"// An array that has no specified size, becomes a 'Array'. This stores the size so it can\n"
"// potentially do bounds checking.\n"
"template<typename T>\n"
"struct Array\n"
"{\n"
"    const T& operator[](size_t index) const\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"    T& operator[](size_t index)\n"
"    {\n"
"        SLANG_BOUND_CHECK(index, count);\n"
"        return data[index];\n"
"    }\n"
"\n"
"    T* data;\n"
"    size_t count;\n"
"};\n"
"\n"
"/* Constant buffers become a pointer to the contained type, so ConstantBuffer<T> becomes T* in C++\n"
" * code.\n"
" */\n"
"\n"
"template<typename T, int COUNT>\n"
"struct Vector;\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 1>\n"
"{\n"
"    T x;\n"
"    const T& operator[](size_t /*index*/) const { return x; }\n"
"    T& operator[](size_t /*index*/) { return x; }\n"
"    operator T() const { return x; }\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = scalar; }\n"
"    template<typename U>\n"
"    Vector(Vector<U, 1> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 1;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 2>\n"
"{\n"
"    T x, y;\n"
"    const T& operator[](size_t index) const { return index == 0 ? x : y; }\n"
"    T& operator[](size_t index) { return index == 0 ? x : y; }\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = y = scalar; }\n"
"    Vector(T _x, T _y)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"    }\n"
"    template<typename U>\n"
"    Vector(Vector<U, 2> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 2;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 3>\n"
"{\n"
"    T x, y, z;\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = y = z = scalar; }\n"
"    Vector(T _x, T _y, T _z)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"    }\n"
"    template<typename U>\n"
"    Vector(Vector<U, 3> other)\n"
"    {\n"
"        x = (T)other.x;\n"
"        y = (T)other.y;\n"
"        z = (T)other.z;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 3;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T>\n"
"struct Vector<T, 4>\n"
"{\n"
"    T x, y, z, w;\n"
"\n"
"    const T& operator[](size_t index) const { return *((T*)(this) + index); }\n"
"    T& operator[](size_t index) { return *((T*)(this) + index); }\n"
"    Vector() = default;\n"
"    Vector(T scalar) { x = y = z = w = scalar; }\n"
"    Vector(T _x, T _y, T _z, T _w)\n"
"    {\n"
"        x = _x;\n"
"        y = _y;\n"
"        z = _z;\n"
"        w = _w;\n"
"    }\n"
"    template<typename U, int otherSize>\n"
"    Vector(Vector<U, otherSize> other)\n"
"    {\n"
"        int minSize = 4;\n"
"        if (otherSize < minSize)\n"
"            minSize = otherSize;\n"
"        for (int i = 0; i < minSize; i++)\n"
"            (*this)[i] = (T)other[i];\n"
"    }\n"
"};\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE Vector<T, N> _slang_select(\n"
"    Vector<bool, N> condition,\n"
"    Vector<T, N> v0,\n"
"    Vector<T, N> v1)\n"
"{\n"
"    Vector<T, N> result;\n"
"    for (int i = 0; i < N; i++)\n"
"    {\n"
"        result[i] = condition[i] ? v0[i] : v1[i];\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"template<typename T>\n"
"SLANG_FORCE_INLINE T _slang_select(bool condition, T v0, T v1)\n"
"{\n"
"    return condition ? v0 : v1;\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T _slang_vector_get_element(Vector<T, N> x, int index)\n"
"{\n"
"    return x[index];\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE const T* _slang_vector_get_element_ptr(const Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*const_cast<Vector<T, N>*>(x))[index]);\n"
"}\n"
"\n"
"template<typename T, int N>\n"
"SLANG_FORCE_INLINE T* _slang_vector_get_element_ptr(Vector<T, N>* x, int index)\n"
"{\n"
"    return &((*x)[index]);\n"
"}\n"
"\n"
"template<typename T, int n, typename OtherT, int m>\n"
"SLANG_FORCE_INLINE Vector<T, n> _slang_vector_reshape(const Vector<OtherT, m> other)\n"
"{\n"
"    Vector<T, n> result;\n"
"    for (int i = 0; i < n; i++)\n"
"    {\n"
"        OtherT otherElement = T(0);\n"
"        if (i < m)\n"
"            otherElement = _slang_vector_get_element(other, i);\n"
"        *_slang_vector_get_element_ptr(&result, i) = (T)otherElement;\n"
"    }\n"
"    return result;\n"
"}\n"
"\n"
"typedef uint32_t uint;\n"
"\n"
"#define SLANG_VECTOR_BINARY_OP(T, op)            \\\n"
"    template<int n>                              \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op( \\\n"
"        const Vector<T, n>& thisVal,             \\\n"
"        const Vector<T, n>& other)               \\\n"
"    {                                            \\\n"
"        Vector<T, n> result;                     \\\n"
"        for (int i = 0; i < n; i++)              \\\n"
"            result[i] = thisVal[i] op other[i];  \\\n"
"        return result;                           \\\n"
"    }\n"
"#define SLANG_VECTOR_BINARY_COMPARE_OP(T, op)       \\\n"
"    template<int n>                                 \\\n"
"    SLANG_FORCE_INLINE Vector<bool, n> operator op( \\\n"
"        const Vector<T, n>& thisVal,                \\\n"
"        const Vector<T, n>& other)                  \\\n"
"    {                                               \\\n"
"        Vector<bool, n> result;                     \\\n"
"        for (int i = 0; i < n; i++)                 \\\n"
"            result[i] = thisVal[i] op other[i];     \\\n"
"        return result;                              \\\n"
"    }\n"
"\n"
"#define SLANG_VECTOR_UNARY_OP(T, op)                                         \\\n"
"    template<int n>                                                          \\\n"
"    SLANG_FORCE_INLINE Vector<T, n> operator op(const Vector<T, n>& thisVal) \\\n"
"    {                                                                        \\\n"
"        Vector<T, n> result;                                                 \\\n"
"        for (int i = 0; i < n; i++)                                          \\\n"
"            result[i] = op thisVal[i];                                       \\\n"
"        return result;                                                       \\\n"
"    }\n"
"#define SLANG_INT_VECTOR_OPS(T)           \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, /)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, &)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, |)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, &&)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, ||)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, ^)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, %)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, >>)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, <<)         \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)  \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=) \\\n"
"    SLANG_VECTOR_UNARY_OP(T, !)           \\\n"
"    SLANG_VECTOR_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_VECTOR_OPS(T)         \\\n"
"    SLANG_VECTOR_BINARY_OP(T, +)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, -)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, *)          \\\n"
"    SLANG_VECTOR_BINARY_OP(T, /)          \\\n"
"    SLANG_VECTOR_UNARY_OP(T, -)           \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >)  \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_VECTOR_BINARY_COMPARE_OP(T, !=)\n"
"\n"
"SLANG_INT_VECTOR_OPS(bool)\n"
"SLANG_INT_VECTOR_OPS(int)\n"
"SLANG_INT_VECTOR_OPS(int8_t)\n"
"SLANG_INT_VECTOR_OPS(int16_t)\n"
"SLANG_INT_VECTOR_OPS(int64_t)\n"
"SLANG_INT_VECTOR_OPS(uint)\n"
"SLANG_INT_VECTOR_OPS(uint8_t)\n"
"SLANG_INT_VECTOR_OPS(uint16_t)\n"
"SLANG_INT_VECTOR_OPS(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_INT_VECTOR_OPS(intptr_t)\n"
"SLANG_INT_VECTOR_OPS(uintptr_t)\n"
"#endif\n"
"\n"
"SLANG_FLOAT_VECTOR_OPS(float)\n"
"SLANG_FLOAT_VECTOR_OPS(double)\n"
"\n"
"#define SLANG_VECTOR_INT_NEG_OP(T)                      \\\n"
"    template<int N>                                     \\\n"
"    Vector<T, N> operator-(const Vector<T, N>& thisVal) \\\n"
"    {                                                   \\\n"
"        Vector<T, N> result;                            \\\n"
"        for (int i = 0; i < N; i++)                     \\\n"
"            result[i] = 0 - thisVal[i];                 \\\n"
"        return result;                                  \\\n"
"    }\n"
"SLANG_VECTOR_INT_NEG_OP(int)\n"
"SLANG_VECTOR_INT_NEG_OP(int8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(int64_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint)\n"
"SLANG_VECTOR_INT_NEG_OP(uint8_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint16_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_VECTOR_INT_NEG_OP(intptr_t)\n"
"SLANG_VECTOR_INT_NEG_OP(uintptr_t)\n"
"#endif\n"
"\n"
"#define SLANG_FLOAT_VECTOR_MOD(T)                                               \\\n"
"    template<int N>                                                             \\\n"
"    Vector<T, N> operator%(const Vector<T, N>& left, const Vector<T, N>& right) \\\n"
"    {                                                                           \\\n"
"        Vector<T, N> result;                                                    \\\n"
"        for (int i = 0; i < N; i++)                                             \\\n"
"            result[i] = _slang_fmod(left[i], right[i]);                         \\\n"
"        return result;                                                          \\\n"
"    }\n"
"\n"
"SLANG_FLOAT_VECTOR_MOD(float)\n"
"SLANG_FLOAT_VECTOR_MOD(double)\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"#undef SLANG_VECTOR_BINARY_OP\n"
"#undef SLANG_VECTOR_UNARY_OP\n"
"#undef SLANG_INT_VECTOR_OPS\n"
"#undef SLANG_FLOAT_VECTOR_OPS\n"
"#undef SLANG_VECTOR_INT_NEG_OP\n"
"#undef SLANG_FLOAT_VECTOR_MOD\n"
"\n"
"template<typename T, int ROWS, int COLS>\n"
"struct Matrix\n"
"{\n"
"    Vector<T, COLS> rows[ROWS];\n"
"    const Vector<T, COLS>& operator[](size_t index) const { return rows[index]; }\n"
"    Vector<T, COLS>& operator[](size_t index) { return rows[index]; }\n"
"    Matrix() = default;\n"
"    Matrix(T scalar)\n"
"    {\n"
"        for (int i = 0; i < ROWS; i++)\n"
"            rows[i] = Vector<T, COLS>(scalar);\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0) { rows[0] = row0; }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"    }\n"
"    Matrix(const Vector<T, COLS>& row0, const Vector<T, COLS>& row1, const Vector<T, COLS>& row2)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"    }\n"
"    Matrix(\n"
"        const Vector<T, COLS>& row0,\n"
"        const Vector<T, COLS>& row1,\n"
"        const Vector<T, COLS>& row2,\n"
"        const Vector<T, COLS>& row3)\n"
"    {\n"
"        rows[0] = row0;\n"
"        rows[1] = row1;\n"
"        rows[2] = row2;\n"
"        rows[3] = row3;\n"
"    }\n"
"    template<typename U, int otherRow, int otherCol>\n"
"    Matrix(const Matrix<U, otherRow, otherCol>& other)\n"
"    {\n"
"        int minRow = ROWS;\n"
"        int minCol = COLS;\n"
"        if (minRow > otherRow)\n"
"            minRow = otherRow;\n"
"        if (minCol > otherCol)\n"
"            minCol = otherCol;\n"
"        for (int i = 0; i < minRow; i++)\n"
"            for (int j = 0; j < minCol; j++)\n"
"                rows[i][j] = (T)other.rows[i][j];\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3)\n"
"    {\n"
"        rows[0][0] = v0;\n"
"        rows[0][1] = v1;\n"
"        rows[1][0] = v2;\n"
"        rows[1][1] = v3;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5)\n"
"    {\n"
"        if (COLS == 3)\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[1][0] = v3;\n"
"            rows[1][1] = v4;\n"
"            rows[1][2] = v5;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[1][0] = v2;\n"
"            rows[1][1] = v3;\n"
"            rows[2][0] = v4;\n"
"            rows[2][1] = v5;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[0][3] = v3;\n"
"            rows[1][0] = v4;\n"
"            rows[1][1] = v5;\n"
"            rows[1][2] = v6;\n"
"            rows[1][3] = v7;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[1][0] = v2;\n"
"            rows[1][1] = v3;\n"
"            rows[2][0] = v4;\n"
"            rows[2][1] = v5;\n"
"            rows[3][0] = v6;\n"
"            rows[3][1] = v7;\n"
"        }\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8)\n"
"    {\n"
"        rows[0][0] = v0;\n"
"        rows[0][1] = v1;\n"
"        rows[0][2] = v2;\n"
"        rows[1][0] = v3;\n"
"        rows[1][1] = v4;\n"
"        rows[1][2] = v5;\n"
"        rows[2][0] = v6;\n"
"        rows[2][1] = v7;\n"
"        rows[2][2] = v8;\n"
"    }\n"
"    Matrix(T v0, T v1, T v2, T v3, T v4, T v5, T v6, T v7, T v8, T v9, T v10, T v11)\n"
"    {\n"
"        if (COLS == 4)\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[0][3] = v3;\n"
"            rows[1][0] = v4;\n"
"            rows[1][1] = v5;\n"
"            rows[1][2] = v6;\n"
"            rows[1][3] = v7;\n"
"            rows[2][0] = v8;\n"
"            rows[2][1] = v9;\n"
"            rows[2][2] = v10;\n"
"            rows[2][3] = v11;\n"
"        }\n"
"        else\n"
"        {\n"
"            rows[0][0] = v0;\n"
"            rows[0][1] = v1;\n"
"            rows[0][2] = v2;\n"
"            rows[1][0] = v3;\n"
"            rows[1][1] = v4;\n"
"            rows[1][2] = v5;\n"
"            rows[2][0] = v6;\n"
"            rows[2][1] = v7;\n"
"            rows[2][2] = v8;\n"
"            rows[3][0] = v9;\n"
"            rows[3][1] = v10;\n"
"            rows[3][2] = v11;\n"
"        }\n"
"    }\n"
"    Matrix(\n"
"        T v0,\n"
"        T v1,\n"
"        T v2,\n"
"        T v3,\n"
"        T v4,\n"
"        T v5,\n"
"        T v6,\n"
"        T v7,\n"
"        T v8,\n"
"        T v9,\n"
"        T v10,\n"
"        T v11,\n"
"        T v12,\n"
"        T v13,\n"
"        T v14,\n"
"        T v15)\n"
"    {\n"
"        rows[0][0] = v0;\n"
"        rows[0][1] = v1;\n"
"        rows[0][2] = v2;\n"
"        rows[0][3] = v3;\n"
"        rows[1][0] = v4;\n"
"        rows[1][1] = v5;\n"
;
sb << 
"        rows[1][2] = v6;\n"
"        rows[1][3] = v7;\n"
"        rows[2][0] = v8;\n"
"        rows[2][1] = v9;\n"
"        rows[2][2] = v10;\n"
"        rows[2][3] = v11;\n"
"        rows[3][0] = v12;\n"
"        rows[3][1] = v13;\n"
"        rows[3][2] = v14;\n"
"        rows[3][3] = v15;\n"
"    }\n"
"};\n"
"\n"
"#define SLANG_MATRIX_BINARY_OP(T, op)                                                         \\\n"
"    template<int R, int C>                                                                    \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal, const Matrix<T, R, C>& other) \\\n"
"    {                                                                                         \\\n"
"        Matrix<T, R, C> result;                                                               \\\n"
"        for (int i = 0; i < R; i++)                                                           \\\n"
"            for (int j = 0; j < C; j++)                                                       \\\n"
"                result.rows[i][j] = thisVal.rows[i][j] op other.rows[i][j];                   \\\n"
"        return result;                                                                        \\\n"
"    }\n"
"\n"
"#define SLANG_MATRIX_BINARY_COMPARE_OP(T, op)                                                    \\\n"
"    template<int R, int C>                                                                       \\\n"
"    Matrix<bool, R, C> operator op(const Matrix<T, R, C>& thisVal, const Matrix<T, R, C>& other) \\\n"
"    {                                                                                            \\\n"
"        Matrix<bool, R, C> result;                                                               \\\n"
"        for (int i = 0; i < R; i++)                                                              \\\n"
"            for (int j = 0; j < C; j++)                                                          \\\n"
"                result.rows[i][j] = thisVal.rows[i][j] op other.rows[i][j];                      \\\n"
"        return result;                                                                           \\\n"
"    }\n"
"\n"
"#define SLANG_MATRIX_UNARY_OP(T, op)                            \\\n"
"    template<int R, int C>                                      \\\n"
"    Matrix<T, R, C> operator op(const Matrix<T, R, C>& thisVal) \\\n"
"    {                                                           \\\n"
"        Matrix<T, R, C> result;                                 \\\n"
"        for (int i = 0; i < R; i++)                             \\\n"
"            for (int j = 0; j < C; j++)                         \\\n"
"                result[i].rows[i][j] = op thisVal.rows[i][j];   \\\n"
"        return result;                                          \\\n"
"    }\n"
"\n"
"#define SLANG_INT_MATRIX_OPS(T)           \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, /)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, &)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, |)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, &&)         \\\n"
"    SLANG_MATRIX_BINARY_OP(T, ||)         \\\n"
"    SLANG_MATRIX_BINARY_OP(T, ^)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, %)          \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, !=) \\\n"
"    SLANG_MATRIX_UNARY_OP(T, !)           \\\n"
"    SLANG_MATRIX_UNARY_OP(T, ~)\n"
"#define SLANG_FLOAT_MATRIX_OPS(T)         \\\n"
"    SLANG_MATRIX_BINARY_OP(T, +)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, -)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, *)          \\\n"
"    SLANG_MATRIX_BINARY_OP(T, /)          \\\n"
"    SLANG_MATRIX_UNARY_OP(T, -)           \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <)  \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, >=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, <=) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, ==) \\\n"
"    SLANG_MATRIX_BINARY_COMPARE_OP(T, !=)\n"
"SLANG_INT_MATRIX_OPS(int)\n"
"SLANG_INT_MATRIX_OPS(int8_t)\n"
"SLANG_INT_MATRIX_OPS(int16_t)\n"
"SLANG_INT_MATRIX_OPS(int64_t)\n"
"SLANG_INT_MATRIX_OPS(uint)\n"
"SLANG_INT_MATRIX_OPS(uint8_t)\n"
"SLANG_INT_MATRIX_OPS(uint16_t)\n"
"SLANG_INT_MATRIX_OPS(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_INT_MATRIX_OPS(intptr_t)\n"
"SLANG_INT_MATRIX_OPS(uintptr_t)\n"
"#endif\n"
"\n"
"SLANG_FLOAT_MATRIX_OPS(float)\n"
"SLANG_FLOAT_MATRIX_OPS(double)\n"
"\n"
"#define SLANG_MATRIX_INT_NEG_OP(T)                                        \\\n"
"    template<int R, int C>                                                \\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator-(Matrix<T, R, C> thisVal) \\\n"
"    {                                                                     \\\n"
"        Matrix<T, R, C> result;                                           \\\n"
"        for (int i = 0; i < R; i++)                                       \\\n"
"            for (int j = 0; j < C; j++)                                   \\\n"
"                result.rows[i][j] = 0 - thisVal.rows[i][j];               \\\n"
"        return result;                                                    \\\n"
"    }\n"
"SLANG_MATRIX_INT_NEG_OP(int)\n"
"SLANG_MATRIX_INT_NEG_OP(int8_t)\n"
"SLANG_MATRIX_INT_NEG_OP(int16_t)\n"
"SLANG_MATRIX_INT_NEG_OP(int64_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uint)\n"
"SLANG_MATRIX_INT_NEG_OP(uint8_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uint16_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uint64_t)\n"
"#if SLANG_INTPTR_TYPE_IS_DISTINCT\n"
"SLANG_MATRIX_INT_NEG_OP(intptr_t)\n"
"SLANG_MATRIX_INT_NEG_OP(uintptr_t)\n"
"#endif\n"
"\n"
"#define SLANG_FLOAT_MATRIX_MOD(T)                                                             \\\n"
"    template<int R, int C>                                                                    \\\n"
"    SLANG_FORCE_INLINE Matrix<T, R, C> operator%(Matrix<T, R, C> left, Matrix<T, R, C> right) \\\n"
"    {                                                                                         \\\n"
"        Matrix<T, R, C> result;                                                               \\\n"
"        for (int i = 0; i < R; i++)                                                           \\\n"
"            for (int j = 0; j < C; j++)                                                       \\\n"
"                result.rows[i][j] = _slang_fmod(left.rows[i][j], right.rows[i][j]);           \\\n"
"        return result;                                                                        \\\n"
"    }\n"
"\n"
"SLANG_FLOAT_MATRIX_MOD(float)\n"
"SLANG_FLOAT_MATRIX_MOD(double)\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"#undef SLANG_MATRIX_BINARY_OP\n"
"#undef SLANG_MATRIX_UNARY_OP\n"
"#undef SLANG_INT_MATRIX_OPS\n"
"#undef SLANG_FLOAT_MATRIX_OPS\n"
"#undef SLANG_MATRIX_INT_NEG_OP\n"
"#undef SLANG_FLOAT_MATRIX_MOD\n"
"\n"
"template<typename TResult, typename TInput>\n"
"TResult slang_bit_cast(TInput val)\n"
"{\n"
"    return *(TResult*)(&val);\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
"\n"
"static const int kSlangTorchTensorMaxDim = 5;\n"
"\n"
"struct TensorView\n"
"{\n"
"    uint8_t* data;\n"
"    uint32_t strides[kSlangTorchTensorMaxDim];\n"
"    uint32_t sizes[kSlangTorchTensorMaxDim];\n"
"    uint32_t dimensionCount;\n"
"};\n"
"\n"
"\n"
"TensorView make_tensor_view(\n"
"    torch::Tensor val,\n"
"    const char* name,\n"
"    torch::ScalarType targetScalarType,\n"
"    bool requireContiguous)\n"
"{\n"
"    // We're currently not trying to implicitly cast or transfer to device for two reasons:\n"
"    // 1. There appears to be a bug with .to() where successive calls after the first one fail.\n"
"    // 2. Silent casts like this can cause large memory allocations & unexpected overheads.\n"
"    //    It's better to be explicit.\n"
"\n"
"    // Expect tensors to be on CUDA device\n"
"    if (!val.device().is_cuda())\n"
"        throw std::runtime_error(\n"
"            std::string(name).append(\": tensor is not on CUDA device.\").c_str());\n"
"\n"
"    // Expect tensors to be the right type.\n"
"    if (val.dtype() != targetScalarType)\n"
"        throw std::runtime_error(\n"
"            std::string(name).append(\": tensor is not of the expected type.\").c_str());\n"
"\n"
"    // Check that the tensor is contiguous\n"
"    if (requireContiguous && !val.is_contiguous())\n"
"        throw std::runtime_error(std::string(name).append(\": tensor is not contiguous.\").c_str());\n"
"\n"
"    TensorView res = {};\n"
"    res.dimensionCount = val.dim();\n"
"    res.data = nullptr;\n"
"    size_t elementSize = 4;\n"
"\n"
"    switch (val.scalar_type())\n"
"    {\n"
"    case torch::kInt8:\n"
"    case torch::kUInt8:\n"
"        elementSize = 1;\n"
"        res.data = (uint8_t*)val.data_ptr<uint8_t>();\n"
"        break;\n"
"    case torch::kBFloat16:\n"
"        elementSize = 2;\n"
"        res.data = (uint8_t*)val.data_ptr<torch::BFloat16>();\n"
"        break;\n"
"    case torch::kFloat16:\n"
"        elementSize = 2;\n"
"        res.data = (uint8_t*)val.data_ptr<at::Half>();\n"
"        break;\n"
"    case torch::kInt16:\n"
"        elementSize = 2;\n"
"        res.data = (uint8_t*)val.data_ptr<int16_t>();\n"
"        break;\n"
"    case torch::kFloat32:\n"
"        elementSize = 4;\n"
"        res.data = (uint8_t*)val.data_ptr<float>();\n"
"        break;\n"
"    case torch::kInt32:\n"
"        elementSize = 4;\n"
"        res.data = (uint8_t*)val.data_ptr<int32_t>();\n"
"        break;\n"
"    case torch::kFloat64:\n"
"        elementSize = 8;\n"
"        res.data = (uint8_t*)val.data_ptr<double>();\n"
"        break;\n"
"    case torch::kInt64:\n"
"        elementSize = 8;\n"
"        res.data = (uint8_t*)val.data_ptr<int64_t>();\n"
"        break;\n"
"    case torch::kBool:\n"
"        elementSize = 1;\n"
"        res.data = (uint8_t*)val.data_ptr<bool>();\n"
"        break;\n"
"    }\n"
"\n"
"    if (val.dim() > kSlangTorchTensorMaxDim)\n"
"        throw std::runtime_error(std::string(name)\n"
"                                     .append(\": number of dimensions exceeds limit (\")\n"
"                                     .append(std::to_string(kSlangTorchTensorMaxDim))\n"
"                                     .append(\")\")\n"
"                                     .c_str());\n"
"\n"
"    bool isEmpty = true;\n"
"    for (int i = 0; i < val.dim(); ++i)\n"
"    {\n"
"        res.strides[i] = val.stride(i) * elementSize;\n"
"        if (res.strides[i] == 0)\n"
"            throw std::runtime_error(\n"
"                std::string(name)\n"
"                    .append(\": tensors with broadcasted dimensions are not supported (use \"\n"
"                            \"tensor.contiguous() to make tensor whole)\")\n"
"                    .c_str());\n"
"\n"
"        res.sizes[i] = val.size(i);\n"
"        if (res.sizes[i] > 0)\n"
"            isEmpty = false;\n"
"    }\n"
"\n"
"    if (!res.data && !isEmpty)\n"
"        throw std::runtime_error(std::string(name).append(\": data pointer is invalid.\").c_str());\n"
"\n"
"    return res;\n"
"}\n"
"\n"
"#define SLANG_PRELUDE_EXPORT\n"
"\n"
;
return sb.produceString();
}
